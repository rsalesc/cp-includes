---
data:
  _extendedDependsOn: []
  _extendedRequiredBy:
  - icon: ':warning:'
    path: tests/benchmark/PolynomialRing.cpp
    title: tests/benchmark/PolynomialRing.cpp
  - icon: ':warning:'
    path: tests/benchmark/PowerSeries.cpp
    title: tests/benchmark/PowerSeries.cpp
  - icon: ':warning:'
    path: tests/benchmark/bench.h
    title: tests/benchmark/bench.h
  - icon: ':warning:'
    path: tests/benchmark/main.cpp
    title: tests/benchmark/main.cpp
  - icon: ':warning:'
    path: tests/stress/PolynomialRing.cpp
    title: tests/stress/PolynomialRing.cpp
  - icon: ':warning:'
    path: tests/stress/PowerSeries.cpp
    title: tests/stress/PowerSeries.cpp
  - icon: ':warning:'
    path: tests/stress/main.cpp
    title: tests/stress/main.cpp
  - icon: ':warning:'
    path: tests/stress/stress.cpp
    title: tests/stress/stress.cpp
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: h
  _verificationStatusIcon: ':warning:'
  attributes:
    links:
    - http://stackoverflow.com/a/19841470/2159939
    - http://stackoverflow.com/questions/42833134)
    - http://www.w3.org/2000/svg
    - https://github.com/ifsmirnov/jngen.
    - https://github.com/ifsmirnov/jngen/issues/5
    - https://stackoverflow.com/questions/46740341
  bundledCode: "#line 1 \"tests/jngen.h\"\n/*\n  Copyright (c) 2016-2018 Ivan Smirnov\n\
    \n  Permission is hereby granted, free of charge, to any person obtaining a copy\n\
    \  of this software and associated documentation files (the \"Software\"), to\
    \ deal\n  in the Software without restriction, including without limitation the\
    \ rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or\
    \ sell\n  copies of the Software, and to permit persons to whom the Software is\n\
    \  furnished to do so, subject to the following conditions:\n\n  The above copyright\
    \ notice and this permission notice shall be included in all\n  copies or substantial\
    \ portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY\
    \ OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\
    \ OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n  SOFTWARE.\n*/\n\n/*\n    This file is automatically generated\
    \ and is not supposed to be edited\n  directly. Source code can be found on https://github.com/ifsmirnov/jngen.\n\
    \n  Follow the same link for docs and reference.\n*/\n\n#define JNGEN_VERSION\
    \ 0.1\n\n// https://github.com/ifsmirnov/jngen/issues/5\n#pragma GCC diagnostic\
    \ push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n\n// this warning is\
    \ buggy in clang >= 5\n#if __clang_major__ >= 5\n#pragma GCC diagnostic push\n\
    #pragma GCC diagnostic ignored \"-Wunused-lambda-capture\"\n#endif\n\n#define\
    \ JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, name) \\\nint _ ## name = 0; \\\n\
    Class& name(int val = 1) { _ ## name = val; return *this; }\n\n#define JNGEN_CHAINING_TRAITS_INNER_0(Class)\n\
    #define JNGEN_CHAINING_TRAITS_INNER_1(Class, arg)       JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg)\n#define JNGEN_CHAINING_TRAITS_INNER_2(Class, arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_1(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_3(Class,\
    \ arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_2(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_4(Class, arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_3(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_5(Class,\
    \ arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_4(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_6(Class, arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_5(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_7(Class,\
    \ arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_6(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_8(Class, arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_7(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_9(Class,\
    \ arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_8(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_10(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_9(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_11(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_10(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_12(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_11(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_13(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_12(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_14(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_13(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_15(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_14(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_16(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_15(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_17(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_16(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_18(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_17(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_19(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_18(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_20(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_19(Class, __VA_ARGS__)\n\n#define JNGEN_GET_CHAINING_TRAITS_INNER_IMPL(p1,\
    \ p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18,\
    \ p19, p20, x, ...) x\n\n#define JNGEN_GET_CHAINING_TRAITS_INNER(...) JNGEN_GET_CHAINING_TRAITS_INNER_IMPL(\\\
    \n        __VA_ARGS__,\\\n        JNGEN_CHAINING_TRAITS_INNER_20,\\\n        JNGEN_CHAINING_TRAITS_INNER_19,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_18,\\\n        JNGEN_CHAINING_TRAITS_INNER_17,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_16,\\\n        JNGEN_CHAINING_TRAITS_INNER_15,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_14,\\\n        JNGEN_CHAINING_TRAITS_INNER_13,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_12,\\\n        JNGEN_CHAINING_TRAITS_INNER_11,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_10,\\\n        JNGEN_CHAINING_TRAITS_INNER_9,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_8,\\\n        JNGEN_CHAINING_TRAITS_INNER_7,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_6,\\\n        JNGEN_CHAINING_TRAITS_INNER_5,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_4,\\\n        JNGEN_CHAINING_TRAITS_INNER_3,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_2,\\\n        JNGEN_CHAINING_TRAITS_INNER_1,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_0)\n\n#define JNGEN_CHAINING_TRAITS(Class,\
    \ ...) \\\n    struct Class { JNGEN_GET_CHAINING_TRAITS_INNER(__VA_ARGS__)(Class,\
    \ __VA_ARGS__) };\n\nnamespace jngen {\n\nstruct Config {\n    bool generateLargeObjects\
    \ = false;\n    bool largeOptionIndices = false;\n    bool normalizeEdges = true;\n\
    };\n\n#ifdef JNGEN_DECLARE_ONLY\nextern\n#endif\nConfig config;\n\n} // namespace\
    \ jngen\n\nusing jngen::config;\n\n\n#include <chrono>\n#include <cstdlib>\n#include\
    \ <iostream>\n#include <map>\n#include <stdexcept>\n#include <string>\n#include\
    \ <type_traits>\n#include <vector>\n\n#ifdef JNGEN_DECLARE_ONLY\n#define JNGEN_EXTERN\
    \ extern\n#else\n#define JNGEN_EXTERN\n#endif\n\nnamespace jngen {\n\nclass Exception\
    \ : public std::runtime_error {\npublic:\n    explicit Exception(const std::string&\
    \ s) :\n        std::runtime_error(\"Assertion `\" + s + \"' failed.\")\n    {\
    \  }\n\n    Exception(const std::string& assertMsg, const std::string& expl) :\n\
    \        std::runtime_error(expl + \" (assertion `\" + assertMsg + \"' failed).\"\
    )\n    {  }\n};\n\nclass InternalException : public Exception {\npublic:\n   \
    \ explicit InternalException(const std::string& s) : Exception(s) {}\n\n    InternalException(const\
    \ std::string& assertMsg, const std::string& expl) :\n        Exception(assertMsg,\
    \ expl)\n    {  }\n};\n\n} // namespace jngen\n\n#define JNGEN_ENSURE1(exType,\
    \ cond)\\\ndo\\\n    if (!(cond)) {\\\n        throw exType(#cond);\\\n    }\\\
    \nwhile (false)\n\n#define JNGEN_ENSURE2(exType, cond, msg)\\\ndo\\\n    if (!(cond))\
    \ {\\\n        throw exType(#cond, msg);\\\n    }\\\nwhile (false)\n\n#define\
    \ JNGEN_GET_MACRO(_1, _2, NAME, ...) NAME\n\n#define ensure(...) JNGEN_GET_MACRO(__VA_ARGS__,\
    \ JNGEN_ENSURE2, JNGEN_ENSURE1)\\\n    (jngen::Exception, __VA_ARGS__)\n#define\
    \ ENSURE(...) JNGEN_GET_MACRO(__VA_ARGS__, JNGEN_ENSURE2, JNGEN_ENSURE1)\\\n \
    \   (jngen::InternalException, __VA_ARGS__)\n\nnamespace jngen {\n\ntemplate<typename\
    \ ... Args>\nstd::string format(const std::string& fmt, Args... args) {\n    constexpr\
    \ static char BUF_SIZE = 64;\n    static char BUFFER[BUF_SIZE];\n\n    int bufSize\
    \ = BUF_SIZE;\n    char *buf = BUFFER;\n\n    while (true) {\n        int ret\
    \ = std::snprintf(buf, bufSize, fmt.c_str(), args...);\n        if (ret < bufSize)\
    \ {\n            break;\n        }\n\n        if (bufSize != BUF_SIZE) {\n   \
    \         delete[] buf;\n        }\n\n        bufSize *= 2;\n        buf = new\
    \ char[bufSize];\n    }\n\n    std::string result(buf);\n\n    if (bufSize !=\
    \ BUF_SIZE) {\n        delete[] buf;\n    }\n\n    return result;\n}\n\nclass\
    \ ContextTimer {\npublic:\n    ContextTimer(const std::string& name) : name_(name)\
    \ {\n        start_ = std::chrono::steady_clock::now();\n    }\n\n    ContextTimer()\
    \ : ContextTimer(\"\") {}\n\n    ContextTimer(const ContextTimer&) = delete;\n\
    \    ContextTimer& operator=(const ContextTimer&) = delete;\n    ContextTimer(ContextTimer&&)\
    \ = delete;\n    ContextTimer& operator=(ContextTimer&&) = delete;\n\n    ~ContextTimer()\
    \ {\n        auto dif = std::chrono::steady_clock::now() - start_;\n        auto\
    \ ms = std::chrono::duration_cast<std::chrono::milliseconds>(dif);\n        if\
    \ (!name_.empty()) {\n            std::cerr << \"[\" << name_ << \"] \";\n   \
    \     }\n        std::cerr << ms.count() << \" ms\\n\";\n    }\n\nprivate:\n \
    \   std::string name_;\n    std::chrono::steady_clock::time_point start_;\n};\n\
    \ntemplate<typename F>\nauto distribution(int n, F&& f) -> std::map<decltype(f()),\
    \ int> {\n    std::map<decltype(f()), int> dist;\n    for (int i = 0; i < n; ++i)\
    \ {\n        ++dist[f()];\n    }\n    return dist;\n}\n\ninline void checkLargeParameter(int\
    \ n) {\n    if (!config.generateLargeObjects) {\n        constexpr static int\
    \ BOUND = 5e6;\n        ensure(\n            n <= BOUND,\n            \"If you\
    \ want to generate an object of size > 5'000'000, please set \"\n            \"\
    'config.generateLargeObjects = true'.\");\n    }\n}\n\n// Some type traits helpers.\
    \ Based on ideas from TCPPPL v4.\ntemplate<bool B, typename T = void>\nusing enable_if_t\
    \ = typename std::enable_if<B, T>::type;\n\ntemplate<typename T>\nusing decay_t\
    \ = typename std::decay<T>::type;\n\nnamespace util {\n\ninline long long gcd(long\
    \ long a, long long b) {\n    if (a < 0) {\n        a = -a;\n    }\n    if (b\
    \ < 0) {\n        b = -b;\n    }\n\n    while (a && b) {\n        if (a > b) {\n\
    \            a %= b;\n        } else {\n            b %= a;\n        }\n    }\n\
    \    return a + b;\n}\n\ninline std::vector<std::string> split(std::string s,\
    \ char delimiter) {\n    auto strip = [](std::string s) {\n        size_t l =\
    \ 0;\n        while (l < s.size() && s[l] == ' ') {\n            ++l;\n      \
    \  }\n        s = s.substr(l);\n        while (!s.empty() && s.back() == ' ')\
    \ {\n            s.pop_back();\n        }\n        return s;\n    };\n\n    std::vector<std::string>\
    \ result;\n    s += delimiter;\n    std::string cur;\n\n    for (char c: s) {\n\
    \        if (c == delimiter) {\n            result.push_back(strip(cur));\n  \
    \          cur.clear();\n        } else {\n            cur += c;\n        }\n\
    \    }\n\n    return result;\n}\n\n} // namespace util\n\n} // namespace jngen\n\
    \nusing jngen::format;\nusing jngen::ContextTimer;\nusing jngen::distribution;\n\
    \n#line 319 \"tests/jngen.h\"\n#include <utility>\n#line 322 \"tests/jngen.h\"\
    \n\nnamespace jngen {\nnamespace drawing {\n\nusing Color = std::string;\n\nstruct\
    \ DrawingEngineState {\n    double width;\n    Color stroke;\n    Color fill;\n\
    \    double opacity;\n};\n\nclass DrawingEngine {\npublic:\n    DrawingEngine()\
    \ {}\n    virtual ~DrawingEngine() {}\n\n    virtual void drawPoint(double x,\
    \ double y) = 0;\n    virtual void drawCircle(double x, double y, double r) =\
    \ 0;\n    virtual void drawSegment(double x1, double y1, double x2, double y2)\
    \ = 0;\n    virtual void drawPolygon(\n        const std::vector<std::pair<double,\
    \ double>>& vertices) = 0;\n    virtual void drawText(\n        double x, double\
    \ y, const std::string& s) = 0;\n\n    virtual void setWidth(double width) = 0;\n\
    \    virtual void setStroke(Color color) = 0;\n    virtual void setFill(Color\
    \ color) = 0;\n    virtual void setOpacity(double opacity) = 0;\n\n    virtual\
    \ double width() const = 0;\n    virtual Color stroke() const = 0;\n    virtual\
    \ Color fill() const = 0;\n    virtual double opacity() const = 0;\n\n    DrawingEngineState\
    \ saveState() {\n        return { width(), stroke(), fill(), opacity() };\n  \
    \  }\n\n    void restoreState(const DrawingEngineState& state) {\n        setWidth(state.width);\n\
    \        setStroke(state.stroke);\n        setFill(state.fill);\n        setOpacity(state.opacity);\n\
    \    }\n};\n\n}} // namespace jngen::drawing\n\n\n#include <sstream>\n#line 375\
    \ \"tests/jngen.h\"\n\nnamespace jngen {\nnamespace drawing {\n\nclass SvgEngine\
    \ : public DrawingEngine {\npublic:\n    SvgEngine(double x1 = 0, double y1 =\
    \ 0, double x2 = 50, double y2 = 50);\n\n    virtual ~SvgEngine() {}\n\n    virtual\
    \ void drawPoint(double x, double y) override;\n    virtual void drawCircle(double\
    \ x, double y, double r) override;\n    virtual void drawSegment(\n        double\
    \ x1, double y1, double x2, double y2) override;\n    virtual void drawPolygon(\n\
    \        const std::vector<std::pair<double, double>>& vertices) override;\n \
    \   virtual void drawText(\n        double x, double y, const std::string& s)\
    \ override;\n\n    virtual void setWidth(double width) override;\n    virtual\
    \ void setStroke(Color color) override;\n    virtual void setFill(Color color)\
    \ override;\n    virtual void setOpacity(double opacity) override;\n\n    virtual\
    \ double width() const override { return width_; }\n    virtual Color stroke()\
    \ const override { return strokeColor_; }\n    virtual Color fill() const override\
    \ { return fillColor_; }\n    virtual double opacity() const override { return\
    \ opacity_; }\n\n    std::string serialize() const;\n\nprivate:\n    double lerpX(double\
    \ x) const;\n    double lerpY(double y) const;\n    double scaleSize(double size)\
    \ const;\n\n    std::string getStyle() const;\n\n    std::ostringstream output_;\n\
    \n    double width_;\n    Color strokeColor_;\n    Color fillColor_;\n    double\
    \ opacity_;\n\n    double x1_, y1_, x2_, y2_; // borders\n};\n\n}} // namespace\
    \ jngen::drawing\n\n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_SVG_ENGINE_INL_H\n\
    #ifndef JNGEN_INCLUDE_SVG_ENGINE_INL_H\n#error File \"svg_engine_inl.h\" must\
    \ not be included directly.\n#endif\n\n#include <cmath>\n#line 433 \"tests/jngen.h\"\
    \n\nnamespace jngen {\nnamespace drawing {\n\nstatic char buf[10000];\nconstexpr\
    \ static double WIDTH_SCALE = 8;\nconstexpr static double CANVAS_SIZE = 2000;\n\
    constexpr static int FONT_SIZE = 64;\n\nnamespace {\n\nconst char* colorToString(const\
    \ Color& color) {\n    const static char* NONE = \"none\";\n    if (color.empty())\
    \ {\n        return NONE;\n    }\n    return color.c_str();\n}\n\n// Given x \\\
    in [l, r], return linear interpolation to [L, R]\ndouble lerp(double x, double\
    \ l, double r, double L, double R) {\n    return L + (R - L) * ((x - l) / (r -\
    \ l));\n}\n\n} // namespace\n\nSvgEngine::SvgEngine(double x1, double y1, double\
    \ x2, double y2) :\n    width_(1.0),\n    opacity_(1.0),\n    x1_(x1),\n    y1_(y1),\n\
    \    x2_(x2),\n    y2_(y2)\n{  }\n\nvoid SvgEngine::drawPoint(double x, double\
    \ y) {\n    x = lerpX(x);\n    y = lerpY(y);\n    double w = width_ * WIDTH_SCALE\
    \ * 1.5;\n    std::sprintf(\n        buf,\n        \"<circle cx='%f' cy='%f' r='%f'\
    \ fill='%s' opacity='%f'/>\",\n        x, y, w, colorToString(strokeColor_), opacity_\n\
    \    );\n    output_ << buf << \"\\n\";\n}\n\nvoid SvgEngine::drawCircle(double\
    \ x, double y, double r) {\n    x = lerpX(x);\n    y = lerpY(y);\n    r = scaleSize(r);\n\
    \    std::sprintf(\n        buf,\n        \"<circle cx='%f' cy='%f' r='%f' style='%s'/>\"\
    ,\n        x, y, r, getStyle().c_str()\n    );\n    output_ << buf << \"\\n\"\
    ;\n}\n\nvoid SvgEngine::drawPolygon(\n    const std::vector<std::pair<double,\
    \ double>>& points)\n{\n    output_ << \"<polygon points='\";\n    for (const\
    \ auto& point: points) {\n        output_ << lerpX(point.first) << \",\" << lerpY(point.second)\
    \ << \" \";\n    }\n    output_ << \"' style='\" << getStyle() << \"'/>\\n\";\n\
    }\n\nvoid SvgEngine::drawSegment(\n        double x1, double y1, double x2, double\
    \ y2)\n{\n    x1 = lerpX(x1);\n    y1 = lerpY(y1);\n    x2 = lerpX(x2);\n    y2\
    \ = lerpY(y2);\n    if (std::fabs(x1 - x2) < 1e-9) {\n        x1 = std::round(x1);\n\
    \        x2 = std::round(x2);\n    }\n    if (std::fabs(y1 - y2) < 1e-9) {\n \
    \       y1 = std::round(y1);\n        y2 = std::round(y2);\n    }\n    std::sprintf(\n\
    \        buf,\n        \"<line x1='%f' y1='%f' x2='%f' y2='%f' style='%s'/>\"\
    ,\n        x1, y1, x2, y2, getStyle().c_str()\n    );\n    output_ << buf << \"\
    \\n\";\n}\n\nvoid SvgEngine::drawText(\n    double x, double y, const std::string&\
    \ s)\n{\n    x = std::round(lerpX(x));\n    y = std::round(lerpY(y));\n    std::sprintf(\n\
    \        buf,\n        \"<text x='%f' y='%f' font-size='%d' font-family='Helvetica'>%s</text>\"\
    ,\n        x, y, FONT_SIZE, s.c_str()\n    );\n    output_ << buf << \"\\n\";\n\
    }\n\nvoid SvgEngine::setWidth(double width) {\n    width_ = width;\n}\n\nvoid\
    \ SvgEngine::setStroke(Color color) {\n    strokeColor_ = color;\n}\n\nvoid SvgEngine::setFill(Color\
    \ color) {\n    fillColor_ = color;\n}\n\nvoid SvgEngine::setOpacity(double opacity)\
    \ {\n    opacity_ = opacity;\n}\n\nstd::string SvgEngine::serialize() const {\n\
    \    int offset = std::sprintf(\n        buf,\n        \"<svg xmlns='http://www.w3.org/2000/svg'\
    \ \"\n        \"viewBox='%f %f %f %f'>\\n\",\n        0.0, 0.0, CANVAS_SIZE, CANVAS_SIZE\
    \ * (y2_ - y1_) / (x2_ - x1_)\n    );\n    std::sprintf(\n        buf + offset,\n\
    \        \"<circle cx='%f' cy='%f' r='%f' fill='white'/>\\n\",\n        CANVAS_SIZE/2,\
    \ CANVAS_SIZE/2,\n        std::hypot(CANVAS_SIZE, CANVAS_SIZE * (y2_ - y1_) /\
    \ (x2_ - x1_))\n    );\n\n    return buf + output_.str() + \"</svg>\\n\";\n}\n\
    \ndouble SvgEngine::lerpX(double x) const {\n    return lerp(x, x1_, x2_, 0.,\
    \ CANVAS_SIZE);\n}\n\ndouble SvgEngine::lerpY(double y) const {\n    return lerp(y,\
    \ y2_, y1_, 0., CANVAS_SIZE * (y2_ - y1_) / (x2_ - x1_));\n}\n\ndouble SvgEngine::scaleSize(double\
    \ size) const {\n    return size * CANVAS_SIZE / (x2_ - x1_);\n}\n\nstd::string\
    \ SvgEngine::getStyle() const {\n    static char buf[1024];\n    std::sprintf(\n\
    \        buf,\n        \"stroke-width:%f;stroke:%s;fill:%s;opacity:%f\",\n   \
    \     width_ * WIDTH_SCALE,\n        colorToString(strokeColor_),\n        colorToString(fillColor_),\n\
    \        opacity_\n    );\n    return buf;\n}\n\n}} // namespace jngen::drawing\n\
    \n#undef JNGEN_INCLUDE_SVG_ENGINE_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#include\
    \ <algorithm>\n#include <cmath>\n#include <fstream>\n#include <functional>\n#include\
    \ <initializer_list>\n#line 608 \"tests/jngen.h\"\n#include <memory>\n#line 613\
    \ \"tests/jngen.h\"\n\nnamespace jngen {\nnamespace drawing {\n\nclass Drawer\
    \ {\npublic:\n    Drawer();\n\n    template<typename P>\n    void point(const\
    \ P& p);\n    template<typename T>\n    void point(T x, T y);\n\n    template<typename\
    \ P>\n    void circle(const P& p, double radius);\n    template<typename T>\n\
    \    void circle(T x, T y, double radius);\n\n    template<typename P>\n    void\
    \ segment(const P& p1, const P& p2);\n    template<typename T>\n    void segment(T\
    \ x1, T y1, T x2, T y2);\n\n    template<typename P>\n    void polygon(const std::vector<P>&\
    \ points);\n    template<typename P>\n    void polygon(std::initializer_list<P>\
    \ points);\n\n    void setWidth(double width);\n\n    void setColor(const std::string&\
    \ color);\n\n    void setStroke(const std::string& color);\n\n    void setFill(const\
    \ std::string& color);\n\n    void setOpacity(double opacity);\n\n    void enableGrid(bool\
    \ value) {\n        gridEnabled_ = value;\n    }\n\n    void dumpSvg(const std::string&\
    \ filename);\n\nprivate:\n    struct Point {\n        double x, y;\n        Point()\
    \ {}\n        Point(double x, double y) : x(x), y(y) {}\n    };\n\n    template<typename\
    \ T>\n    Point extractCoords(const T& pt) {\n        return Point(pt.x, pt.y);\n\
    \    }\n\n    template<typename T>\n    Point extractCoords(const std::pair<T,\
    \ T>& pt) {\n        return Point(pt.first, pt.second);\n    }\n\n    typedef\
    \ std::function<void(DrawingEngine*)> DrawRequest;\n\n    typedef std::pair<Point,\
    \ Point> Bbox;\n\n    static Bbox emptyBbox();\n\n    static Bbox unite(const\
    \ Bbox& lhs, const Bbox& rhs);\n\n    static Bbox bbox(const Point& p);\n    static\
    \ Bbox bbox(const std::pair<Point, double>& circle);\n\n    Bbox getBbox() const;\n\
    \n    static Bbox viewportByBbox(const Bbox& bbox);\n\n    void drawAll();\n \
    \   void drawGrid(const Bbox& bbox);\n\n    std::vector<DrawRequest> requests_;\n\
    \n    DrawingEngine* engine_;\n    Bbox bbox_;\n    int requestId_ = 0;\n    bool\
    \ gridEnabled_ = true;\n};\n\ntemplate<typename P>\nvoid Drawer::point(const P&\
    \ p_) {\n    Point p = extractCoords(p_);\n    bbox_ = unite(bbox_ , bbox(Point(p.x,\
    \ p.y)));\n    requests_.push_back([p](DrawingEngine* engine) {\n        engine->drawPoint(p.x,\
    \ p.y);\n    });\n}\n\ntemplate<typename T>\nvoid Drawer::point(T x, T y) {\n\
    \    point(Point(x, y));\n}\n\ntemplate<typename P>\nvoid Drawer::circle(const\
    \ P& p_, double radius) {\n    Point p = extractCoords(p_);\n    bbox_ = unite(bbox_\
    \ , bbox({Point(p.x, p.y), radius}));\n    requests_.push_back([p, radius](DrawingEngine*\
    \ engine) {\n        engine->drawCircle(p.x, p.y, radius);\n    });\n}\n\ntemplate<typename\
    \ T>\nvoid Drawer::circle(T x, T y, double radius) {\n    circle(Point(x, y),\
    \ radius);\n}\n\ntemplate<typename P>\nvoid Drawer::segment(const P& p1_, const\
    \ P& p2_) {\n    Point p1 = extractCoords(p1_);\n    Point p2 = extractCoords(p2_);\n\
    \    bbox_ = unite(bbox_ , bbox(Point(p1.x, p1.y)));\n    bbox_ = unite(bbox_\
    \ , bbox(Point(p2.x, p2.y)));\n    requests_.push_back([p1, p2](DrawingEngine*\
    \ engine) {\n        engine->drawSegment(p1.x, p1.y, p2.x, p2.y);\n    });\n}\n\
    \ntemplate<typename T>\nvoid Drawer::segment(T x1, T y1, T x2, T y2) {\n    segment(Point(x1,\
    \ y1), Point(x2, y2));\n}\n\ntemplate<typename P>\nvoid Drawer::polygon(const\
    \ std::vector<P>& points) {\n    for (const auto& p: points) {\n        bbox_\
    \ = unite(bbox_, bbox(extractCoords(p)));\n    }\n\n    requests_.push_back([points,\
    \ this](DrawingEngine* engine) {\n        std::vector<std::pair<double, double>>\
    \ enginePoints;\n        for (const auto& p: points) {\n            Point pt =\
    \ extractCoords(p);\n            enginePoints.emplace_back(pt.x, pt.y);\n    \
    \    }\n        engine->drawPolygon(enginePoints);\n    });\n}\n\ntemplate<typename\
    \ P>\nvoid Drawer::polygon(std::initializer_list<P> points) {\n    polygon(std::vector<P>(points.begin(),\
    \ points.end()));\n}\n\n#ifndef JNGEN_DECLARE_ONLY\n\nDrawer::Drawer() : bbox_(emptyBbox())\
    \ {\n    setFill(\"\");\n    setStroke(\"black\");\n}\n\nvoid Drawer::setWidth(double\
    \ width) {\n    requests_.push_back([width](DrawingEngine* engine) {\n       \
    \ engine->setWidth(width);\n    });\n}\n\nvoid Drawer::setColor(const std::string&\
    \ color) {\n    setStroke(color);\n    setFill(color);\n}\n\nvoid Drawer::setStroke(const\
    \ std::string& color) {\n    requests_.push_back([color](DrawingEngine* engine)\
    \ {\n        engine->setStroke(color);\n    });\n}\n\nvoid Drawer::setFill(const\
    \ std::string& color) {\n    requests_.push_back([color](DrawingEngine* engine)\
    \ {\n        engine->setFill(color);\n    });\n}\n\nvoid Drawer::setOpacity(double\
    \ opacity) {\n    requests_.push_back([opacity](DrawingEngine* engine) {\n   \
    \     engine->setOpacity(opacity);\n    });\n}\n\nDrawer::Bbox Drawer::emptyBbox()\
    \ {\n    const static double inf = 1e18;\n    return { Point{inf, inf}, Point{-inf,\
    \ -inf} };\n}\n\nDrawer::Bbox Drawer::unite(const Bbox& lhs, const Bbox& rhs)\
    \ {\n    return Bbox{\n            Point{\n                std::min(lhs.first.x,\
    \ rhs.first.x),\n                std::min(lhs.first.y, rhs.first.y)},\n      \
    \      Point{\n                std::max(lhs.second.x, rhs.second.x),\n       \
    \         std::max(lhs.second.y, rhs.second.y)}\n    };\n}\n\nDrawer::Bbox Drawer::bbox(const\
    \ Point& p) {\n    return {p, p};\n}\n\nDrawer::Bbox Drawer::bbox(const std::pair<Point,\
    \ double>& circle) {\n    Point p;\n    double radius;\n    std::tie(p, radius)\
    \ = circle;\n    return {\n            Point{p.x - radius, p.y - radius},\n  \
    \          Point{p.x + radius, p.y + radius}\n    };\n}\n\n/*\nGiven a bbox of\
    \ points, returns a bbox with following properties:\n    - at least 5% margin\
    \ at each side is blank\n    - side lengths differ by at most 1.6\n    - side\
    \ length is at least 10\n    - if it is possible to include (0, 0), include it\
    \ explicitly\n */\nDrawer::Bbox Drawer::viewportByBbox(const Bbox& bbox) {\n \
    \   constexpr static double MIN_SIZE = 10.0;\n    constexpr static double MAX_RATIO\
    \ = 1.6;\n    constexpr static double MARGIN_RATIO = 0.05;\n    constexpr static\
    \ double MAX_RELATIVE_DISTANCE_TO_ZERO = 0.2;\n\n    double lx = bbox.first.x;\n\
    \    double rx = bbox.second.x;\n    double ly = bbox.first.y;\n    double ry\
    \ = bbox.second.y;\n\n    auto extendToSize = [&](double& l, double &r, double\
    \ size) {\n        double shift = (size - (r - l)) / 2;\n        l -= shift;\n\
    \        r += shift;\n    };\n\n    auto extendInterval = [&](double& l, double\
    \ &r) {\n        if (r - l < MIN_SIZE) {\n            if (l >= -1e-9 && r < MIN_SIZE)\
    \ {\n                l = 0;\n                r = MIN_SIZE;\n\n            } else\
    \ if (r <= 1e-9 && l >= -MIN_SIZE) {\n                l = -MIN_SIZE;\n       \
    \         r = 0;\n            } else {\n                extendToSize(l, r, MIN_SIZE);\n\
    \            }\n        }\n\n        if ((l > 0 || r < 0) && std::min(std::abs(l),\
    \ std::abs(r)) <=\n                (r - l) * MAX_RELATIVE_DISTANCE_TO_ZERO)\n\
    \        {\n            if (l > 0) {\n                l = 0;\n            } else\
    \ {\n                r = 0;\n            }\n        }\n\n        double margin\
    \ = (r - l) * MARGIN_RATIO;\n        l -= margin;\n        r += margin;\n    };\n\
    \n    extendInterval(lx, rx);\n    extendInterval(ly, ry);\n\n    if ((rx - lx)\
    \ / (ry - ly) > MAX_RATIO) {\n        extendToSize(ly, ry, (rx - lx) / MAX_RATIO);\n\
    \    } else if ((ry - ly) / (rx - lx) > MAX_RATIO) {\n        extendToSize(lx,\
    \ rx, (ry - ly) / MAX_RATIO);\n    }\n\n    return { Point(lx, ly), Point(rx,\
    \ ry) };\n}\n\nvoid Drawer::drawAll() {\n    for (const auto& request: requests_)\
    \ {\n        request(engine_);\n    }\n}\n\nvoid Drawer::drawGrid(const Bbox&\
    \ bbox) {\n    const static std::vector<int> STEP_DELTA = {20, 25, 20};\n    //\
    \ Step goes like 1, 2, 5, 10, 20, 50, 100, ...\n    constexpr static int SMALL_IN_BIG\
    \ = 5;\n    constexpr static int THRESHOLD = 8;\n    constexpr static int MAX_SPREAD_TO_DRAW_ALL_TICKS\
    \ = 13;\n    constexpr static double TEXT_OFFSET_RATIO = 0.01;\n\n    auto savedState\
    \ = engine_->saveState();\n\n    int step = 5;\n    double spread = std::min(\n\
    \        bbox.second.x - bbox.first.x,\n        bbox.second.y - bbox.first.y);\n\
    \    size_t deltaPos = 2;\n    while (spread / step > THRESHOLD) {\n        step\
    \ = step * STEP_DELTA[deltaPos] / 10;\n        if (++deltaPos == STEP_DELTA.size())\
    \ {\n            deltaPos = 0;\n        }\n    }\n\n    engine_->setWidth(0.5);\n\
    \    engine_->setStroke(\"lightgrey\");\n\n    double smallStep = 1.0 * step /\
    \ SMALL_IN_BIG;\n\n    for (\n            double tick = std::ceil(bbox.first.x\
    \ / smallStep) * smallStep;\n            tick < bbox.second.x;\n            tick\
    \ += smallStep)\n    {\n        if (std::lround(tick) % step != 0) {\n       \
    \     engine_->drawSegment(tick, bbox.first.y, tick, bbox.second.y);\n       \
    \ }\n    }\n\n    for (\n            double tick = std::ceil(bbox.first.y / smallStep)\
    \ * smallStep;\n            tick < bbox.second.y;\n            tick += smallStep)\n\
    \    {\n        if (std::lround(tick) % step != 0) {\n            engine_->drawSegment(bbox.first.x,\
    \ tick, bbox.second.x, tick);\n        }\n    }\n\n    engine_->setWidth(0.75);\n\
    \    engine_->setStroke(\"grey\");\n\n    for (\n            double tick = std::ceil(bbox.first.x\
    \ / step) * step;\n            tick < bbox.second.x;\n            tick += step)\n\
    \    {\n        engine_->drawSegment(tick, bbox.first.y, tick, bbox.second.y);\n\
    \    }\n\n    for (\n            double tick = std::ceil(bbox.first.y / step)\
    \ * step;\n            tick < bbox.second.y;\n            tick += step)\n    {\n\
    \        engine_->drawSegment(bbox.first.x, tick, bbox.second.x, tick);\n    }\n\
    \n    const double textOffsetX =\n        (bbox.second.x - bbox.first.x) * TEXT_OFFSET_RATIO;\n\
    \    const double textOffsetY =\n        (bbox.second.y - bbox.first.y) * TEXT_OFFSET_RATIO;\n\
    \n    auto format = [](double x) {\n        static char buf[10];\n        std::sprintf(buf,\
    \ \"%d\", int(std::lround(x)));\n        return std::string(buf);\n    };\n\n\
    \    if (spread < MAX_SPREAD_TO_DRAW_ALL_TICKS) {\n        step = 1;\n    }\n\n\
    \    for (\n            double tick = std::ceil(bbox.first.y / step) * step;\n\
    \            tick < bbox.second.y;\n            tick += step)\n    {\n       \
    \ engine_->drawText(\n            bbox.first.x + textOffsetX, tick + textOffsetX,\
    \ format(tick));\n    }\n\n    for (\n            double tick = std::ceil(bbox.first.x\
    \ / step) * step;\n            tick < bbox.second.x;\n            tick += step)\n\
    \    {\n        engine_->drawText(\n            tick + textOffsetY, bbox.first.y\
    \ + textOffsetY, format(tick));\n    }\n\n\n    if (spread <= MAX_SPREAD_TO_DRAW_ALL_TICKS)\
    \ {\n        step = 1;\n    }\n\n    engine_->restoreState(savedState);\n}\n\n\
    void Drawer::dumpSvg(const std::string& filename) {\n    if (requests_.empty())\
    \ {\n        return;\n    }\n\n    auto bbox = bbox_;\n    auto viewport = viewportByBbox(bbox);\n\
    \    std::unique_ptr<SvgEngine> svgEngine(new SvgEngine(\n        viewport.first.x,\
    \ viewport.first.y,\n        viewport.second.x, viewport.second.y));\n\n    engine_\
    \ = svgEngine.get();\n    if (gridEnabled_) {\n        drawGrid(viewport);\n \
    \   }\n    drawAll();\n\n    std::string svg = svgEngine->serialize();\n\n   \
    \ std::ofstream out(filename);\n    out << svg;\n    out.close();\n}\n\n#endif\
    \ // JNGEN_DECLARE_ONLY\n\n}} // namespace jngen::drawing\n\nusing jngen::drawing::Drawer;\n\
    using jngen::drawing::Color;\n\n#line 1042 \"tests/jngen.h\"\n\nnamespace jngen\
    \ {\n\nclass Dsu {\npublic:\n    int getRoot(int x);\n\n    bool unite(int x,\
    \ int y);\n\n    bool isConnected() const { return components <= 1; }\n\n    int\
    \ numComponents() const { return components; }\n\n    void extend(size_t size);\n\
    \nprivate:\n    std::vector<int> parent;\n    std::vector<int> rank;\n\n    int\
    \ components = 0;\n};\n\n#ifndef JNGEN_DECLARE_ONLY\n\nint Dsu::getRoot(int x)\
    \ {\n    extend(x);\n\n    return parent[x] == x ? x : (parent[x] = getRoot(parent[x]));\n\
    }\n\nbool Dsu::unite(int x, int y) {\n    extend(std::max(x, y) + 1);\n\n    x\
    \ = getRoot(x);\n    y = getRoot(y);\n    if (x == y) {\n        return false;\n\
    \    }\n\n    if (rank[x] > rank[y]) {\n        std::swap(x, y);\n    }\n    if\
    \ (rank[y] == rank[x]) {\n        ++rank[y];\n    }\n    parent[x] = y;\n\n  \
    \  --components;\n\n    return true;\n}\n\nvoid Dsu::extend(size_t x) {\n    size_t\
    \ last = parent.size() - 1;\n    while (parent.size() < x) {\n        ++components;\n\
    \        parent.push_back(++last);\n        rank.push_back(0);\n    }\n}\n\n#endif\
    \ // JNGEN_DECLARE_ONLY\n\n} // namespace jngen\n\n\nnamespace jngen {\nnamespace\
    \ impl {\n\n// Generated with util/generate_prime_rehash_policy.cpp\n// Necessary\
    \ for anti-unordered_set test.\nextern const unsigned int primeList[]\n#ifndef\
    \ JNGEN_DECLARE_ONLY\n= {\n2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67,\n71, 73, 79, 83, 89, 97, 103, 109, 113, 127, 137, 139, 149,\
    \ 157, 167, 179,\n193, 199, 211, 227, 241, 257, 277, 293, 313, 337, 359, 383,\
    \ 409, 439,\n467, 503, 541, 577, 619, 661, 709, 761, 823, 887, 953, 1031, 1109,\
    \ 1193,\n1289, 1381, 1493, 1613, 1741, 1879, 2029, 2179, 2357, 2549, 2753, 2971,\n\
    3209, 3469, 3739, 4027, 4349, 4703, 5087, 5503, 5953, 6427, 6949, 7517,\n8123,\
    \ 8783, 9497, 10273, 11113, 12011, 12983, 14033, 15173, 16411, 17749,\n19183,\
    \ 20753, 22447, 24281, 26267, 28411, 30727, 33223, 35933, 38873,\n42043, 45481,\
    \ 49201, 53201, 57557, 62233, 67307, 72817, 78779, 85229,\n92203, 99733, 107897,\
    \ 116731, 126271, 136607, 147793, 159871, 172933,\n187091, 202409, 218971, 236897,\
    \ 256279, 277261, 299951, 324503, 351061,\n379787, 410857, 444487, 480881, 520241,\
    \ 562841, 608903, 658753, 712697,\n771049, 834181, 902483, 976369, 1056323, 1142821,\
    \ 1236397, 1337629, 1447153,\n1565659, 1693859, 1832561, 1982627, 2144977, 2320627,\
    \ 2510653, 2716249,\n2938679, 3179303, 3439651, 3721303, 4026031, 4355707, 4712381,\
    \ 5098259,\n5515729, 5967347, 6456007, 6984629, 7556579, 8175383, 8844859, 9569143,\n\
    10352717, 11200489\n}\n#endif // JNGEN_DECLARE_ONLY\n;\n\n} // namespace impl\n\
    } // namespace jngen\n\n#line 1141 \"tests/jngen.h\"\n\nnamespace jngen {\n\n\
    class Graph;\n\nnamespace graph_detail {\n\nclass GraphRandom;\n\nstruct Traits\
    \ {\n    int n;\n    int m;\n    bool directed = false;\n    bool acyclic = false;\n\
    \    bool allowLoops = false;\n    bool allowMulti = false;\n    bool allowAntiparallel\
    \ = false;\n    bool connected = false;\n\n    Traits() {}\n    explicit Traits(int\
    \ n) : n(n) {}\n    Traits(int n, int m) : n(n), m(m) {}\n};\n\nclass BuilderProxy\
    \ {\npublic:\n    BuilderProxy(\n            Traits traits,\n            std::function<Graph(Traits)>\
    \ builder) :\n        traits_(traits),\n        builder_(builder)\n    {  }\n\n\
    \    Graph g() const;\n\n    operator Graph() const;\n\n    BuilderProxy& allowLoops(bool\
    \ value = true) {\n        traits_.allowLoops = value;\n        return *this;\n\
    \    }\n\n    BuilderProxy& allowMulti(bool value = true) {\n        traits_.allowMulti\
    \ = value;\n        return *this;\n    }\n\n    BuilderProxy& allowAntiparallel(bool\
    \ value = true) {\n        traits_.allowAntiparallel = value;\n        return\
    \ *this;\n    }\n\n    BuilderProxy& connected(bool value = true) {\n        traits_.connected\
    \ = value;\n        return *this;\n    }\n\n    BuilderProxy& directed(bool value\
    \ = true) {\n        traits_.directed = value;\n        return *this;\n    }\n\
    \n    BuilderProxy& acyclic(bool value = true) {\n        traits_.acyclic = value;\n\
    \        return *this;\n    }\n\nprivate:\n    Traits traits_;\n    std::function<Graph(Traits)>\
    \ builder_;\n};\n\n} // namespace graph_detail\n\n} // namespace jngen\n\n\n#include\
    \ <iterator>\n#include <unordered_set>\n#line 1223 \"tests/jngen.h\"\n\nnamespace\
    \ jngen {\n\ntemplate<typename T, typename Enable = void>\nstruct Hash;\n\nnamespace\
    \ impl {\n\ninline void hashCombine(uint64_t& h, uint64_t k) {\n    const uint64_t\
    \ m = 0xc6a4a7935bd1e995;\n    const int r = 47;\n\n    k *= m;\n    k ^= k >>\
    \ r;\n    k *= m;\n\n    h ^= k;\n    h *= m;\n\n    h += 0xe6546b64;\n}\n\ntemplate<typename\
    \ Iterator>\nvoid hashCombine(uint64_t& h, Iterator begin, Iterator end) {\n \
    \   Hash<typename std::iterator_traits<Iterator>::value_type> hash;\n    while\
    \ (begin != end) {\n        hashCombine(h, hash(*begin++));\n    }\n}\n\n} //\
    \ namespace impl\n\ntemplate<typename T>\nstruct Hash<\n        T,\n        enable_if_t<std::is_integral<T>::value>>\n\
    {\n    uint64_t operator()(const T& t) const {\n        uint64_t h = 0;\n    \
    \    impl::hashCombine(h, t);\n        return h;\n    }\n};\n\n#define JNGEN_DEFINE_STD_HASH(Type)\\\
    \nnamespace std {\\\ntemplate<>\\\nstruct hash<Type> {\\\n    size_t operator()(const\
    \ Type& value) const {\\\n        return jngen::Hash<Type>{}(value);\\\n    }\\\
    \n};\\\n}\n\n#define JNGEN_DEFINE_STD_HASH_TEMPLATE(T, Type)\\\nnamespace std\
    \ {\\\ntemplate<typename T>\\\nstruct hash<Type> {\\\n    size_t operator()(const\
    \ Type& value) const {\\\n        return jngen::Hash<Type>{}(value);\\\n    }\\\
    \n};\\\n}\n\ntemplate<typename T>\nstruct Hash<std::vector<T>> {\n    uint64_t\
    \ operator()(const std::vector<T>& elements) const {\n        uint64_t h = 0;\n\
    \        impl::hashCombine(h, elements.size());\n        impl::hashCombine(h,\
    \ elements.begin(), elements.end());\n        return h;\n    }\n};\n\ntemplate<typename\
    \ T, typename U>\nstruct Hash<std::pair<T, U>> {\n    uint64_t operator()(const\
    \ std::pair<T, U>& value) const {\n        uint64_t h = 0;\n        impl::hashCombine(h,\
    \ Hash<T>{}(value.first));\n        impl::hashCombine(h, Hash<U>{}(value.second));\n\
    \        return h;\n    }\n};\n\n} // namespace jngen\n\nJNGEN_DEFINE_STD_HASH_TEMPLATE(T,\
    \ std::vector<T>);\n\nnamespace std {\ntemplate<typename T, typename U>\nstruct\
    \ hash<std::pair<T, U>> {\n    size_t operator()(const std::pair<T, U>& value)\
    \ const {\n        return jngen::Hash<std::pair<T, U>>{}(value);\n    }\n};\n\
    } // namespace std\n\n\n#line 1322 \"tests/jngen.h\"\n#include <cctype>\n#line\
    \ 1324 \"tests/jngen.h\"\n#include <set>\n#line 1328 \"tests/jngen.h\"\n\n// TODO:\
    \ adequate error messages\n\nnamespace jngen {\n\nclass Pattern {\n    friend\
    \ class Parser;\npublic:\n    Pattern() : isOrPattern(false), min(1), max(1) {}\n\
    \    Pattern(const std::string& s);\n\n    std::string next(std::function<int(int)>&&\
    \ rnd) const;\n\nprivate:\n    Pattern(Pattern p, std::pair<int, int> quantity);\n\
    \n    Pattern(std::vector<char> chars, std::pair<int, int> quantity);\n\n    std::vector<char>\
    \ chars;\n    std::vector<Pattern> children;\n    bool isOrPattern;\n    int min;\n\
    \    int max;\n\n    static std::map<std::string, Pattern> cachedPatterns_;\n\
    };\n\nclass Parser {\npublic:\n    Pattern parse(const std::string& s) {\n   \
    \     this->s = s;\n        pos = 0;\n        return parsePattern();\n    }\n\n\
    private:\n    static bool isControl(char c);\n\n    static int control(int c);\n\
    \n    int next();\n\n    int peek() const;\n\n    int peekAndMove(size_t& newPos)\
    \ const;\n\n    // TODO: catch overflows\n    int readInt();\n\n    std::pair<int,\
    \ int> parseRange();\n\n    std::pair<int, int> tryParseQuantity();\n\n    std::vector<char>\
    \ parseBlock();\n\n    Pattern parsePattern();\n\n    std::string s;\n    size_t\
    \ pos;\n};\n\n} // namespace jngen\n\n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_PATTERN_INL_H\n\
    #ifndef JNGEN_INCLUDE_PATTERN_INL_H\n#error File \"pattern_inl.h\" must not be\
    \ included directly.\n#endif\n\nnamespace jngen {\n\nPattern::Pattern(const std::string&\
    \ s) {\n    auto iter = cachedPatterns_.find(s);\n    if (iter != cachedPatterns_.end())\
    \ {\n        *this = iter->second;\n        return;\n    }\n    *this = Parser().parse(s);\n\
    \    cachedPatterns_[s] = *this;\n}\n\nPattern::Pattern(Pattern p, std::pair<int,\
    \ int> quantity) :\n    isOrPattern(false),\n    min(quantity.first),\n    max(quantity.second)\n\
    {\n    children.push_back(std::move(p));\n}\n\nPattern::Pattern(std::vector<char>\
    \ chars, std::pair<int, int> quantity) :\n    chars(std::move(chars)),\n    isOrPattern(false),\n\
    \    min(quantity.first),\n    max(quantity.second)\n{  }\n\nstd::map<std::string,\
    \ Pattern> Pattern::cachedPatterns_;\n\nstd::string Pattern::next(std::function<int(int)>&&\
    \ rnd) const {\n    if (isOrPattern) {\n        ENSURE(!children.empty());\n \
    \       return children[rnd(children.size())].next(std::move(rnd));\n    }\n\n\
    \    ENSURE( (!!chars.empty()) ^ (!!children.empty()) );\n\n    int count;\n \
    \   if (min == max) {\n        count = min;\n    } else {\n        count = min\
    \ + rnd(max - min + 1);\n    }\n\n    std::string result;\n    for (int i = 0;\
    \ i < count; ++i) {\n        if (!children.empty()) {\n            for (const\
    \ Pattern& p: children) {\n                result += p.next(std::move(rnd));\n\
    \            }\n        } else {\n            result += chars[rnd(chars.size())];\n\
    \        }\n    }\n\n    return result;\n}\n\nbool Parser::isControl(char c) {\n\
    \    static const std::string CONTROL_CHARS = \"()[]{}|?\";\n    return CONTROL_CHARS.find(c)\
    \ != std::string::npos;\n}\n\nint Parser::control(int c) {\n    return c >> 8;\n\
    }\n\nint Parser::next() {\n    size_t newPos;\n    int result = peekAndMove(newPos);\n\
    \    pos = newPos;\n    return result;\n}\n\nint Parser::peek() const {\n    size_t\
    \ dummy;\n    return peekAndMove(dummy);\n}\n\nint Parser::peekAndMove(size_t&\
    \ newPos) const {\n    newPos = pos;\n    if (pos == s.size()) {\n        return\
    \ -1;\n    }\n    if (s[pos] == '\\\\') {\n        ensure(\n            pos+1\
    \ < s.size(),\n            \"Backslash at the end of the pattern is illegal\"\
    );\n        newPos += 2;\n        return s[pos+1];\n    }\n\n    ++newPos;\n \
    \   int ret = s[pos];\n    return isControl(ret) ? (ret << 8) : ret;\n}\n\n//\
    \ TODO: catch overflows\nint Parser::readInt() {\n    ENSURE(std::isdigit(peek()));\n\
    \n    int res = 0;\n    while (std::isdigit(peek())) {\n        res = res * 10\
    \ + next() - '0';\n    }\n    return res;\n}\n\nstd::pair<int, int> Parser::parseRange()\
    \ {\n    ENSURE(control(next()) == '{');\n\n    int from = readInt();\n\n    int\
    \ nxt = next();\n    if (control(nxt) == '}') {\n        return {from, from};\n\
    \    } else if (nxt == ',' || nxt == '-') {\n        int to = readInt();\n   \
    \     ENSURE(control(next()) == '}');\n        return {from, to};\n    } else\
    \ {\n        ensure(false, \"cannot parse character range\");\n    }\n}\n\nstd::pair<int,\
    \ int> Parser::tryParseQuantity() {\n    std::pair<int, int> quantity = {1, 1};\n\
    \n    int qchar = peek();\n    if (control(qchar) == '?') {\n        quantity\
    \ = {0, 1};\n        next();\n    } else if (control(qchar) == '{') {\n      \
    \  quantity = parseRange();\n    }\n\n    return quantity;\n}\n\nstd::vector<char>\
    \ Parser::parseBlock() {\n    std::vector<char> allowed;\n    char last = -1;\n\
    \    bool inRange = false;\n    while (control(peek()) != ']') {\n        char\
    \ c = next(); // buggy on cases like [a-}]\n        ENSURE(c != -1);\n\n     \
    \   if (c == '-') {\n            ensure(!inRange, \"invalid pattern\");\n    \
    \        inRange = true;\n        } else if (inRange) {\n            ensure(c\
    \ >= last, \"invalid pattern\");\n            for (char i = last; i <= c; ++i)\
    \ {\n                allowed.push_back(i);\n            }\n            inRange\
    \ = false;\n            last = -1;\n        } else {\n            if (last !=\
    \ -1) {\n                allowed.push_back(last);\n            }\n           \
    \ last = c;\n        }\n    }\n\n    ENSURE(control(next()) == ']');\n\n    ENSURE(!inRange);\n\
    \    if (last != -1) {\n        allowed.push_back(last);\n    }\n\n    std::sort(allowed.begin(),\
    \ allowed.end());\n    return allowed;\n}\n\nPattern Parser::parsePattern() {\n\
    \    std::vector<Pattern> orPatterns;\n    Pattern cur;\n\n    while (true) {\n\
    \        int nxt = next();\n        if (nxt == -1 || control(nxt) == ')') {\n\
    \            break;\n        } else if (control(nxt) == '(') {\n            Pattern\
    \ p = parsePattern();\n            cur.children.push_back(Pattern(p, tryParseQuantity()));\n\
    \        } else if (control(nxt) == '|') {\n            orPatterns.emplace_back();\n\
    \            std::swap(orPatterns.back(), cur);\n        } else {\n          \
    \  std::vector<char> chars;\n            if (control(nxt) == '[') {\n        \
    \        chars = parseBlock();\n            } else {\n                ENSURE(!control(nxt));\n\
    \                chars = {static_cast<char>(nxt)};\n            }\n\n        \
    \    cur.children.push_back(Pattern(chars, tryParseQuantity()));\n        }\n\
    \    }\n\n    if (orPatterns.empty()) {\n        return cur;\n    } else {\n \
    \       orPatterns.emplace_back();\n        std::swap(orPatterns.back(), cur);\n\
    \n        Pattern p;\n        p.isOrPattern = true;\n        p.children = orPatterns;\n\
    \        return p;\n    }\n}\n\n} // namespace jngen\n#undef JNGEN_INCLUDE_PATTERN_INL_H\n\
    #endif // JNGEN_DECLARE_ONLY\n\nusing jngen::Pattern;\n\n\n#line 1624 \"tests/jngen.h\"\
    \n#include <limits>\n#include <random>\n#line 1630 \"tests/jngen.h\"\n\nnamespace\
    \ jngen {\n\nvoid assertRandomEngineConsistency();\nvoid assertIntegerSizes();\n\
    void registerGen(int argc, char *argv[], int version = 1);\n\nclass Random;\n\n\
    class BaseTypedRandom {\npublic:\n    BaseTypedRandom(Random& random) : random(random)\
    \ {}\n\nprotected:\n    Random& random;\n};\n\ntemplate<typename T>\nstruct TypedRandom;\n\
    \nuint64_t maskForBound(uint64_t bound);\n\ntemplate<typename Result, typename\
    \ Source>\nResult uniformRandom(Result bound, Random& random, Source (Random::*method)())\
    \ {\n    static_assert(sizeof(Result) <= sizeof(Source),\n        \"uniformRandom:\
    \ Source type must be at least as large as Result type\");\n#ifdef JNGEN_FAST_RANDOM\n\
    \    return (random.*method)() % bound;\n#else\n    Source mask = maskForBound(bound);\n\
    \    while (true) {\n        Source outcome = (random.*method)() & mask;\n   \
    \     if (outcome < static_cast<Source>(bound)) {\n            return outcome;\n\
    \        }\n    }\n#endif\n}\n\nclass Random {\npublic:\n    Random() {\n    \
    \    assertRandomEngineConsistency();\n        assertIntegerSizes();\n       \
    \ std::vector<uint32_t> seedSeq;\n        // 4 random_device calls is enough for\
    \ everyone\n        std::random_device rd;\n        for (size_t i = 0; i < 4;\
    \ ++i) {\n            seedSeq.push_back(rd());\n        }\n        seed(seedSeq);\n\
    \n    }\n\n    void seed(uint32_t val);\n    void seed(const std::vector<uint32_t>&\
    \ seed);\n\n    uint32_t next();\n    uint64_t next64();\n    double nextf();\n\
    \n    int next(int n);\n    long long next(long long n);\n    size_t next(size_t\
    \ n);\n    double next(double n);\n\n    int next(int l, int r);\n    long long\
    \ next(long long l, long long r);\n    size_t next(size_t l, size_t r);\n    double\
    \ next(double l, double r);\n\n    int wnext(int n, int w);\n    long long wnext(long\
    \ long n, int w);\n    size_t wnext(size_t n, int w);\n    double wnext(double\
    \ n, int w);\n\n    int wnext(int l, int r, int w);\n    long long wnext(long\
    \ long l, long long r, int w);\n    size_t wnext(size_t l, size_t r, int w);\n\
    \    double wnext(double l, double r, int w);\n\n    std::string next(const std::string&\
    \ pattern);\n\n    template<typename ... Args>\n    std::string next(const std::string&\
    \ pattern, Args... args) {\n        return next(format(pattern, args...));\n \
    \   }\n\n    template<typename T, typename ... Args>\n    T tnext(Args... args)\
    \ {\n        return TypedRandom<T>{*this}.next(args...);\n    }\n\n    template<typename\
    \ ... Args>\n    std::pair<int, int> nextp(Args... args) {\n        return tnext<std::pair<int,\
    \ int>>(args...);\n    }\n\n    template<typename Iterator>\n    auto choice(Iterator\
    \ begin, Iterator end)\n            -> typename std::iterator_traits<Iterator>::value_type\n\
    \    {\n        auto length = std::distance(begin, end);\n        ensure(length\
    \ > 0, \"Cannot select from a range of negative length\");\n        size_t index\
    \ = tnext<size_t>(length);\n        std::advance(begin, index);\n        return\
    \ *begin;\n    }\n\n    template<typename Container>\n    typename Container::value_type\
    \ choice(const Container& container) {\n        ensure(!container.empty(), \"\
    Cannot select from an empty container\");\n        return choice(container.begin(),\
    \ container.end());\n    }\n\n    template<typename T>\n    T choice(const std::initializer_list<T>&\
    \ ilist) {\n        return choice(ilist.begin(), ilist.end());\n    }\n\n    template<typename\
    \ Numeric>\n    size_t nextByDistribution(const std::vector<Numeric>& distribution)\
    \ {\n        ensure(!distribution.empty(), \"Cannot sample by empty distribution\"\
    );\n        Numeric sum = std::accumulate(\n                distribution.begin(),\
    \ distribution.end(), Numeric(0));\n        auto x = next(sum);\n        for (size_t\
    \ i = 0; i < distribution.size(); ++i) {\n            if (x < distribution[i])\
    \ {\n                return i;\n            }\n            x -= distribution[i];\n\
    \        }\n        return distribution.size() - 1;\n    }\n\n    template<typename\
    \ Numeric>\n    size_t nextByDistribution(const std::initializer_list<Numeric>&\
    \ ilist) {\n        // TODO: looks suboptimal\n        return nextByDistribution(std::vector<Numeric>(ilist));\n\
    \    }\n\nprivate:\n    template<typename T, typename ...Args>\n    T smallWnext(int\
    \ w, Args... args) {\n        ENSURE(std::abs(w) <= WNEXT_LIMIT);\n        T result\
    \ = next(args...);\n        while (w > 0) {\n            result = std::max(result,\
    \ next(args...));\n            --w;\n        }\n        while (w < 0) {\n    \
    \        result = std::min(result, next(args...));\n            ++w;\n       \
    \ }\n        return result;\n    }\n\n    double realWnext(int w) {\n        if\
    \ (w == 0) {\n            return nextf();\n        } else if (w > 0) {\n     \
    \       return std::pow(nextf(), 1.0 / (w + 1));\n        } else {\n         \
    \   return 1.0 - std::pow(nextf(), 1.0 / (-w + 1));\n        }\n    }\n\n    std::mt19937\
    \ randomEngine_;\n    constexpr static int WNEXT_LIMIT = 8;\n};\n\nJNGEN_EXTERN\
    \ Random rnd;\n\ntemplate<>\nstruct TypedRandom<int> : public BaseTypedRandom\
    \ {\n    using BaseTypedRandom::BaseTypedRandom;\n    int next(int n) { return\
    \ random.next(n); }\n    int next(int l, int r) { return random.next(l, r); }\n\
    };\n\ntemplate<>\nstruct TypedRandom<double> : public BaseTypedRandom {\n    using\
    \ BaseTypedRandom::BaseTypedRandom;\n    double next(double n) { return random.next(n);\
    \ }\n    double next(double l, double r) { return random.next(l, r); }\n};\n\n\
    template<>\nstruct TypedRandom<long double> : public BaseTypedRandom {\n    using\
    \ BaseTypedRandom::BaseTypedRandom;\n    double next(double n) { return random.next(n);\
    \ }\n    double next(double l, double r) { return random.next(l, r); }\n};\n\n\
    template<>\nstruct TypedRandom<long long> : public BaseTypedRandom {\n    using\
    \ BaseTypedRandom::BaseTypedRandom;\n    long long next(long long n) { return\
    \ random.next(n); }\n    long long next(long long l, long long r) { return random.next(l,\
    \ r); }\n};\n\ntemplate<>\nstruct TypedRandom<size_t> : public BaseTypedRandom\
    \ {\n    using BaseTypedRandom::BaseTypedRandom;\n    size_t next(size_t n) {\
    \ return random.next(n); }\n    size_t next(size_t l, size_t r) { return random.next(l,\
    \ r); }\n};\n\ntemplate<>\nstruct TypedRandom<char> : public BaseTypedRandom {\n\
    \    using BaseTypedRandom::BaseTypedRandom;\n    char next(char n) { return random.next(n);\
    \ }\n    char next(char l, char r) { return random.next(l, r); }\n};\n\ntemplate<typename\
    \ T>\nstruct TypedRandom : public BaseTypedRandom {\n    using BaseTypedRandom::BaseTypedRandom;\n\
    \    template<typename ... Args>\n    T next(Args... args) { return random.next(args...);\
    \ }\n};\n\nstruct RandomPairTraits {\n    const bool ordered;\n    const bool\
    \ distinct;\n};\n\n#ifdef JNGEN_DECLARE_ONLY\nextern RandomPairTraits opair, dpair,\
    \ odpair, dopair;\n#else\nRandomPairTraits opair{true, false};\nRandomPairTraits\
    \ dpair{false, true};\nRandomPairTraits odpair{true, true};\nRandomPairTraits\
    \ dopair{true, true};\n#endif\n\ntemplate<>\nstruct TypedRandom<std::pair<int,\
    \ int>> : public BaseTypedRandom {\n    using BaseTypedRandom::BaseTypedRandom;\n\
    \n    std::pair<int, int> next(int n) {\n        return next(n, {false, false});\n\
    \    }\n    std::pair<int, int> next(int l, int r) {\n        return next(l, r,\
    \ {false, false});\n    }\n\n    std::pair<int, int> next(int n, RandomPairTraits\
    \ traits) {\n        int first = rnd.next(n);\n        int second;\n        do\
    \ {\n            second = rnd.next(n);\n        } while (traits.distinct && first\
    \ == second);\n        if (traits.ordered && first > second) {\n            std::swap(first,\
    \ second);\n        }\n        return {first, second};\n    }\n    std::pair<int,\
    \ int> next(int l, int r, RandomPairTraits traits) {\n        auto res = next(r-l+1,\
    \ traits);\n        res.first += l;\n        res.second += l;\n        return\
    \ res;\n    }\n\nprivate:\n    std::pair<int, int> ordered(std::pair<int, int>\
    \ pair) const {\n        if (pair.first > pair.second) {\n            std::swap(pair.first,\
    \ pair.second);\n        }\n        return pair;\n    }\n};\n\n} // namespace\
    \ jngen\n\nusing jngen::Random;\n\nusing jngen::rnd;\nusing jngen::opair;\nusing\
    \ jngen::dpair;\nusing jngen::dopair;\nusing jngen::odpair;\n\nusing jngen::registerGen;\n\
    \n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_RANDOM_INL_H\n#ifndef JNGEN_INCLUDE_RANDOM_INL_H\n\
    #error File \"random_inl.h\" must not be included directly.\n#endif\n\nnamespace\
    \ jngen {\n\nvoid assertRandomEngineConsistency() {\n    std::mt19937 engine(1234);\n\
    \    ENSURE(engine() == 822569775,\n        \"std::mt19937 doesn't conform to\
    \ the C++ standard\");\n    ENSURE(engine() == 2137449171,\n        \"std::mt19937\
    \ doesn't conform to the C++ standard\");\n    ENSURE(engine() == 2671936806,\n\
    \        \"std::mt19937 doesn't conform to the C++ standard\");\n}\n\nvoid assertIntegerSizes()\
    \ {\n    static_assert(\n        std::numeric_limits<unsigned char>::max() ==\
    \ 255,\n        \"max(unsigned char) != 255\");\n    static_assert(sizeof(int)\
    \ == 4, \"sizeof(int) != 4\");\n    static_assert(sizeof(long long) == 8, \"sizeof(long\
    \ long) != 8\");\n    static_assert(\n        sizeof(size_t) == 4 || sizeof(size_t)\
    \ == 8,\n        \"sizeof(size_t) is neither 4 nor 8\");\n    static_assert(\n\
    \        sizeof(std::size_t) == sizeof(size_t),\n        \"sizeof(size_t) != sizeof(std::size_t)\"\
    );\n}\n\nvoid registerGen(int argc, char *argv[], int version) {\n    (void)version;\
    \ // unused, only for testlib.h compatibility\n\n    std::vector<uint32_t> seed;\n\
    \    for (int i = 1; i < argc; ++i) {\n        int startPosition = seed.size();\n\
    \        seed.emplace_back();\n        for (char *s = argv[i]; *s; ++s) {\n  \
    \          ++seed[startPosition];\n            seed.push_back(*s);\n        }\n\
    \    }\n    rnd.seed(seed);\n}\n\nuint64_t maskForBound(uint64_t bound) {\n  \
    \  --bound;\n    uint64_t mask = ~0;\n    if ((mask >> 32) >= bound) mask >>=\
    \ 32;\n    if ((mask >> 16) >= bound) mask >>= 16;\n    if ((mask >> 8 ) >= bound)\
    \ mask >>= 8 ;\n    if ((mask >> 4 ) >= bound) mask >>= 4 ;\n    if ((mask >>\
    \ 2 ) >= bound) mask >>= 2 ;\n    if ((mask >> 1 ) >= bound) mask >>= 1 ;\n  \
    \  return mask;\n}\n\nvoid Random::seed(uint32_t val) {\n    randomEngine_.seed(val);\n\
    }\n\nvoid Random::seed(const std::vector<uint32_t>& seed) {\n    std::seed_seq\
    \ seq(seed.begin(), seed.end());\n    randomEngine_.seed(seq);\n}\n\nuint32_t\
    \ Random::next() {\n    return randomEngine_();\n}\n\nuint64_t Random::next64()\
    \ {\n    uint64_t a = next();\n    uint64_t b = next();\n    return (a << 32)\
    \ ^ b;\n}\n\ndouble Random::nextf() {\n    return (double)randomEngine_() / randomEngine_.max();\n\
    }\n\nint Random::next(int n) {\n    ensure(n > 0);\n    return uniformRandom(n,\
    \ *this, (uint32_t (Random::*)())&Random::next);\n}\n\nlong long Random::next(long\
    \ long n) {\n    ensure(n > 0);\n    return uniformRandom(n, *this, &Random::next64);\n\
    }\n\nsize_t Random::next(size_t n) {\n    ensure(n > 0);\n    return uniformRandom(n,\
    \ *this, &Random::next64);\n}\n\ndouble Random::next(double n) {\n    ensure(n\
    \ >= 0);\n    return nextf() * n;\n}\n\nint Random::next(int l, int r) {\n   \
    \ ensure(l <= r);\n    uint32_t n = static_cast<uint32_t>(r) - l + 1;\n    return\
    \ l + uniformRandom(\n        n, *this, (uint32_t (Random::*)())&Random::next);\n\
    }\n\nlong long Random::next(long long l, long long r) {\n    ensure(l <= r);\n\
    \    uint64_t n = static_cast<uint64_t>(r) - l + 1;\n    return l + uniformRandom(n,\
    \ *this, &Random::next64);\n}\n\nsize_t Random::next(size_t l, size_t r) {\n \
    \   ensure(l <= r);\n    uint64_t n = static_cast<uint64_t>(r) - l + 1;\n    return\
    \ l + uniformRandom(n, *this, &Random::next64);\n}\n\ndouble Random::next(double\
    \ l, double r) {\n    ensure(l <= r);\n    return l + next(r-l);\n}\n\nint Random::wnext(int\
    \ n, int w) {\n    ensure(n > 0);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n   \
    \     return smallWnext<int>(w, n);\n    } else {\n        double t = realWnext(w);\n\
    \        return n * t;\n    }\n}\n\nlong long Random::wnext(long long n, int w)\
    \ {\n    ensure(n > 0);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n        return\
    \ smallWnext<long long>(w, n);\n    } else {\n        return n * realWnext(w);\n\
    \    }\n}\n\nsize_t Random::wnext(size_t n, int w) {\n    ensure(n > 0);\n   \
    \ if (std::abs(w) <= WNEXT_LIMIT) {\n        return smallWnext<size_t>(w, n);\n\
    \    } else {\n        return n * realWnext(w);\n    }\n}\n\ndouble Random::wnext(double\
    \ n, int w) {\n    ensure(n >= 0);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n  \
    \      return smallWnext<double>(w, n);\n    } else {\n        return realWnext(w)\
    \ * n;\n    }\n}\n\nint Random::wnext(int l, int r, int w) {\n    ensure(l <=\
    \ r);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n        return smallWnext<int>(w,\
    \ l, r);\n    } else {\n        uint32_t n = static_cast<uint32_t>(r) - l + 1;\n\
    \        return l + static_cast<uint32_t>(n * realWnext(w));\n    }\n}\n\nlong\
    \ long Random::wnext(long long l, long long r, int w) {\n    ensure(l <= r);\n\
    \    if (std::abs(w) <= WNEXT_LIMIT) {\n        return smallWnext<long long>(w,\
    \ l, r);\n    } else {\n        uint64_t n = static_cast<uint64_t>(r) - l + 1;\n\
    \        return l + static_cast<uint64_t>(n * realWnext(w));\n    }\n}\n\nsize_t\
    \ Random::wnext(size_t l, size_t r, int w) {\n    ensure(l <= r);\n    if (std::abs(w)\
    \ <= WNEXT_LIMIT) {\n        return smallWnext<size_t>(w, l, r);\n    } else {\n\
    \        uint64_t n = static_cast<uint64_t>(r) - l + 1;\n        return l + static_cast<uint64_t>(n\
    \ * realWnext(w));\n    }\n}\n\ndouble Random::wnext(double l, double r, int w)\
    \ {\n    ensure(l <= r);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n        return\
    \ smallWnext<double>(w, l, r);\n    } else {\n        return realWnext(w) * (r\
    \ - l) + l;\n    }\n}\n\nstd::string Random::next(const std::string& pattern)\
    \ {\n    return Pattern(pattern).next([this](int n) { return next(n); });\n}\n\
    \n} // namespace jngen\n#undef JNGEN_INCLUDE_RANDOM_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\
    \n\n#line 2130 \"tests/jngen.h\"\n\nnamespace jngen {\nnamespace options {\n\n\
    struct Range {\n    int first;\n    int last;\n    int step;\n\n    Range(int\
    \ first, int last, int step = 1) :\n        first(first),\n        last(last),\n\
    \        step(step)\n    {\n        ensure(first <= last);\n        ensure(step\
    \ > 0);\n    }\n\n    class iterator {\n    public:\n        using iterator_category\
    \ = std::forward_iterator_tag;\n        using value_type = int;\n        using\
    \ reference = const int&;\n        using pointer = const int*;\n        using\
    \ difference_type = int;\n\n        iterator(int value, int step, int last) :\n\
    \            value_(value),\n            step_(step),\n            last_(last)\n\
    \        {  }\n\n        iterator& operator++() {\n            ensure(value_ <=\
    \ last_, \"Cannot increment past-the-end iterator\");\n            value_ += step_;\n\
    \            return *this;\n        }\n\n        iterator operator++(int) {\n\
    \            iterator copy = *this;\n            ++*this;\n            return\
    \ copy;\n        }\n\n        int operator*() const {\n            ensure(value_\
    \ <= last_, \"Cannot dereference past-the-end iterator\");\n            return\
    \ value_;\n        }\n\n        bool operator==(const iterator& other) const {\n\
    \            if (value_ <= last_) {\n                return value_ == other.value_;\n\
    \            }\n            return other.value_ > last_;\n        }\n\n      \
    \  bool operator!=(const iterator& other) const {\n            return !(*this\
    \ == other);\n        }\n\n    private:\n        int value_;\n        int step_;\n\
    \        int last_;\n    };\n\n    iterator begin() const {\n        return {\
    \ first, step, last };\n    }\n\n    iterator end() const {\n        return {\
    \ last + 1, step, last };\n    }\n\n    static Range fromString(std::string s)\
    \ {\n        for (char& c: s) {\n            ensure(c != ' ', \"No spaces allowed\
    \ in range description\");\n            if (c == ':') {\n                c = '\
    \ ';\n            }\n        }\n\n        std::istringstream ss(s);\n        int\
    \ first = 1;\n        int last = std::numeric_limits<int>::max() - 1;\n      \
    \  int step = 1;\n        if (!(ss >> first)) {\n            ensure(false, \"\
    Failed to parse range\");\n        }\n        if (!(ss >> last)) {\n         \
    \   return Range(first, last, step);\n        }\n        if (!(ss >> step)) {\n\
    \            return Range(first, last, step);\n        }\n        return Range(first,\
    \ last, step);\n    }\n};\n\n} // namespace options\n} // namespace jngen\n\n\n\
    #line 2237 \"tests/jngen.h\"\n\nnamespace jngen {\n\nnamespace detail {\n\ntemplate<typename\
    \ T>\nconstexpr bool isValidOptionType() {\n    return std::is_same<T, std::string>::value\
    \ ||\n        (std::is_arithmetic<T>::value && !std::is_same<T, char>::value);\n\
    }\n\ntemplate<typename T>\nusing StringIfCharPtrElseT = typename std::conditional<\n\
    \    std::is_same<typename std::decay<T>::type, const char*>::value ||\n     \
    \   std::is_same<typename std::decay<T>::type, char*>::value,\n    std::string,\n\
    \    T>::type;\n\n} // namespace detail\n\nstruct Index {\n    size_t index;\n\
    \    std::string name;\n\n    Index(size_t index) : index(index) {\n        if\
    \ (!config.largeOptionIndices) {\n            ensure(\n                index <\
    \ 32,\n                \"Looks like you called getOpt('c'). Consider using \"\n\
    \                \"getOpt(\\\"c\\\") or set 'config.largeOptionIndices = true'\
    \ \"\n                \"if you indeed have more than 32 options.\");\n       \
    \ }\n    }\n\n    Index(const std::string& name) : name(name) {\n        ensure(!name.empty(),\
    \ \"Variable name cannot be empty\");\n    }\n\n    bool isNamed() const {\n \
    \       return !name.empty();\n    }\n};\n\nstruct VariableMap {\n    std::vector<std::string>\
    \ positional;\n    std::map<std::string, std::string> named;\n\n    int count(size_t\
    \ pos) const {\n        return pos < positional.size();\n    }\n\n    int count(const\
    \ std::string& name) const {\n        return named.count(name);\n    }\n\n   \
    \ std::string operator[](size_t pos) const {\n        if (!count(pos)) {\n   \
    \         return \"\";\n        }\n        return positional.at(pos);\n    }\n\
    \n    std::string operator[](const std::string& name) const {\n        if (!count(name))\
    \ {\n            return \"\";\n        }\n        return named.at(name);\n   \
    \ }\n\n    int count(const Index& index) const {\n        if (index.isNamed())\
    \ {\n            return count(index.name);\n        } else {\n            return\
    \ count(index.index);\n        }\n    }\n\n    std::string operator[](const Index&\
    \ index) const {\n        if (index.isNamed()) {\n            return (*this)[index.name];\n\
    \        } else {\n            return (*this)[index.index];\n        }\n    }\n\
    \n    void assertExistence(const Index& index) const {\n        if (count(index))\
    \ {\n            return;\n        }\n        if (index.isNamed()) {\n        \
    \    ensure(false, format(\n                    \"There is no variable with name\
    \ '%s'\", index.name.c_str()));\n        } else {\n            ensure(false, format(\n\
    \                    \"There is no variable with index %d\", index.index));\n\
    \        }\n    }\n\n    bool initialized = false;\n};\n\ntemplate<typename T>\n\
    class PendingVariable {\npublic:\n    explicit PendingVariable(std::string value)\
    \ :\n        value_(std::move(value))\n    {  }\n\n    PendingVariable(std::string\
    \ value, T defaultValue) :\n        value_(std::move(value)),\n        default_(std::move(defaultValue))\n\
    \    {  }\n\n    explicit PendingVariable(std::nullptr_t, T defaultValue) :\n\
    \        valid_(false),\n        default_(std::move(defaultValue))\n    {  }\n\
    \n    // We need this check in order to make the following work:\n    // string\
    \ s = getOpt(0);\n    // s = getOpt(0);\n    // Weird things happen if we allow\
    \ all kind of casts. See\n    // https://stackoverflow.com/questions/46740341\n\
    \    template<\n        typename U,\n        typename std::enable_if<\n      \
    \      detail::isValidOptionType<U>()>::type* = nullptr>\n    operator U() const\n\
    \    {\n        if (!valid_) {\n            return static_cast<U>(default_);\n\
    \        }\n\n        std::istringstream ss(value_);\n        U t;\n        if\
    \ (ss >> t) {\n            return t;\n        } else {\n            ensure(\n\
    \                false,\n                format(\n                    \"Cannot\
    \ parse option. Raw value: '%s'\",\n                    value_.c_str()));\n  \
    \      }\n    }\n\n    // TODO: getOpt operators, like getOpt(\"n\") == 100\n\n\
    private:\n    bool valid_ = true;\n    std::string value_;\n    T default_;\n\
    };\n\ntemplate<>\nclass PendingVariable<void> {\npublic:\n    explicit PendingVariable(std::string\
    \ value) :\n        value_(std::move(value))\n    {  }\n\n    // We need this\
    \ check in order to make the following work:\n    // string s = getOpt(0);\n \
    \   // s = getOpt(0);\n    // Weird things happen if we allow all kind of casts.\
    \ See\n    // https://stackoverflow.com/questions/46740341\n    template<\n  \
    \      typename U,\n        typename std::enable_if<\n            detail::isValidOptionType<U>()>::type*\
    \ = nullptr>\n    operator U() const\n    {\n        std::istringstream ss(value_);\n\
    \        U t;\n        if (ss >> t) {\n            return t;\n        } else {\n\
    \            ensure(\n                false,\n                format(\n      \
    \              \"Cannot parse option. Raw value: '%s'\",\n                   \
    \ value_.c_str()));\n        }\n    }\n\nprivate:\n    std::string value_;\n};\n\
    \n// TODO: think about seed as a last argument\ninline VariableMap parseArguments(const\
    \ std::vector<std::string>& args) {\n    VariableMap result;\n\n    auto setNamedVar\
    \ = [&result](\n            const std::string& name,\n            const std::string&\
    \ value)\n    {\n        ensure(\n            !result.count(value),\n        \
    \    \"Named arguments must have distinct names\");\n        result.named[name]\
    \ = value;\n    };\n\n    std::string pendingVarName;\n\n    for (const std::string&\
    \ s: args) {\n        if (s == \"-\") {\n            continue;\n        }\n  \
    \      if (s == \"--\") {\n            break;\n        }\n\n        if (s[0] !=\
    \ '-') {\n            if (!pendingVarName.empty()) {\n                setNamedVar(pendingVarName,\
    \ s);\n                pendingVarName = \"\";\n            } else {\n        \
    \        result.positional.push_back(s);\n            }\n            continue;\n\
    \        }\n\n        if (!pendingVarName.empty()) {\n            result.named[pendingVarName]\
    \ = \"1\";\n            pendingVarName = \"\";\n        }\n\n        std::string\
    \ name;\n        std::string value;\n        bool foundEq = false;\n        for\
    \ (char c: s.substr(1)) {\n            if (!foundEq && c == '=') {\n         \
    \       foundEq = true;\n            } else {\n                if (foundEq) {\n\
    \                    value += c;\n                } else {\n                 \
    \   name += c;\n                }\n            }\n        }\n        if (foundEq)\
    \ {\n            setNamedVar(name, value);\n        } else {\n            pendingVarName\
    \ = name;\n        }\n\n        setNamedVar(name, value);\n    }\n\n    if (!pendingVarName.empty())\
    \ {\n        result.named[pendingVarName] = \"1\";\n    }\n\n    result.initialized\
    \ = true;\n    return result;\n}\n\nJNGEN_EXTERN VariableMap vmap;\n\nnamespace\
    \ detail {\n\ninline PendingVariable<void> getOpt(const Index& index) {\n    ensure(\n\
    \        vmap.initialized,\n        \"parseArgs(args, argv) must be called before\
    \ getOpt(...)\");\n    vmap.assertExistence(index);\n    return PendingVariable<void>(vmap[index]);\n\
    }\n\ntemplate<typename T, typename U = detail::StringIfCharPtrElseT<T>>\nPendingVariable<U>\
    \ getOpt(const Index& index, const T& defaultValue) {\n    ensure(\n        vmap.initialized,\n\
    \        \"parseArgs(args, argv) must be called before getOpt(...)\");\n    if\
    \ (vmap.count(index)) {\n        return PendingVariable<U>(vmap[index], U{defaultValue});\n\
    \    } else {\n        return PendingVariable<U>(nullptr, U{defaultValue});\n\
    \    }\n}\n\ninline bool hasOpt(const Index& index) {\n    return vmap.count(index);\n\
    }\n\ntemplate<typename T>\nbool readVariable(const std::string& value, T& var)\
    \ {\n    std::istringstream ss(value);\n\n    T t;\n    if (ss >> t) {\n     \
    \   var = t;\n        return true;\n    }\n    return false;\n}\n\ninline int\
    \ getNamedImpl(std::vector<std::string>::const_iterator) { return 0; }\n\ntemplate<typename\
    \ T, typename ... Args>\nint getNamedImpl(\n    std::vector<std::string>::const_iterator\
    \ it, T& var, Args&... args)\n{\n    T value;\n    int res = 0;\n    if (readVariable(vmap[*it],\
    \ value)) {\n        var = value;\n        ++res;\n    }\n    res += getNamedImpl(++it,\
    \ args...);\n    return res;\n}\n\ninline int getPositionalImpl(size_t) { return\
    \ 0; }\n\ntemplate<typename T, typename ... Args>\nint getPositionalImpl(size_t\
    \ index, T& var, Args&... args) {\n    T value;\n    int res = 0;\n    if (readVariable(vmap[index],\
    \ value)) {\n        var = value;\n        ++res;\n    }\n    res += getPositionalImpl(index\
    \ + 1, args...);\n    return res;\n}\n\n} // namespace detail\n\ntemplate<typename\
    \ ... Args>\nint doGetNamed(const std::string& names, Args&... args) {\n    ensure(\n\
    \        vmap.initialized,\n        \"parseArgs(args, argv) must be called before\
    \ getNamed(...)\");\n\n    auto namesSplit = util::split(names, ',');\n\n    ENSURE(\n\
    \        namesSplit.size() == sizeof...(args),\n        \"Number of names is not\
    \ equal to number of variables\");\n\n    return detail::getNamedImpl(namesSplit.begin(),\
    \ args...);\n}\n\ntemplate<typename ... Args>\nint getPositional(Args&... args)\
    \ {\n    ensure(\n        vmap.initialized,\n        \"parseArgs(args, argv) must\
    \ be called before getPositional(...)\");\n\n    return detail::getPositionalImpl(0,\
    \ args...);\n}\n\ninline void parseArgs(int argc, char *argv[]) {\n    vmap =\
    \ parseArguments(std::vector<std::string>(argv + 1, argv + argc));\n}\n\ninline\
    \ PendingVariable<void> getOpt(size_t index) {\n    return detail::getOpt(Index(index));\n\
    }\n\ninline PendingVariable<void> getOpt(const std::string& name) {\n    return\
    \ detail::getOpt(Index(name));\n}\n\ntemplate<typename T, typename U = detail::StringIfCharPtrElseT<T>>\n\
    PendingVariable<U> getOpt(size_t index, const T& defaultValue) {\n    return detail::getOpt(Index(index),\
    \ defaultValue);\n}\n\ntemplate<typename T, typename U = detail::StringIfCharPtrElseT<T>>\n\
    PendingVariable<U> getOpt(const std::string& name, const T& defaultValue) {\n\
    \    return detail::getOpt(Index(name), defaultValue);\n}\n\ninline bool hasOpt(size_t\
    \ index) {\n    return vmap.count(index);\n}\n\ninline bool hasOpt(const std::string&\
    \ name) {\n    return vmap.count(name);\n}\n\ninline options::Range parseRange(const\
    \ std::string& value) {\n    return options::Range::fromString(value);\n\n}\n\n\
    } // namespace jngen\n\nusing jngen::parseArgs;\nusing jngen::getOpt;\nusing jngen::hasOpt;\n\
    using jngen::parseRange;\n\nusing jngen::getPositional;\n\n#define getNamed(...)\
    \ ::jngen::doGetNamed(#__VA_ARGS__, __VA_ARGS__)\n\n\n#line 2641 \"tests/jngen.h\"\
    \n\nnamespace jngen {\n\ntemplate<int N> struct PTag : PTag<N-1> {};\ntemplate<>\
    \ struct PTag<0> {};\nstruct PTagMax : PTag<20> {};\n\nstruct OutputModifier {\n\
    \    int addition = 0;\n    bool printN = false;\n    bool printM = false;\n\n\
    \    int printParents;\n    bool printEdges = true;\n    bool printWeights = true;\n\
    \n    char sep = ' ';\n};\n\nJNGEN_EXTERN OutputModifier defaultMod;\n\ntemplate<typename\
    \ T>\nclass Repr {\n    friend std::ostream& operator<<(std::ostream& out, const\
    \ Repr& repr) {\n        repr.print(out);\n        return out;\n    }\n\n    template<typename\
    \ P>\n    friend Repr<P> repr(const P& t);\n\n    template<typename P>\n    friend\
    \ class ReprProxy;\n\nprotected:\n    Repr() = delete;\n    Repr(const Repr<T>&)\
    \ = default;\n    Repr<T>& operator=(const Repr<T>&) = default;\n    Repr(Repr<T>&&)\
    \ = default;\n    Repr<T>& operator=(Repr<T>&&) = default;\n\npublic:\n    Repr(const\
    \ T& object) :\n        object_(object),\n        mod_(defaultMod)\n    {  }\n\
    \n    Repr<T>& add1(bool value = true) {\n        mod_.addition = value;\n   \
    \     return *this;\n    }\n\n    Repr<T>& printN(bool value = true) {\n     \
    \   mod_.printN = value;\n        return *this;\n    }\n\n    Repr<T>& printM(bool\
    \ value = true) {\n        mod_.printM = value;\n        return *this;\n    }\n\
    \n    Repr<T>& printParents(int value = -1) {\n        mod_.printParents = value;\n\
    \        mod_.printEdges = false;\n        return *this;\n    }\n\n    Repr<T>&\
    \ printEdges(bool value = true) {\n        mod_.printEdges = value;\n        if\
    \ (!value) {\n            mod_.printParents = -1;\n        }\n        return *this;\n\
    \    }\n\n    Repr<T>& printWeights(bool value = true) {\n        mod_.printWeights\
    \ = value;\n        return *this;\n    }\n\n    Repr<T>& endl(bool value = true)\
    \ {\n        mod_.sep = value ? '\\n' : ' ';\n        return *this;\n    }\n\n\
    private:\n    void print(std::ostream& out) const {\n        printValue(out, object_,\
    \ mod_, PTagMax{});\n    }\n\n    const T& object_;\n\nprotected:\n    OutputModifier\
    \ mod_;\n};\n\nclass BaseReprProxy {};\n\ntemplate<typename T>\nclass ReprProxy\
    \ : public BaseReprProxy {\n    friend std::ostream& operator<<(std::ostream&\
    \ out, const ReprProxy& proxy) {\n        Repr<T> repr(static_cast<const T&>(proxy));\n\
    \        return out << repr;\n    }\n\npublic:\n    Repr<T> add1(bool value =\
    \ true) {\n        Repr<T> repr(static_cast<const T&>(*this));\n        repr.add1(value);\n\
    \        return repr;\n    }\n\n    Repr<T> printN(bool value = true) {\n    \
    \    Repr<T> repr(static_cast<const T&>(*this));\n        repr.printN(value);\n\
    \        return repr;\n    }\n\n    Repr<T> printM(bool value = true) {\n    \
    \    Repr<T> repr(static_cast<const T&>(*this));\n        repr.printM(value);\n\
    \        return repr;\n    }\n\n    Repr<T> printParents(int value = -1) {\n \
    \       Repr<T> repr(static_cast<const T&>(*this));\n        repr.printParents(value);\n\
    \        return repr;\n    }\n\n    Repr<T> printEdges(bool value = true) {\n\
    \        Repr<T> repr(static_cast<const T&>(*this));\n        repr.printEdges(value);\n\
    \        return repr;\n    }\n\n    Repr<T> printWeights(bool value = true) {\n\
    \        Repr<T> repr(static_cast<const T&>(*this));\n        repr.printWeights(value);\n\
    \        return repr;\n    }\n\n    Repr<T> endl(bool value = true) {\n      \
    \  Repr<T> repr(static_cast<const T&>(*this));\n        repr.endl(value);\n  \
    \      return repr;\n    }\n\nprotected:\n    ReprProxy() {\n        static_assert(\n\
    \            std::is_base_of<ReprProxy<T>, T>::value,\n            \"ReprProxy<T>\
    \ must be inherited by T\");\n    }\n};\n\ntemplate<typename T>\nRepr<T> repr(const\
    \ T& t) {\n    return Repr<T>(t);\n}\n\nclass DefaultModSetter : public Repr<int>\
    \ {\n    friend DefaultModSetter setMod();\n\nprivate:\n    DefaultModSetter(int\
    \ val) :\n        Repr<int>(val)\n    {  }\n\npublic:\n    ~DefaultModSetter()\
    \ {\n        defaultMod = mod_;\n    }\n\n    Repr<int>& reset() {\n        mod_\
    \ = OutputModifier();\n        return *this;\n    }\n};\n\ninline DefaultModSetter\
    \ setMod() {\n    static int dummy = 0;\n    return DefaultModSetter(dummy);\n\
    }\n\n} // namespace jngen\n\nusing jngen::repr;\nusing jngen::setMod;\n\n\n#line\
    \ 2834 \"tests/jngen.h\"\n#include <tuple>\n#line 2836 \"tests/jngen.h\"\n#include\
    \ <typeinfo>\n#line 2839 \"tests/jngen.h\"\n\nnamespace jngen {\n\nnamespace detail\
    \ {\n\n// TODO: maybe make it more clear SFINAE, like boost::has_left_shift<X,Y>?\n\
    // TODO: make these defines namespace independent\n\n#define JNGEN_DEFINE_FUNCTION_CHECKER(name,\
    \ expr)\\\ntemplate<typename T, typename Enable = void>\\\nclass Has ## name ##\
    \ Helper: public std::false_type {};\\\n\\\ntemplate<typename T>\\\nclass Has\
    \ ## name ## Helper<T,\\\n    decltype(void(\\\n        expr\\\n    ))\\\n> :\
    \ public std::true_type {};\\\n\n#define JNGEN_HAS_FUNCTION(name)\\\n    ::jngen::detail::Has\
    \ ## name ## Helper<T>::value\n\nJNGEN_DEFINE_FUNCTION_CHECKER(\n    OstreamMethod,\n\
    \    std::declval<std::ostream&>().operator<< (std::declval<T>())\n)\n\nJNGEN_DEFINE_FUNCTION_CHECKER(\n\
    \    OstreamFreeFunction,\n    std::operator<<(std::declval<std::ostream&>(),\
    \ std::declval<T>())\n)\n\nJNGEN_DEFINE_FUNCTION_CHECKER(\n    Plus,\n    T(std::declval<T>()\
    \ + 1)\n)\n\nJNGEN_DEFINE_FUNCTION_CHECKER(\n    Container,\n    std::distance(std::declval<T>().begin(),\
    \ std::declval<T>().end())\n)\n\n#define JNGEN_HAS_OSTREAM()\\\n    (JNGEN_HAS_FUNCTION(OstreamMethod)\
    \ ||\\\n        JNGEN_HAS_FUNCTION(OstreamFreeFunction))\n\ntemplate<typename\
    \ T>\nstruct VectorDepth {\n    constexpr static int value = 0;\n};\n\ntemplate<typename\
    \ T, template <typename...> class C>\nstruct VectorDepth<C<T>> {\n    constexpr\
    \ static int value =\n        std::is_base_of<\n            std::vector<T>,\n\
    \            C<T>\n        >::value ? VectorDepth<T>::value + 1 : 0;\n};\n\n}\
    \ // namespace detail\n\n#define JNGEN_DECLARE_PRINTER(constraint, priority)\\\
    \ntemplate<typename T>\\\nauto printValue(\\\n    std::ostream& out, const T&\
    \ t, const OutputModifier& mod, PTag<priority>)\\\n    -> enable_if_t<constraint,\
    \ void>\n\n#define JNGEN_DECLARE_SIMPLE_PRINTER(type, priority)\\\ninline void\
    \ printValue(std::ostream& out, const type& t,\\\n    const OutputModifier& mod,\
    \ PTag<priority>)\n\n#define JNGEN_PRINT(value)\\\nprintValue(out, value, mod,\
    \ PTagMax{})\n\n#define JNGEN_PRINT_NO_MOD(value)\\\nprintValue(out, value, OutputModifier{},\
    \ PTagMax{})\n\nJNGEN_DECLARE_PRINTER(!JNGEN_HAS_OSTREAM(), 0)\n{\n    static\
    \ bool locked = false;\n\n    ensure(\n            !locked,\n            std::string{}\
    \ + \"You are trying to print a type for which \"\n            \"operator<< is\
    \ not defined: \" + typeid(T).name());\n\n    locked = true;\n    (void)mod;\n\
    \    out << t;\n    locked = false;\n}\n\nJNGEN_DECLARE_PRINTER(JNGEN_HAS_OSTREAM(),\
    \ 10)\n{\n    (void)mod;\n    out << t;\n}\n\nJNGEN_DECLARE_PRINTER(\n    JNGEN_HAS_OSTREAM()\
    \ && JNGEN_HAS_FUNCTION(Plus), 11)\n{\n    if (std::is_integral<T>::value) {\n\
    \        out << T(t + mod.addition);\n    } else {\n        out << t;\n    }\n\
    }\n\nJNGEN_DECLARE_PRINTER(detail::VectorDepth<T>::value == 1, 3)\n{\n    if (mod.printN)\
    \ {\n        out << t.size() << \"\\n\";\n    }\n    bool first = true;\n    for\
    \ (const auto& x: t) {\n        if (first) {\n            first = false;\n   \
    \     } else {\n            out << mod.sep;\n        }\n        JNGEN_PRINT(x);\n\
    \    }\n}\n\nJNGEN_DECLARE_PRINTER(detail::VectorDepth<T>::value == 1 &&\n   \
    \ std::tuple_size<typename T::value_type>::value == 2, 4)\n{\n    if (mod.printN)\
    \ {\n        out << t.size() << \"\\n\";\n    }\n\n    bool first = true;\n  \
    \  for (const auto& x: t) {\n        if (first) {\n            first = false;\n\
    \        } else {\n            out << \"\\n\";\n        }\n        JNGEN_PRINT(x);\n\
    \    }\n}\n\nJNGEN_DECLARE_PRINTER(detail::VectorDepth<T>::value == 2, 4)\n{\n\
    \    if (mod.printN) {\n        out << t.size() << (mod.printM ? \" \" : \"\"\
    );\n    }\n    if (mod.printM) {\n        if (t.empty()) {\n            out <<\
    \ 0;\n        } else {\n            auto size = t[0].size();\n            out\
    \ << size;\n            for (const auto& vec: t) {\n                ensure(size\
    \ == vec.size(), \"Size of all matrix elements must \"\n                     \
    \   \"be equal if printM is specified\");\n            }\n        }\n    }\n\n\
    \    if ((mod.printN || mod.printM) && !t.empty()) {\n        out << \"\\n\";\n\
    \    }\n\n    auto tmp = mod;\n    {\n        auto mod = tmp;\n        mod.printN\
    \ = mod.printM = false;\n        bool first = true;\n        for (const auto&\
    \ x: t) {\n            if (first) {\n                first = false;\n        \
    \    } else {\n                out << '\\n';\n            }\n            JNGEN_PRINT(x);\n\
    \        }\n    }\n}\n\nJNGEN_DECLARE_PRINTER(JNGEN_HAS_FUNCTION(Container), 2)\n\
    {\n    if (mod.printN) {\n        out << t.size() << \"\\n\";\n    }\n    bool\
    \ first = true;\n    for (const auto& x: t) {\n        if (first) {\n        \
    \    first = false;\n        } else {\n            out << \" \";\n        }\n\
    \        JNGEN_PRINT(x);\n    }\n}\n\nJNGEN_DECLARE_PRINTER(JNGEN_HAS_FUNCTION(Container)\n\
    \    && std::tuple_size<typename T::value_type>::value == 2, 3)\n{\n    if (mod.printN)\
    \ {\n        out << t.size() << \"\\n\";\n    }\n    bool first = true;\n    for\
    \ (const auto& x: t) {\n        if (first) {\n            first = false;\n   \
    \     } else {\n            out << \"\\n\";\n        }\n        JNGEN_PRINT(x);\n\
    \    }\n}\n\n// http://stackoverflow.com/a/19841470/2159939\n#define JNGEN_COMMA\
    \ ,\n\ntemplate<typename Lhs, typename Rhs>\nJNGEN_DECLARE_SIMPLE_PRINTER(std::pair<Lhs\
    \ JNGEN_COMMA Rhs>, 3)\n{\n    JNGEN_PRINT(t.first);\n    out << \" \";\n    JNGEN_PRINT(t.second);\n\
    }\n\n#undef JNGEN_COMMA\n\n// Following snippet allows writing\n//     cout <<\
    \ pair<int, int>(1, 2) << endl;\n// in user code. I have to put it into separate\
    \ namespace because\n//   1) I don't want to 'use' all operator<< from jngen\n\
    //   2) I cannot do it in global namespace because JNGEN_HAS_OSTREAM relies\n\
    // on that it is in jngen.\nnamespace namespace_for_fake_operator_ltlt {\n\ntemplate<typename\
    \ T>\nauto operator<<(std::ostream& out, const T& t)\n    -> enable_if_t<\n  \
    \          !JNGEN_HAS_OSTREAM() && !std::is_base_of<BaseReprProxy, T>::value,\n\
    \            std::ostream&\n        >\n{\n    // not jngen::printValue, because\
    \ relying on ADL here for printers declared\n    // later (see, e.g., http://stackoverflow.com/questions/42833134)\n\
    \    printValue(out, t, jngen::defaultMod, jngen::PTagMax{});\n    return out;\n\
    }\n\n} // namespace namespace_for_fake_operator_ltlt\n\n// Calling this operator\
    \ inside jngen namespace doesn't work without this line.\nusing namespace jngen::namespace_for_fake_operator_ltlt;\n\
    \n} // namespace jngen\n\nusing namespace jngen::namespace_for_fake_operator_ltlt;\n\
    \n\n#line 3099 \"tests/jngen.h\"\n#include <numeric>\n\nnamespace jngen {\n\n\
    // TODO: deprecate random_shuffle as done in testlib.h\n\ntemplate<typename Iterator>\n\
    void shuffle(Iterator begin, Iterator end) {\n    ensure(end >= begin, \"Cannot\
    \ shuffle range of negative length\");\n    size_t size = end - begin;\n    for\
    \ (size_t i = 1; i < size; ++i) {\n        std::swap(*(begin + i), *(begin + rnd.next(i\
    \ + 1)));\n    }\n}\n\ntemplate<typename Iterator>\nauto choice(Iterator begin,\
    \ Iterator end)\n        -> typename std::iterator_traits<Iterator>::value_type\n\
    {\n    return rnd.choice(begin, end);\n}\n\ntemplate<typename Container>\ntypename\
    \ Container::value_type choice(const Container& container) {\n    return rnd.choice(container);\n\
    }\n\ntemplate<typename T>\nT choice(std::initializer_list<T> ilist) {\n    return\
    \ choice(ilist.begin(), ilist.end());\n}\n\nnamespace detail {\n\ntemplate<typename\
    \ Collection2D>\ntypename Collection2D::value_type interleave(const Collection2D&\
    \ collection) {\n    std::vector<size_t> sizes;\n    for (const auto& c: collection)\
    \ {\n        sizes.push_back(c.size());\n    }\n    size_t size = std::accumulate(sizes.begin(),\
    \ sizes.end(), 0u);\n\n    typename Collection2D::value_type result;\n    while\
    \ (size > 0) {\n        size_t id = rnd.nextByDistribution(sizes);\n        result.emplace_back(collection[id][collection[id].size()\
    \ - sizes[id]]);\n        --sizes[id];\n\n        --size;\n    }\n\n    return\
    \ result;\n}\n\n} // namespace detail\n\ntemplate<typename Collection2D>\ntypename\
    \ Collection2D::value_type interleave(const Collection2D& collection) {\n    return\
    \ detail::interleave(collection);\n}\n\ntemplate<typename Collection>\nCollection\
    \ interleave(const std::initializer_list<Collection>& ilist) {\n    return detail::interleave<std::vector<Collection>>(ilist);\n\
    }\n\n} // namespace jngen\n\nusing jngen::shuffle;\nusing jngen::choice;\nusing\
    \ jngen::interleave;\n\n\n#line 3179 \"tests/jngen.h\"\n#include <unordered_map>\n\
    #line 3182 \"tests/jngen.h\"\n\nnamespace jngen {\n\ntemplate<typename T>\nclass\
    \ GenericArray : public ReprProxy<GenericArray<T>>, public std::vector<T> {\n\
    public:\n    typedef std::vector<T> Base;\n\n    using Base::Base;\n\n    GenericArray()\
    \ {}\n    GenericArray(const GenericArray<T>&) = default;\n    GenericArray& operator=(const\
    \ GenericArray<T>&) = default;\n    GenericArray(GenericArray<T>&&) = default;\n\
    \    GenericArray& operator=(GenericArray<T>&&) = default;\n\n    ~GenericArray()\
    \ {}\n\n    /* implicit */ GenericArray(const Base& base) :\n            Base(base)\n\
    \    {  }\n\n    using Base::at;\n    using Base::size;\n    using Base::resize;\n\
    \    using Base::begin;\n    using Base::end;\n    using Base::insert;\n    using\
    \ Base::clear;\n    using Base::erase;\n\n    void extend(size_t requiredSize)\
    \ {\n        checkLargeParameter(requiredSize);\n        if (requiredSize > size())\
    \ {\n            resize(requiredSize);\n        }\n    }\n\n    template<typename\
    \ F, typename ...Args>\n    static GenericArray<T> randomf(size_t size, F func,\
    \ const Args& ... args);\n    template<typename F, typename ...Args>\n    static\
    \ GenericArray<T> randomfUnique(\n            size_t size, F func, const Args&\
    \ ... args);\n    template<typename F, typename ...Args>\n    static GenericArray<T>\
    \ randomfAll(F func, const Args& ... args);\n\n    template<typename ...Args>\n\
    \    static GenericArray<T> random(size_t size, const Args& ... args);\n    template<typename\
    \ ...Args>\n    static GenericArray<T> randomUnique(size_t size, const Args& ...\
    \ args);\n    template<typename ...Args>\n    static GenericArray<T> randomAll(const\
    \ Args& ... args);\n\n    static GenericArray<T> id(size_t size, T start = T{});\n\
    \n    GenericArray<T>& shuffle();\n    GenericArray<T> shuffled() const;\n\n \
    \   GenericArray<T>& reverse();\n    GenericArray<T> reversed() const;\n\n   \
    \ GenericArray<T>& sort();\n    GenericArray<T> sorted() const;\n\n    template<typename\
    \ Comp>\n    GenericArray<T>& sort(Comp&& comp);\n    template<typename Comp>\n\
    \    GenericArray<T> sorted(Comp&& comp) const;\n\n    GenericArray<T>& unique();\n\
    \    GenericArray<T> uniqued() const;\n\n    GenericArray<T> inverse() const;\n\
    \n    template<typename Integer>\n    GenericArray<T> subseq(const std::vector<Integer>&\
    \ indices) const;\n\n    template<typename Integer>\n    GenericArray<T> subseq(\n\
    \        const std::initializer_list<Integer>& indices) const;\n\n    T choice()\
    \ const;\n    GenericArray<T> choice(size_t count) const;\n    GenericArray<T>\
    \ choiceWithRepetition(size_t count) const;\n\n    GenericArray<T>& operator+=(const\
    \ GenericArray<T>& other);\n    GenericArray<T> operator+(const GenericArray<T>&\
    \ other) const;\n\n    GenericArray<T>& operator*=(int k);\n    GenericArray<T>\
    \ operator*(int k) const;\n\n    operator std::string() const;\n};\n\ntemplate<typename\
    \ T>\ntemplate<typename ...Args>\nGenericArray<T> GenericArray<T>::random(size_t\
    \ size, const Args& ... args) {\n    checkLargeParameter(size);\n    GenericArray<T>\
    \ result(size);\n    for (T& x: result) {\n        x = rnd.tnext<T>(args...);\n\
    \    }\n    return result;\n}\n\ntemplate<typename T>\ntemplate<typename F, typename\
    \ ...Args>\nGenericArray<T> GenericArray<T>::randomf(\n        size_t size,\n\
    \        F func,\n        const Args& ... args)\n{\n    checkLargeParameter(size);\n\
    \    GenericArray<T> result(size);\n    for (T& x: result) {\n        x = func(args...);\n\
    \    }\n    return result;\n}\n\nnamespace detail {\n\ntemplate<typename T, typename\
    \ Enable = std::size_t>\nstruct DictContainer {\n    typedef std::set<T> type;\n\
    };\n\ntemplate<typename T>\nstruct DictContainer<T, typename std::hash<T>::result_type>\n\
    {\n    typedef std::unordered_set<T> type;\n};\n\n} // namespace detail\n\ntemplate<typename\
    \ T>\ntemplate<typename F, typename ...Args>\nGenericArray<T> GenericArray<T>::randomfUnique(\n\
    \        size_t size,\n        F func,\n        const Args& ... args)\n{\n   \
    \ typename detail::DictContainer<T>::type set;\n    checkLargeParameter(size);\n\
    \    GenericArray<T> result;\n    result.reserve(size);\n\n    size_t retries\
    \ = (size + 10) * log(size + 10) * 2;\n\n    while (result.size() != size) {\n\
    \        T t = func(args...);\n        if (!set.count(t)) {\n            set.insert(t);\n\
    \            result.push_back(t);\n        }\n\n        if (--retries == 0) {\n\
    \            ensure(false, \"There are not enough unique elements\");\n      \
    \  }\n\n    }\n\n    return result;\n}\n\ntemplate<typename T>\ntemplate<typename\
    \ ...Args>\nGenericArray<T> GenericArray<T>::randomUnique(\n        size_t size,\
    \ const Args& ... args)\n{\n    return GenericArray<T>::randomfUnique(\n     \
    \   size,\n        [](Args... args) { return rnd.tnext<T>(args...); },\n     \
    \   args...);\n}\n\ntemplate<typename T>\ntemplate<typename F, typename ...Args>\n\
    GenericArray<T> GenericArray<T>::randomfAll(\n        F func,\n        const Args&\
    \ ... args)\n{\n    typename detail::DictContainer<T>::type set;\n    GenericArray<T>\
    \ result;\n\n    size_t timeAfterLastHit = 0;\n\n    while (true) {\n        T\
    \ t = func(args...);\n        if (!set.count(t)) {\n            set.insert(t);\n\
    \            result.push_back(t);\n            timeAfterLastHit = 0;\n       \
    \ }\n\n        ++timeAfterLastHit;\n\n        // Probability of finding not all\
    \ elements is about e^{-20} ~= 1e-9\n        if (timeAfterLastHit > (result.size()\
    \ + 10) * 20) {\n            return result;\n        }\n    }\n}\n\ntemplate<typename\
    \ T>\ntemplate<typename ...Args>\nGenericArray<T> GenericArray<T>::randomAll(const\
    \ Args& ... args)\n{\n    return GenericArray<T>::randomfAll(\n        [](Args...\
    \ args) { return rnd.tnext<T>(args...); },\n        args...);\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T> GenericArray<T>::id(size_t size, T start) {\n    constexpr\
    \ bool enable = std::is_integral<T>::value;\n    static_assert(enable, \"Cannot\
    \ call Array<T>::id with non-integral T\");\n    checkLargeParameter(size);\n\n\
    \    if (enable) {\n        GenericArray<T> result(size);\n        std::iota(result.begin(),\
    \ result.end(), start);\n        return result;\n    } else {\n        return\
    \ {};\n    }\n}\n\ntemplate<typename T>\nGenericArray<T>& GenericArray<T>::shuffle()\
    \ {\n    jngen::shuffle(begin(), end());\n    return *this;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T> GenericArray<T>::shuffled() const {\n    auto res = *this;\n\
    \    res.shuffle();\n    return res;\n}\n\ntemplate<typename T>\nGenericArray<T>&\
    \ GenericArray<T>::reverse() {\n    std::reverse(begin(), end());\n    return\
    \ *this;\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::reversed()\
    \ const {\n    auto res = *this;\n    res.reverse();\n    return res;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T>& GenericArray<T>::sort() {\n    std::sort(begin(), end());\n\
    \    return *this;\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::sorted()\
    \ const {\n    auto res = *this;\n    res.sort();\n    return res;\n}\n\ntemplate<typename\
    \ T>\ntemplate<typename Comp>\nGenericArray<T>& GenericArray<T>::sort(Comp&& comp)\
    \ {\n    std::sort(begin(), end(), comp);\n    return *this;\n}\n\ntemplate<typename\
    \ T>\ntemplate<typename Comp>\nGenericArray<T> GenericArray<T>::sorted(Comp&&\
    \ comp) const {\n    auto res = *this;\n    res.sort(comp);\n    return res;\n\
    }\n\ntemplate<typename T>\nGenericArray<T>& GenericArray<T>::unique() {\n    erase(std::unique(begin(),\
    \ end()), end());\n    return *this;\n}\n\ntemplate<typename T>\nGenericArray<T>\
    \ GenericArray<T>::uniqued() const {\n    auto res = *this;\n    res.unique();\n\
    \    return res;\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::inverse()\
    \ const {\n    static_assert(\n        std::is_integral<T>::value,\n        \"\
    Can only take inverse permutation of integral array\");\n    int n = size();\n\
    \n    if (n == 0) {\n        return *this;\n    }\n\n    // sanity check\n   \
    \ ensure(*max_element(begin(), end()) == n-1 &&\n        *min_element(begin(),\
    \ end()) == 0,\n        \"Trying to take inverse of the array which is not a permutation\"\
    );\n\n    const static T NONE = static_cast<T>(-1);\n    GenericArray<T> result(n,\
    \ NONE);\n    for (int i = 0; i < n; ++i) {\n        ensure(result[at(i)] == NONE,\n\
    \            \"Trying to take inverse of the array which is not a permutation\"\
    );\n        result[at(i)] = i;\n    }\n\n    return result;\n}\n\ntemplate<typename\
    \ T>\ntemplate<typename Integer>\nGenericArray<T> GenericArray<T>::subseq(\n \
    \       const std::vector<Integer>& indices) const\n{\n    GenericArray<T> result;\n\
    \    result.reserve(indices.size());\n    for (Integer idx: indices) {\n     \
    \   result.push_back(at(idx));\n    }\n    return result;\n}\n\n// TODO(ifsmirnov):\
    \ ever need to make it faster?\ntemplate<typename T>\ntemplate<typename Integer>\n\
    GenericArray<T> GenericArray<T>::subseq(\n        const std::initializer_list<Integer>&\
    \ indices) const\n{\n    return subseq(std::vector<T>(indices));\n}\n\ntemplate<typename\
    \ T>\nT GenericArray<T>::choice() const {\n    return jngen::choice(begin(), end());\n\
    }\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::choice(size_t count)\
    \ const {\n    ensure(\n        count <= size(),\n        \"Use Array::choiceWithRepetition\
    \ to select more than size() elements\");\n\n    size_t n = size();\n\n    std::unordered_map<size_t,\
    \ size_t> used;\n    std::vector<size_t> res;\n    for (size_t i = 0; i < count;\
    \ ++i) {\n        size_t oldValue = used.count(n-i-1) ? used[n-i-1] : n-i-1;\n\
    \        size_t index = rnd.tnext<size_t>(n-i);\n        res.push_back(used.count(index)\
    \ ? used[index] : index);\n        used[index] = oldValue;\n    }\n\n    return\
    \ subseq(res);\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::choiceWithRepetition(size_t\
    \ count) const {\n    checkLargeParameter(count);\n    GenericArray<T> res(count);\n\
    \    for (T& t: res) {\n        t = choice();\n    }\n    return res;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T>& GenericArray<T>::operator+=(const GenericArray<T>& other)\
    \ {\n    if (&other == this) {\n        return *this *= 2;\n    }\n    insert(end(),\
    \ other.begin(), other.end());\n    return *this;\n}\n\ntemplate<typename T>\n\
    GenericArray<T> GenericArray<T>::operator+(const GenericArray<T>& other) const\
    \ {\n    GenericArray<T> copy(*this);\n    return copy += other;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T>& GenericArray<T>::operator*=(int k) {\n    if (k == 0) {\n\
    \        clear();\n        return *this;\n    }\n\n    this->reserve(size() *\
    \ k);\n\n    std::copy_n(begin(), size() * (k - 1), std::back_inserter(*this));\n\
    \n    return *this;\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::operator*(int\
    \ k) const {\n    GenericArray<T> copy(*this);\n    return copy *= k;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T>::operator std::string() const {\n    static_assert(std::is_same<T,\
    \ char>::value, \"Must not cast\"\n        \" TArray<T> to std::string with 'T'\
    \ != 'char'\");\n    return std::string(begin(), end());\n}\n\n// JNGEN_EXTERN\
    \ template class GenericArray<int>;\n\ntemplate<typename T>\nusing TArray = GenericArray<T>;\n\
    \nusing Array = GenericArray<int>;\nusing Array2d = GenericArray<jngen::GenericArray<int>>;\n\
    using Array64 = GenericArray<long long>;\nusing Arrayf = GenericArray<double>;\n\
    using Arrayp = GenericArray<std::pair<int, int>>;\n\ntemplate<typename T>\njngen::GenericArray<T>\
    \ makeArray(const std::vector<T>& values) {\n    return jngen::GenericArray<T>(values);\n\
    }\n\ntemplate<typename T>\njngen::GenericArray<T> makeArray(const std::initializer_list<T>&\
    \ values) {\n    return jngen::GenericArray<T>(values);\n}\n\ntemplate<typename\
    \ T, typename U>\nTArray<std::pair<T, U>> zip(const TArray<T>& lhs, const TArray<U>&\
    \ rhs) {\n    ensure(\n        lhs.size() == rhs.size(),\n        \"In zip(a,\
    \ b), a and b must have the same size\");\n    TArray<std::pair<T, U>> result;\n\
    \    for (size_t i = 0; i < lhs.size(); ++i) {\n        result.emplace_back(lhs[i],\
    \ rhs[i]);\n    }\n    return result;\n}\n\ntemplate<typename T, typename U>\n\
    TArray<T> arrayCast(const TArray<U>& array) {\n    return TArray<T>(array.begin(),\
    \ array.end());\n}\n\ntemplate<typename T>\nstruct Hash<TArray<T>> {\n    uint64_t\
    \ operator()(const TArray<T>& elements) const {\n        return Hash<std::vector<T>>{}(elements);\n\
    \    }\n};\n\n} // namespace jngen\n\nJNGEN_DEFINE_STD_HASH_TEMPLATE(T, jngen::TArray<T>);\n\
    \nusing jngen::makeArray;\nusing jngen::zip;\nusing jngen::arrayCast;\n\nusing\
    \ jngen::TArray;\n\nusing jngen::Array;\nusing jngen::Array2d;\nusing jngen::Array64;\n\
    using jngen::Arrayf;\nusing jngen::Arrayp;\n\n// This header is named 'math_jngen.h'\
    \ and not 'math.h' because in the latter\n// case it will replace the standard\
    \ 'math.h' if you set jngen folder as the\n// include path.\n\n\n#line 3676 \"\
    tests/jngen.h\"\n\nnamespace jngen {\n\nnamespace detail {\n\ninline int multiply(int\
    \ x, int y, int mod) {\n    return static_cast<long long>(x) * y % mod;\n}\n\n\
    inline long long multiply(long long x, long long y, long long mod) {\n#if defined(__SIZEOF_INT128__)\n\
    \    return static_cast<__int128>(x) * y % mod;\n#else\n    long long res = 0;\n\
    \    while (y) {\n        if (y&1) {\n            res = (static_cast<unsigned\
    \ long long>(res) + x) % mod;\n        }\n        x = (static_cast<unsigned long\
    \ long>(x) + x) % mod;\n        y >>= 1;\n    }\n    return res;\n#endif\n}\n\n\
    inline int power(int x, int k, int mod) {\n    int res = 1;\n    while (k) {\n\
    \        if (k&1) {\n            res = multiply(res, x, mod);\n        }\n   \
    \     x = multiply(x, x, mod);\n        k >>= 1;\n    }\n    return res;\n}\n\n\
    inline long long power(long long x, long long k, long long mod) {\n    long long\
    \ res = 1;\n    while (k) {\n        if (k&1) {\n            res = multiply(res,\
    \ x, mod);\n        }\n        x = multiply(x, x, mod);\n        k >>= 1;\n  \
    \  }\n    return res;\n}\n\ntemplate<typename I>\nbool millerRabinTest(I n, const\
    \ std::vector<I>& witnesses) {\n    static_assert(\n        std::is_same<I, int>::value\
    \ || std::is_same<I, long long>::value,\n        \"millerRabinTest<int/long long>\
    \ only is supported\");\n\n    if (n == 1) {\n        return false;\n    }\n\n\
    \    constexpr int LIMIT = 10000;\n\n    if (n <= LIMIT) {\n        for (int i\
    \ = 2; i*i <= n; ++i) {\n            if (n%i == 0) {\n                return false;\n\
    \            }\n        }\n        return true;\n    }\n\n    int r = 0;\n   \
    \ I d = n - 1;\n    while (d % 2 == 0) {\n        ++r;\n        d /= 2;\n    }\n\
    \n    for (I a: witnesses) {\n        I x = power(a, d, n);\n        if (x ==\
    \ 1 || x == n - 1) {\n            continue;\n        }\n\n        bool composite\
    \ = true;\n        for (int i = 0; i < r - 1; ++i) {\n            x = multiply(x,\
    \ x, n);\n            if (x == 1) {\n                return false;\n         \
    \   }\n            if (x == n - 1) {\n                i = r;\n               \
    \ composite = false;\n                continue;\n            }\n        }\n  \
    \      if (composite) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n\n} // namespace detail\n\ninline bool isPrime(long long n) {\n  \
    \  const static std::vector<int> INT_WITNESSES{2, 7, 61};\n    const static std::vector<long\
    \ long> LONG_LONG_WITNESSES\n        {2, 3, 5, 7, 11, 13, 17, 19, 23};\n    //\
    \ todo: experiment with base\n    // 2, 325, 9375, 28178, 450775, 9780504, and\
    \ 1795265022\n    // (guaranteed for all integers < 2^64)\n\n    // first strong\
    \ pseudoprime to i64 bases is 3825123056546413051 ~= 3.8e18\n    ensure(n > 0,\
    \ \"isPrime() is undefined for negative numbers\");\n    ensure(\n        n <=\
    \ static_cast<long long>(3.8e18),\n        \"isPrime() supports only numbers not\
    \ greater than 3.8 * 10^18\");\n\n    if (n < std::numeric_limits<int>::max())\
    \ {\n        return detail::millerRabinTest<int>(n, INT_WITNESSES);\n    } else\
    \ {\n        return detail::millerRabinTest<long long>(n, LONG_LONG_WITNESSES);\n\
    \    }\n}\n\nclass MathRandom {\npublic:\n    MathRandom() {\n        static bool\
    \ created = false;\n        ensure(!created, \"jngen::MathRandom should be created\
    \ only once\");\n        created = true;\n    }\n\n    static long long randomPrime(long\
    \ long n) {\n        ensure(n > 2, format(\"There are no primes below %lld\",\
    \ n));\n        return randomPrime(2, n - 1);\n    }\n\n    static long long randomPrime(long\
    \ long l, long long r) {\n        ensure(l <= r);\n        std::unordered_set<long\
    \ long> used;\n        while (static_cast<long long>(used.size()) < r - l + 1)\
    \ {\n            long long x = rnd.next(l, r);\n            if (used.count(x))\
    \ {\n                continue;\n            }\n            used.insert(x);\n \
    \           if (isPrime(x)) {\n                return x;\n            }\n    \
    \    }\n        ensure(\n            false,\n            format(\n           \
    \     \"There are no primes between %lld and %lld\",\n                l, r)\n\
    \        );\n    }\n\n    static long long nextPrime(long long n) {\n        while\
    \ (!isPrime(n)) {\n            ++n;\n        }\n        return n;\n    }\n\n \
    \   static long long previousPrime(long long n) {\n        ensure(n >= 2, format(\"\
    There are no primes less or equal to %lld\", n));\n        while (!isPrime(n))\
    \ {\n            --n;\n        }\n        return n;\n    }\n\n    static Array\
    \ partition(\n            int n,\n            int numParts,\n            int minSize\
    \ = 0,\n            int maxSize = -1)\n    {\n        auto res = partition(\n\
    \            static_cast<long long>(n),\n            numParts,\n            static_cast<long\
    \ long>(minSize),\n            static_cast<long long>(maxSize));\n        return\
    \ Array(res.begin(), res.end());\n    }\n\n    static Array64 partition(\n   \
    \         long long n,\n            int numParts,\n            long long minSize\
    \ = 0,\n            long long maxSize = -1)\n    {\n        if (maxSize == -1)\
    \ {\n            maxSize = n;\n        }\n\n        ensure(n >= 0);\n        ensure(numParts\
    \ >= 0);\n        ensure(numParts * minSize <= n, \"minSize is too large\");\n\
    \        ensure(numParts * maxSize >= n, \"maxSize is too small\");\n        ensure(minSize\
    \ <= maxSize);\n\n        n -= minSize * numParts;\n\n        auto delimiters\
    \ = Array64::random(\n                numParts - 1, 0, n).sorted();\n        delimiters.insert(delimiters.begin(),\
    \ 0);\n        delimiters.push_back(n);\n\n        Array64 partition(numParts);\n\
    \        for (long long i = 0; i < numParts; ++i) {\n            partition[i]\
    \ = delimiters[i + 1] - delimiters[i];\n        }\n        partition.sort().reverse();\n\
    \n        long long remaining = 0;\n\n        long long localMax = maxSize - minSize;\n\
    \        for (auto& x: partition) {\n            if (x > localMax) {\n       \
    \         remaining += x - localMax;\n                x = localMax;\n        \
    \    }\n\n            x += minSize;\n        }\n\n        // Here we try to distribute\
    \ the remaining part in some even manner\n        // between remaining slots.\
    \ Looks like crap anyway, need a smarter way.\n\n        for (int divisor: { 2,\
    \ 1 }) {\n            partition.shuffle();\n            for (auto& x: partition)\
    \ {\n                if (x < maxSize) {\n                    long long add = std::min(\n\
    \                            remaining, (maxSize - x) / divisor);\n          \
    \          x += add;\n                    remaining -= add;\n                }\n\
    \            }\n        }\n\n        ensure(remaining == 0, \"maxSize is too small\"\
    );\n\n        return partition;\n    }\n\n    template<typename T>\n    TArray<TArray<T>>\
    \ partition(\n            TArray<T> elements,\n            int numParts,\n   \
    \         int minSize = 0,\n            int maxSize = -1)\n    {\n        return\
    \ partition(\n            std::move(elements),\n            partition(\n     \
    \           static_cast<int>(elements.size()),\n                numParts,\n  \
    \              minSize,\n                maxSize));\n    }\n\n    template<typename\
    \ T>\n    TArray<TArray<T>> partition(TArray<T> elements, const Array& sizes)\
    \ {\n        size_t total = std::accumulate(sizes.begin(), sizes.end(), size_t(0));\n\
    \        ensure(total == elements.size(), \"sum(sizes) != elements.size()\");\n\
    \        elements.shuffle();\n        TArray<TArray<T>> res;\n        auto it\
    \ = elements.begin();\n        for (int size: sizes) {\n            res.emplace_back();\n\
    \            std::copy(it, it + size, std::back_inserter(res.back()));\n     \
    \       it += size;\n        }\n\n        return res;\n    }\n};\n\nJNGEN_EXTERN\
    \ MathRandom rndm;\n\n} // namespace jngen\n\nusing jngen::isPrime;\n\nusing jngen::rndm;\n\
    \n\n#line 3969 \"tests/jngen.h\"\n\nnamespace jngen {\n\nenum class UnorderedSetCompiler\
    \ {\n    Gcc4,\n    Gcc5or6,\n    Clang\n};\n\nclass ArrayRandom {\npublic:\n\
    \    ArrayRandom() {\n        static bool created = false;\n        ENSURE(!created,\
    \ \"jngen::ArrayRandom should be created only once\");\n        created = true;\n\
    \    }\n\n    template<typename F, typename ...Args>\n    static auto randomf(\n\
    \            size_t size,\n            F func,\n            Args... args) -> GenericArray<decltype(func(args...))>\n\
    \    {\n        typedef decltype(func(args...)) T;\n        return GenericArray<T>::randomf(size,\
    \ func, args...);\n    }\n\n    template<typename F, typename ...Args>\n    static\
    \ auto randomfUnique(\n            size_t size,\n            F func,\n       \
    \     Args... args) -> GenericArray<decltype(func(args...))>\n    {\n        typedef\
    \ decltype(func(args...)) T;\n        return GenericArray<T>::randomfUnique(size,\
    \ func, args...);\n    }\n\n    template<typename F, typename ...Args>\n    static\
    \ auto randomfAll(\n            F func,\n            Args... args) -> GenericArray<decltype(func(args...))>\n\
    \    {\n        typedef decltype(func(args...)) T;\n        return GenericArray<T>::randomfAll(func,\
    \ args...);\n    }\n\n    static Array64 antiUnorderedSet(\n        int n,\n \
    \       double maxLoadFactor = 1.0,\n        bool reserve = false,\n        UnorderedSetCompiler\
    \ compiler = UnorderedSetCompiler::Gcc4);\n\nprivate:\n    static Array64 numbersDividingPrime(int\
    \ n, long long p);\n\n    static long long nextPrime(\n        unsigned long long\
    \ x,\n        UnorderedSetCompiler compiler);\n};\n\nJNGEN_EXTERN ArrayRandom\
    \ rnda;\n\n#ifndef JNGEN_DECLARE_ONLY\n\nArray64 ArrayRandom::antiUnorderedSet(\n\
    \    int n,\n    double maxLoadFactor,\n    bool reserve,\n    UnorderedSetCompiler\
    \ compiler)\n{\n    ensure(\n        compiler == UnorderedSetCompiler::Gcc4,\n\
    \        \"unordered set antitest supported only for gcc-4.x yet\");\n\n    ensure(\n\
    \        n <= 1000000,\n        \"unordered set antitest supported only for n\
    \ <= 1e7\");\n\n    int buckets;\n\n    if (reserve) {\n        buckets = nextPrime(std::ceil(n\
    \ / maxLoadFactor), compiler);\n    } else {\n        buckets = 2;\n        for\
    \ (int size = 1; size <= n; ++size) {\n            if (size + 1 > buckets * maxLoadFactor)\
    \ {\n                buckets = nextPrime(buckets * 2, compiler);\n           \
    \ }\n        }\n    }\n\n    return numbersDividingPrime(n, buckets);\n}\n\nArray64\
    \ ArrayRandom::numbersDividingPrime(int n, long long p) {\n    auto a = Array64::id(n);\n\
    \    for (auto& x: a) {\n        x *= p;\n    }\n    return a;\n}\n\nlong long\
    \ ArrayRandom::nextPrime(\n    unsigned long long x,\n    UnorderedSetCompiler\
    \ compiler)\n{\n    ENSURE(compiler == UnorderedSetCompiler::Gcc4);\n\n    const\
    \ static size_t SIZE =\n        sizeof(impl::primeList) / sizeof(impl::primeList[0]);\n\
    \    return *std::lower_bound(impl::primeList, impl::primeList + SIZE, x);\n}\n\
    \n#endif // JNGEN_DECLARE_ONLY\n\n} // namespace jngen\n\nusing jngen::rnda;\n\
    using jngen::UnorderedSetCompiler;\n\n\n#line 4097 \"tests/jngen.h\"\n\nnamespace\
    \ jngen {\n\n#ifdef JNGEN_DECLARE_ONLY\nextern long double eps;\n#else\nlong double\
    \ eps = 1e-9;\n#endif\n\ninline void setEps(long double value) {\n    eps = value;\n\
    }\n\ntemplate<typename T, typename U, typename Enable = void>\nstruct Comparator\
    \ {\n    static bool eq(T a, U b) { return a == b; }\n    static bool lt(T a,\
    \ U b) { return a < b; }\n};\n\ntemplate<typename T, typename U>\nstruct Comparator<T,\
    \ U, enable_if_t<\n        std::is_floating_point<T>::value || std::is_floating_point<U>::value,\n\
    \        void>>\n{\n    static bool eq(T a, U b) { return std::abs(b - a) < eps;\
    \ }\n    static bool lt(T a, U b) { return a < b - eps; }\n};\n\ntemplate<typename\
    \ T, typename U>\nbool eq(T t, U u) {\n    return Comparator<T, U>().eq(t, u);\n\
    }\n\ntemplate<typename T, typename U>\nbool lt(T t, U u) {\n    return Comparator<T,\
    \ U>().lt(t, u);\n}\n\ntemplate<typename T, typename U> bool ne(T t, U u) { return\
    \ !eq(t, u); }\ntemplate<typename T, typename U> bool le(T t, U u) { return !lt(u,\
    \ t); }\ntemplate<typename T, typename U> bool gt(T t, U u) { return  lt(u, t);\
    \ }\ntemplate<typename T, typename U> bool ge(T t, U u) { return !lt(t, u); }\n\
    \ntemplate<typename T>\nstruct TPoint : public ReprProxy<TPoint<T>> {\n    T x,\
    \ y;\n\n    TPoint() : x(0), y(0) {}\n    TPoint(T x, T y) : x(x), y(y) {}\n\n\
    \    template<typename U>\n    TPoint(const TPoint<U>& other) : x(other.x), y(other.y)\
    \ {}\n\n    TPoint<T> operator+(const TPoint<T>& other) const {\n        return\
    \ TPoint<T>(x + other.x, y + other.y);\n    }\n\n    TPoint<T>& operator+=(const\
    \ TPoint<T>& other) {\n        x += other.x;\n        y += other.y;\n        return\
    \ *this;\n    }\n\n    TPoint<T> operator-(const TPoint<T>& other) const {\n \
    \       return TPoint<T>(x - other.x, y - other.y);\n    }\n\n    TPoint<T>& operator-=(const\
    \ TPoint<T>& other) {\n        x -= other.x;\n        y -= other.y;\n        return\
    \ *this;\n    }\n\n    TPoint<T> operator-() const {\n        return TPoint<T>(-x,\
    \ -y);\n    }\n\n    TPoint<T> operator*(T factor) const {\n        return TPoint<T>(x\
    \ * factor, y * factor);\n    }\n\n    TPoint<T>& operator*=(T factor) {\n   \
    \     x *= factor;\n        y *= factor;\n        return *this;\n    }\n\n   \
    \ T operator*(const TPoint<T>& other) const {\n        return x * other.x + y\
    \ * other.y;\n    }\n\n    T operator%(const TPoint<T>& other) const {\n     \
    \   return x * other.y - y * other.x;\n    }\n\n    bool operator==(const TPoint<T>&\
    \ other) const {\n        return eq(x, other.x) && eq(y, other.y);\n    }\n\n\
    \    bool operator!=(const TPoint<T>& other) const {\n        return !(*this ==\
    \ other);\n    }\n\n    bool operator<(const TPoint<T>& other) const {\n     \
    \   if (eq(x, other.x)) {\n            return lt(y, other.y);\n        }\n   \
    \     return lt(x, other.x);\n    }\n};\n\nusing Point = TPoint<long long>;\n\
    using Pointf = TPoint<long double>;\n\ntemplate<>\nstruct Hash<Point> {\n    uint64_t\
    \ operator()(const Point& point) const {\n        uint64_t h = 0;\n        impl::hashCombine(h,\
    \ Hash<long long>{}(point.x));\n        impl::hashCombine(h, Hash<long long>{}(point.y));\n\
    \        return h;\n    }\n};\n\ntemplate<typename T>\nJNGEN_DECLARE_SIMPLE_PRINTER(TPoint<T>,\
    \ 3) {\n    (void)mod;\n    out << t.x << \" \" << t.y;\n}\n\ntemplate<typename\
    \ T>\nclass TPolygon : public GenericArray<TPoint<T>> {\npublic:\n    using Base\
    \ = GenericArray<TPoint<T>>;\n    using Base::Base;\n\n    TPolygon<T>& shift(const\
    \ TPoint<T>& vector) {\n        for (auto &pt: *this) {\n            pt += vector;\n\
    \        }\n        return *this;\n    }\n\n    TPolygon<T> shifted(const TPoint<T>&\
    \ vector) const {\n        auto res = *this;\n        res.shift(vector);\n   \
    \     return res;\n    }\n\n    TPolygon<T>& reflect() {\n        for (auto& pt:\
    \ *this) {\n            pt = -pt;\n        }\n        return *this;\n    }\n\n\
    \    TPolygon<T> reflected() const {\n        auto res = *this;\n        res.reflect();\n\
    \        return res;\n    }\n};\n\nusing Polygon = TPolygon<long long>;\nusing\
    \ Polygonf = TPolygon<long double>;\n\ntemplate<>\nstruct Hash<Polygon> {\n  \
    \  uint64_t operator()(const Polygon& p) const {\n        return Hash<TArray<Point>>{}(p);\n\
    \    }\n};\n\ntemplate<typename T>\nJNGEN_DECLARE_SIMPLE_PRINTER(TArray<TPoint<T>>,\
    \ 5) {\n    // I should avoid copy-paste from array printer here but need to output\n\
    \    // points with '\\n' separator. Maybe 'mod' should be made non-const?\n \
    \   if (mod.printN) {\n        out << t.size() << \"\\n\";\n    }\n    bool first\
    \ = true;\n    for (const auto& x: t) {\n        if (first) {\n            first\
    \ = false;\n        } else {\n            out << '\\n';\n        }\n        JNGEN_PRINT(x);\n\
    \    }\n}\n\nnamespace detail {\n\ntemplate<typename T>\nTPolygon<T> convexHull(TArray<TPoint<T>>\
    \ points) {\n    points.sort().unique();\n\n    if (points.size() <= 2u) {\n \
    \       return points;\n    }\n\n    TArray<TPoint<T>> upper(points.begin(), points.begin()\
    \ + 2);\n    upper.reserve(points.size());\n    int top = 1;\n    for (size_t\
    \ i = 2; i < points.size(); ++i) {\n        while (top >= 1 && ge(\n         \
    \       (upper[top] - upper[top-1]) % (points[i] - upper[top]), 0ll))\n      \
    \  {\n            upper.pop_back();\n            --top;\n        }\n        upper.push_back(points[i]);\n\
    \        ++top;\n    }\n\n    TArray<TPoint<T>> lower(points.begin(), points.begin()\
    \ + 2);\n    lower.reserve(points.size());\n    top = 1;\n    for (size_t i =\
    \ 2; i < points.size(); ++i) {\n        while (top >= 1 && le(\n             \
    \   (lower[top] - lower[top-1]) % (points[i] - lower[top]), 0ll))\n        {\n\
    \            lower.pop_back();\n            --top;\n        }\n        lower.push_back(points[i]);\n\
    \        ++top;\n    }\n    upper.pop_back();\n    upper.erase(upper.begin());\n\
    \    return lower + upper.reversed();\n}\n\ntemplate<typename T>\nTPolygon<T>\
    \ convexPolygonByEllipse(\n        int n, Pointf center, Pointf xAxis, Pointf\
    \ yAxis)\n{\n    return convexHull(rnda.randomf(\n        n,\n        [center,\
    \ xAxis, yAxis] () -> TPoint<T> {\n            static const long double PI = acosl(-1.0);\n\
    \            long double angle = rnd.next(0., PI*2);\n            long double\
    \ sina = sinl(angle);\n            long double cosa = cosl(angle);\n         \
    \   return center + xAxis * cosa + yAxis * sina;\n        }\n    ));\n}\n\n} //\
    \ namespace detail\n\nclass GeometryRandom {\npublic:\n    GeometryRandom() {\n\
    \        static bool created = false;\n        ensure(!created, \"jngen::GeometryRandom\
    \ should be created only once\");\n        created = true;\n    }\n\n    // point\
    \ in [0, C] x [0, C]\n    static Point point(long long C);\n\n    // point in\
    \ [min, max] x [min, max]\n    static Point point(long long min, long long max);\n\
    \n    // point in [X1, Y1] x [X2, Y2]\n    static Point point(\n            long\
    \ long X1, long long Y1,\n            long long X2, long long Y2);\n\n    // point\
    \ in [0, C] x [0, C]\n    static Point pointf(long double C);\n\n    // point\
    \ in [min, max] x [min, max]\n    static Point pointf(long double min, long double\
    \ max);\n\n    // point in [X1, Y1] x [X2, Y2]\n    static Point pointf(\n   \
    \         long double X1, long double Y1,\n            long double X2, long double\
    \ Y2);\n\n\n    static Polygon convexPolygon(int n, long long C);\n    static\
    \ Polygon convexPolygon(int n, long long min, long long max);\n    static Polygon\
    \ convexPolygon(\n            int n,\n            long long X1, long long Y1,\n\
    \            long long X2, long long Y2);\n\n\n    static TArray<Point> pointsInGeneralPosition(int\
    \ n, long long C);\n\n    static TArray<Point> pointsInGeneralPosition(\n    \
    \        int n, long long min, long long max);\n    static TArray<Point> pointsInGeneralPosition(\n\
    \            int n,\n            long long X1, long long Y1,\n            long\
    \ long X2, long long Y2);\n\n};\n\n\nJNGEN_EXTERN GeometryRandom rndg;\n\nJNGEN_EXTERN\
    \ template struct jngen::TPoint<long long>;\nJNGEN_EXTERN template struct jngen::TPoint<long\
    \ double>;\nJNGEN_EXTERN template class jngen::TPolygon<long long>;\nJNGEN_EXTERN\
    \ template class jngen::TPolygon<long double>;\n\nJNGEN_EXTERN template TPolygon<long\
    \ long> detail::convexHull<long long>(\n        TArray<TPoint<long long>> points);\n\
    JNGEN_EXTERN template TPolygon<long double> detail::convexHull<long double>(\n\
    \        TArray<TPoint<long double>> points);\n\n} // namespace jngen\n\nJNGEN_DEFINE_STD_HASH(jngen::Point);\n\
    JNGEN_DEFINE_STD_HASH(jngen::Polygon);\n\nusing jngen::Point;\nusing jngen::Pointf;\n\
    \nusing jngen::Polygon;\nusing jngen::Polygonf;\n\nusing jngen::rndg;\n\nusing\
    \ jngen::setEps;\n\n// workaround for g++-7\nnamespace std {\n\nJNGEN_EXTERN template\
    \ class std::allocator<Point>;\nJNGEN_EXTERN template class std::allocator<Pointf>;\n\
    \n} // namespace std\n\n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_GEOMETRY_INL_H\n\
    #ifndef JNGEN_INCLUDE_GEOMETRY_INL_H\n#error File \"geometry_inl.h\" must not\
    \ be included directly.\n#endif\n\nnamespace jngen {\n\nPoint GeometryRandom::point(long\
    \ long C) {\n    return point(0, 0, C, C);\n}\n\nPoint GeometryRandom::point(long\
    \ long min, long long max) {\n    return point(min, min, max, max);\n}\n\nPoint\
    \ GeometryRandom::point(\n        long long X1, long long Y1,\n        long long\
    \ X2, long long Y2) {\n    long long x = rnd.tnext<long long>(X1, X2);\n    long\
    \ long y = rnd.tnext<long long>(Y1, Y2);\n    return Point(x, y);\n}\n\nPoint\
    \ GeometryRandom::pointf(long double C) {\n    return pointf(0, 0, C, C);\n}\n\
    \nPoint GeometryRandom::pointf(long double min, long double max) {\n    return\
    \ pointf(min, min, max, max);\n}\n\nPoint GeometryRandom::pointf(\n        long\
    \ double X1, long double Y1,\n        long double X2, long double Y2)\n{\n   \
    \ long double x = rnd.tnext<long double>(X1, X2);\n    long double y = rnd.tnext<long\
    \ double>(Y1, Y2);\n    return Pointf(x, y);\n}\n\n\nPolygon GeometryRandom::convexPolygon(int\
    \ n, long long C) {\n    return convexPolygon(n, 0, 0, C, C);\n}\n\nPolygon GeometryRandom::convexPolygon(int\
    \ n, long long min, long long max) {\n    return convexPolygon(n, min, min, max,\
    \ max);\n}\n\nPolygon GeometryRandom::convexPolygon(\n            int n,\n   \
    \         long long X1, long long Y1,\n            long long X2, long long Y2)\n\
    {\n    // todo: off-by-one error?\n    auto dx = X2 - X1;\n    auto dy = Y2 -\
    \ Y1;\n    ensure(n >= 0);\n    Polygon res = detail::convexPolygonByEllipse<long\
    \ long>(\n        n * 10, // BUBEN!\n        Point(dx / 2, dy / 2),\n        Point(dx\
    \ / 2, 0),\n        Point(0, dy / 2)\n    );\n    res.shift(Point(X1, Y1));\n\
    \    for (auto& x: res) {\n        ENSURE(x.x >= X1);\n        ENSURE(x.x <= X2);\n\
    \        ENSURE(x.y >= Y1);\n        ENSURE(x.y <= Y2);\n    }\n\n    ensure(\n\
    \        static_cast<int>(res.size()) >= n,\n        \"Cannot generate a convex\
    \ polygon with so many vertices\");\n\n    return res.subseq(Array::id(res.size()).choice(n).sort());\n\
    }\n\n\nTArray<Point> GeometryRandom::pointsInGeneralPosition(int n, long long\
    \ C) {\n    return pointsInGeneralPosition(n, 0, 0, C, C);\n}\n\nTArray<Point>\
    \ GeometryRandom::pointsInGeneralPosition(\n        int n, long long min, long\
    \ long max)\n{\n    return pointsInGeneralPosition(n, min, min, max, max);\n}\n\
    \nTArray<Point> GeometryRandom::pointsInGeneralPosition(\n        int n,\n   \
    \     long long X1, long long Y1,\n        long long X2, long long Y2)\n{\n  \
    \  struct Line {\n        long long A, B, C; // Ax + By + C = 0\n        Line()\
    \ {}\n        Line(const Point& p1, const Point& p2) {\n            A = p1.y -\
    \ p2.y;\n            B = p2.x - p1.x;\n            C = -(p1.x * A + p1.y * B);\n\
    \n            ENSURE(A != 0 || B != 0);\n\n            long long g = util::gcd(A,\
    \ util::gcd(B, C));\n            A /= g;\n            B /= g;\n            C /=\
    \ g;\n            if (A < 0 || (A == 0 && B < 0)) {\n                A = -A;\n\
    \                B = -B;\n                C = -C;\n            }\n        }\n\n\
    \        bool operator<(const Line& other) const {\n            return std::tie(A,\
    \ B, C) < std::tie(other.A, other.B, other.C);\n        }\n    };\n\n    const\
    \ long long LIMIT = 2e9;\n    ensure(\n        std::abs(X2 - X1) <= LIMIT && X1\
    \ <= LIMIT && X2 <= LIMIT &&\n            std::abs(Y2 - Y1) <= LIMIT && Y1 <=\
    \ LIMIT && Y2 <= LIMIT,\n        \"rndg.pointsInGeneralPosition must not be called\
    \ with coordinates \"\n        \"larger than 2e9\");\n\n    std::set<Line> lines;\n\
    \    std::unordered_set<Point> points;\n\n    TArray<Point> res;\n\n    while\
    \ (static_cast<int>(res.size()) != n) {\n        Point p = point(X1, Y1, X2, Y2);\n\
    \n        if (points.count(p)) {\n            continue;\n        }\n\n       \
    \ if (std::none_of(\n                res.begin(),\n                res.end(),\n\
    \                [&lines, &p] (const Point& q) {\n                    return lines.count(Line(p,\
    \ q));\n                }))\n        {\n            points.insert(p);\n      \
    \      for (const auto& q: res) {\n                lines.emplace(p, q);\n    \
    \        }\n            res.push_back(p);\n        }\n    }\n    return res;\n\
    }\n\n} // namespace jngen\n#undef JNGEN_INCLUDE_GEOMETRY_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\
    \n\n#line 4599 \"tests/jngen.h\"\n\nnamespace jngen {\n\nclass QueryBuilder {\n\
    public:\n    QueryBuilder() {}\n\n    QueryBuilder(int n);\n    QueryBuilder(int\
    \ l, int r);\n\n    QueryBuilder& minLen(int value);\n    QueryBuilder& maxLen(int\
    \ value);\n    QueryBuilder& range(int n);\n    QueryBuilder& range(int l, int\
    \ r);\n    QueryBuilder& small();\n    QueryBuilder& large();\n    QueryBuilder&\
    \ ordered(bool value);\n\n    std::pair<int, int> next();\n    Arrayp next(int\
    \ m);\n\nprivate:\n    enum class QueryType {\n        Default, Large, Small\n\
    \    };\n\n    QueryType queryType_ = QueryType::Default;\n\n    std::pair<int,\
    \ int> range_; // half-interval\n    std::pair<int, int> lenRange_; // segment\n\
    \    bool ordered_;\n};\n\n#ifndef JNGEN_DECLARE_ONLY\n\nQueryBuilder::QueryBuilder(int\
    \ n) :\n    QueryBuilder(0, n - 1)\n{  }\n\nQueryBuilder::QueryBuilder(int l,\
    \ int r) :\n    range_(l, r + 1),\n    lenRange_(1, r - l + 1),\n    ordered_(true)\n\
    {\n    ensure(l <= r);\n}\n\nQueryBuilder& QueryBuilder::minLen(int value) {\n\
    \    lenRange_.first = value;\n    return *this;\n}\n\nQueryBuilder& QueryBuilder::maxLen(int\
    \ value) {\n    lenRange_.second = value;\n    return *this;\n}\n\nQueryBuilder&\
    \ QueryBuilder::range(int n) {\n    ensure(n > 0);\n    return this->range(0,\
    \ n - 1);\n}\n\nQueryBuilder& QueryBuilder::range(int l, int r) {\n    ensure(l\
    \ <= r);\n    range_ = {l, r+1};\n    lenRange_.second = std::min(lenRange_.second,\
    \ r - l + 1);\n    lenRange_.first = std::min(lenRange_.first, lenRange_.second);\n\
    \    return *this;\n}\n\nQueryBuilder& QueryBuilder::small() {\n    queryType_\
    \ = QueryType::Small;\n    return *this;\n}\n\nQueryBuilder& QueryBuilder::large()\
    \ {\n    queryType_ = QueryType::Large;\n    return *this;\n}\n\nQueryBuilder&\
    \ QueryBuilder::ordered(bool value) {\n    ordered_ = value;\n    return *this;\n\
    }\n\nstd::pair<int, int> QueryBuilder::next() {\n    switch (queryType_) {\n \
    \   case QueryType::Default: {\n        // This is inaccurate to say the least.\
    \ I don't know how to\n        // generate a random segment with length from l\
    \ to r without\n        // calling sqrt.\n        int len = rnd.wnext(lenRange_.first,\
    \ lenRange_.second, -1);\n        int l = rnd.next(range_.first, range_.second\
    \ - len);\n        if (ordered_ || rnd.next(2)) {\n            return {l, l +\
    \ len - 1};\n        } else {\n            return {l + len - 1, l};\n        }\n\
    \    }\n    case QueryType::Large: {\n        ENSURE(false, \"not implemented\"\
    );\n        break;\n    }\n    case QueryType::Small: {\n        ENSURE(false,\
    \ \"not implemented\");\n        break;\n    }\n    default: ENSURE(false, \"\
    Nonexistent option\");\n    }\n}\n\nArrayp QueryBuilder::next(int m) {\n    return\
    \ rnda.randomf(m, [this]() { return next(); });\n}\n\n#endif\n\ntemplate<typename\
    \ ... Args>\nQueryBuilder rndq(Args... args) {\n    return QueryBuilder(args...);\n\
    }\n\n} // namespace jngen\n\nusing jngen::rndq;\n\n\n#line 4733 \"tests/jngen.h\"\
    \n\nnamespace jngen {\n\ntypedef std::pair<long long, long long> HashBase; //\
    \ (mod, base)\ntypedef std::pair<std::string, std::string> StringPair;\n\nclass\
    \ StringRandom {\npublic:\n    StringRandom() {\n        static bool created =\
    \ false;\n        ENSURE(!created, \"jngen::StringRandom should be created only\
    \ once\");\n        created = true;\n    }\n\n    static std::string random(int\
    \ len, const std::string& alphabet = \"a-z\");\n\n    template<typename ... Args>\n\
    \    static std::string random(const std::string& pattern, Args... args) {\n \
    \       return rnd.next(pattern, std::forward(args)...);\n    }\n\n    static\
    \ std::string thueMorse(int len, char first = 'a', char second = 'b');\n\n   \
    \ static std::string abacaba(int len, char first = 'a');\n\n    static StringPair\
    \ antiHash(\n            const std::vector<HashBase>& bases,\n            const\
    \ std::string& alphabet = \"a-z\",\n            int length = -1);\n};\n\nJNGEN_EXTERN\
    \ StringRandom rnds;\n\n} // namespace jngen\n\nusing jngen::rnds;\n\n#ifndef\
    \ JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_RNDS_INL_H\n#ifndef JNGEN_INCLUDE_RNDS_INL_H\n\
    #error File \"rnds_inl.h\" must not be included directly.\n#endif\n\nnamespace\
    \ jngen {\n\nnamespace detail {\n\nint popcount(long long x) {\n    int res =\
    \ 0;\n    while (x) {\n        ++res;\n        x &= x-1;\n    }\n    return res;\n\
    }\n\nint trailingZeroes(long long x) {\n    int res = 0;\n    ENSURE(x != 0);\n\
    \    while (!(x&1)) {\n        ++res;\n        x >>= 1;\n    }\n    return res;\n\
    }\n\nstd::string parseAllowedChars(std::string pattern) {\n    std::string result;\n\
    \    pattern += \"\\0\\0\";\n    for (size_t i = 0; i < pattern.length(); ++i)\
    \ {\n        if (pattern[i] == '-') {\n            result += '-';\n        } else\
    \ if (pattern[i+1] == '-' && pattern[i+2] != '\\0') {\n            for (char c\
    \ = pattern[i]; c <= pattern[i+2]; ++c) {\n                result += c;\n    \
    \        }\n            i += 2;\n        } else {\n            result += pattern[i];\n\
    \        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n\
    }\n\nstd::vector<std::string> extendAntiHash(\n        const std::vector<std::string>&\
    \ chars,\n        HashBase base,\n        int count)\n{\n    ENSURE(count == 2,\
    \ \"Count != 2 is not supported (yet)\");\n\n    size_t baseLength = chars[0].size();\n\
    \    for (const auto& s: chars) {\n        ensure(s.size() == baseLength);\n \
    \   }\n\n    long long mod = base.first;\n    long long p = base.second;\n\n \
    \   long long pPower = 1;\n    for (size_t i = 0; i != baseLength; ++i) {\n  \
    \      pPower = (pPower * p) % mod;\n    }\n\n    std::vector<long long> charHashes;\n\
    \    for (const auto& s: chars) {\n        long long hash = 0;\n        for (char\
    \ c: s) {\n            hash = (hash * p + c) % mod;\n        }\n        charHashes.push_back(hash);\n\
    \    }\n\n    auto computeHash = [&charHashes, mod, pPower](const std::vector<int>&\
    \ a) {\n        long long hash = 0;\n        for (int x: a) {\n            hash\
    \ = (hash * pPower + charHashes[x]) % mod;\n        }\n        return hash;\n\
    \    };\n\n    // This bounds were achieved empirically and should be justified.\n\
    \    int needForMatch;\n    if (count == 2) {\n        needForMatch = 5 * pow(double(mod),\
    \ 0.5);\n    } else {\n        ENSURE(false, \"Only count = 2 is supported yet\"\
    );\n    }\n\n    int length = 2;\n    double wordCount = pow(double(chars.size()),\
    \ double(length));\n\n    while (true) {\n        ++length;\n        wordCount\
    \ *= chars.size();\n        if (wordCount < needForMatch) {\n            continue;\n\
    \        }\n\n        std::vector<std::pair<long long, Array>> words;\n      \
    \  std::map<long long, int> hashCount;\n        std::set<Array> used;\n\n    \
    \    for (int i = 0; i < needForMatch; ++i) {\n            Array w = Array::random(length,\
    \ chars.size());\n            if (used.count(w)) {\n                --i;\n   \
    \             continue;\n            }\n            used.insert(w);\n        \
    \    long long hash = computeHash(w);\n            words.emplace_back(hash, w);\n\
    \            if (++hashCount[hash] == count) {\n                std::vector<std::string>\
    \ result;\n                for (const auto& kv: words) {\n                   \
    \ if (kv.first == hash) {\n                        std::string word;\n       \
    \                 for (int c: kv.second) {\n                            word +=\
    \ chars[c];\n                        }\n                        result.push_back(word);\n\
    \                    }\n                }\n                return result;\n  \
    \          }\n        }\n    }\n}\n\nStringPair minimalAntiHashTest(\n       \
    \ std::vector<HashBase> bases,\n        const std::string allowedChars)\n{\n \
    \   for (auto base: bases) {\n        ensure(base.first >= 0, \"0 < MOD must hold\"\
    );\n        ensure(\n            base.first <= (long long)(2e9),\n           \
    \ \"Modules larger than 2'000'000'000 are not supported yet\");\n        ensure(\n\
    \            0 < base.second && base.second < base.first,\n            \"0 <=\
    \ P < MOD must hold\");\n    }\n\n    std::vector<int> counts;\n    if (bases.size()\
    \ == 1) {\n        counts = {2};\n    } else if (bases.size() == 2) {\n      \
    \  counts = {2, 2};\n    } else {\n        counts.assign(bases.size(), 2);\n \
    \   }\n\n    std::vector<std::string> cur;\n    for (char c: allowedChars) {\n\
    \        cur.emplace_back(1, c);\n    }\n\n    for (size_t i = 0; i != bases.size();\
    \ ++i) {\n        cur = extendAntiHash(cur, bases[i], counts[i]);\n        ensure(static_cast<int>(cur.size())\
    \ == counts[i],\n            \"Cannot generate long enough pair with same hash\"\
    );\n    }\n\n    return {cur[0], cur[1]};\n}\n\n} // namespace detail\n\n\nstd::string\
    \ StringRandom::random(int len, const std::string& alphabet) {\n    checkLargeParameter(len);\n\
    \    std::string chars = detail::parseAllowedChars(alphabet);\n    std::string\
    \ res;\n    res.reserve(len);\n    for (int i = 0; i < len; ++i) {\n        res\
    \ += choice(chars);\n    }\n    return res;\n}\n\nstd::string StringRandom::thueMorse(int\
    \ len, char first, char second) {\n    ensure(len >= 0);\n    checkLargeParameter(len);\n\
    \    std::string res(len, ' ');\n    for (int i = 0; i < len; ++i) {\n       \
    \ res[i] = detail::popcount(i)%2 == 0 ? first : second;\n    }\n    return res;\n\
    }\n\nstd::string StringRandom::abacaba(int len, char first) {\n    ensure(len\
    \ >= 0);\n    checkLargeParameter(len);\n    std::string res(len, ' ');\n    for\
    \ (int i = 0; i < len; ++i) {\n        res[i] = first + detail::trailingZeroes(~i);\n\
    \    }\n    return res;\n}\n\nStringPair StringRandom::antiHash(\n        const\
    \ std::vector<HashBase>& bases,\n        const std::string& alphabet,\n      \
    \  int length)\n{\n    checkLargeParameter(length);\n    std::string allowedChars\
    \ = detail::parseAllowedChars(alphabet);\n    StringPair result = detail::minimalAntiHashTest(bases,\
    \ allowedChars);\n\n    if (length == -1) {\n        return result;\n    }\n\n\
    \    ensure(\n        static_cast<int>(result.first.length()) <= length,\n   \
    \     \"Cannot generate enough long anti-hash test\");\n\n    int extraLength\
    \ = length - result.first.length();\n    int leftSize = rnd.next(0, extraLength);\n\
    \n    std::string left = rnd.next(format(\"[%s]{%d}\", alphabet.c_str(), leftSize));\n\
    \    std::string right =\n        rnd.next(format(\"[%s]{%d}\", alphabet.c_str(),\
    \ extraLength - leftSize));\n\n    return {\n        left + result.first + right,\n\
    \        left + result.second + right\n    };\n}\n\n} // namespace jngen\n#undef\
    \ JNGEN_INCLUDE_RNDS_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#line 5016 \"tests/jngen.h\"\
    \n\nnamespace jngen {\nnamespace suites {\n\n#define JNGEN_ADD_PRODUCER(...)\\\
    \n    {\\\n        std::string name = #__VA_ARGS__;\\\n        if (name.empty())\
    \ {\\\n            name = format(\"noname%d\", (int)names_.size());\\\n      \
    \  }\\\n        if (std::find(names_.begin(), names_.end(), name) != names_.end())\
    \ {\\\n            ENSURE(false, format(\"Duplicated test name: '%s'\", name.c_str()));\\\
    \n        }\\\n        names_.emplace_back(name);\\\n    }\\\n    *std::back_inserter(producers_)\
    \ = [this] (JNGEN_PRODUCER_ARGS) -> value_type\n\ntemplate<typename T, typename\
    \ Traits, typename ... Args>\nclass BaseTestSuite {\npublic:\n    explicit BaseTestSuite(const\
    \ std::string& name) : name_(name) {  }\n\n    BaseTestSuite(const BaseTestSuite&)\
    \ = delete;\n    BaseTestSuite& operator=(const BaseTestSuite&) = delete;\n\n\
    \    size_t size() const {\n        return producers_.size();\n    }\n\n    TArray<std::string>\
    \ names() const {\n        return names_;\n    }\n\n    T gen(size_t id, Args...\
    \ args) const {\n        ensure(\n            id < producers_.size(),\n      \
    \      format(\"Cannot generate test #%d in suite '%s', there are only \"\n  \
    \              \"%d\", (int)id, name_.c_str(), (int)producers_.size()));\n   \
    \     return producers_[id](args...);\n    }\n\n    T gen(const std::string& name,\
    \ Args... args) const {\n        size_t pos = std::find(names_.begin(), names_.end(),\
    \ name)\n            - names_.begin();\n        ensure(\n            pos < names_.size(),\n\
    \            format(\"There is no test '%s' in suite '%s'\",\n               \
    \ name.c_str(), name_.c_str()));\n        return gen(pos, args...);\n    }\n\n\
    \    TArray<T> genMany(size_t count, Args... args) const {\n        ensure(\n\
    \            count <= producers_.size(),\n            format(\"Cannot generate\
    \ %d tests in suite '%s', there are only \"\n                \"%d\", (int)count,\
    \ name_.c_str(), (int)producers_.size()));\n\n        TArray<T> result;\n    \
    \    result.reserve(count);\n        for (size_t id = 0; id < count; ++id) {\n\
    \            try {\n                result.push_back(gen(id, args...));\n    \
    \        } catch (...) {\n                std::cerr << \"Cannot generate test\
    \ #\" << id << \" of suite \"\n                    << name_ << \"\\n\";\n    \
    \        }\n        }\n\n        return result;\n    }\n\n    Traits& conf() {\
    \ return conf_; }\n\nprotected:\n    using Producer = std::function<T(Args...)>;\n\
    \    using value_type = T;\n\n    std::vector<Producer> producers_;\n    std::vector<std::string>\
    \ names_;\n\n    Traits conf_;\n\nprivate:\n    std::string name_;\n};\n\n}} //\
    \ namespace jngen::suites\n\n\n#line 5106 \"tests/jngen.h\"\n#include <cstdio>\n\
    #line 5108 \"tests/jngen.h\"\n\nnamespace jngen {\n\ninline int getInitialTestNo()\
    \ {\n    char *envvar = std::getenv(\"TESTNO\");\n    int testno;\n    if (!envvar\
    \ || 1 != std::sscanf(envvar, \"%d\", &testno)) {\n        return 1;\n    }\n\
    \    return testno;\n}\n\n#ifdef JNGEN_DECLARE_ONLY\nextern int nextTestNo;\n\
    #else\nint nextTestNo = -1;\n#endif // JNGEN_DECLARE_ONLY\n\nvoid startTest(int\
    \ testNo);\n\nvoid startTest();\n\nvoid setNextTestNumber(int testNo);\n\nArray64\
    \ randomTestSizes(\n    long long totalSize,\n    int count,\n    long long minSize,\n\
    \    long long maxSize,\n    const Array64& predefined);\n\nArray randomTestSizes(\n\
    \    int totalSize,\n    int count,\n    int minSize,\n    int maxSize,\n    const\
    \ Array& predefined);\n\n#ifndef JNGEN_DECLARE_ONLY\n\nvoid startTest(int testNo)\
    \ {\n    nextTestNo = testNo + 1;\n    char filename[10];\n    std::sprintf(filename,\
    \ \"%d\", testNo);\n    if (!std::freopen(filename, \"w\", stdout)) {\n      \
    \  ensure(false, format(\"Cannot open the file `%s'\", filename));\n    }\n}\n\
    \nvoid startTest() {\n    if (nextTestNo == -1) {\n        nextTestNo = getInitialTestNo();\n\
    \    }\n\n    startTest(nextTestNo);\n}\n\nvoid setNextTestNumber(int testNo)\
    \ {\n    nextTestNo = testNo;\n}\n\nArray64 randomTestSizes(\n    long long totalSize,\n\
    \    int count,\n    long long minSize,\n    long long maxSize,\n    const Array64&\
    \ predefined)\n{\n    for (auto x: predefined) {\n        totalSize -= x;\n  \
    \  }\n    ensure(totalSize >= 0, \"Sum of predefined test sizes exceeds total\
    \ size\");\n    ensure(count * minSize <= totalSize, \"minSize is too large\"\
    );\n    ensure(count * maxSize >= totalSize, \"maxSize is too small\");\n    ensure(minSize\
    \ <= maxSize);\n\n    return (rndm.partition(totalSize, count, minSize, maxSize)\
    \ +\n            predefined).shuffle();\n}\n\nArray randomTestSizes(\n    int\
    \ totalSize,\n    int count,\n    int minSize,\n    int maxSize,\n    const Array&\
    \ predefined)\n{\n    return arrayCast<int>(randomTestSizes(\n        static_cast<long\
    \ long>(totalSize),\n        count,\n        static_cast<long long>(minSize),\n\
    \        static_cast<long long>(maxSize),\n        arrayCast<long long>(predefined)\n\
    \    ));\n}\n\n#endif // JNGEN_DECLARE_ONLY\n\n} // namespace jngen\n\nusing jngen::startTest;\n\
    using jngen::setNextTestNumber;\n\nusing jngen::randomTestSizes;\n\n\n#line 5217\
    \ \"tests/jngen.h\"\n\nnamespace jngen {\n\nnamespace variant_detail {\n\nconstexpr\
    \ static int NO_TYPE = -1;\n\ntemplate<size_t Size, size_t Align, typename ...\
    \ Args>\nclass VariantImpl;\n\ntemplate<size_t Size, size_t Align>\nclass VariantImpl<Size,\
    \ Align> {\npublic:\n    VariantImpl() {\n        type_ = NO_TYPE;\n    }\n\n\
    private:\n    alignas(Align) char data_[Size];\n    int type_;\n\nprotected:\n\
    \    int& type() { return type_; }\n    int type() const { return type_; }\n\n\
    \    char* data() { return data_; }\n    const char* data() const { return data_;\
    \ }\n\n    void doDestroy() {\n        throw;\n    }\n\n    template<typename\
    \ P>\n    constexpr static int typeId() {\n        return NO_TYPE;\n    }\n\n\
    \    void copy(char*) const {\n        throw;\n    }\n\n    void move(char*) const\
    \ {\n        throw;\n    }\n\n    void setType(int) {\n        throw;\n    }\n\
    \n    template<typename V>\n    typename V::return_type applyVisitor(V&&) const\
    \ {\n        throw;\n    }\n\n    void assign() {}\n};\n\ntemplate<size_t Size,\
    \ size_t Align, typename T, typename ... Args>\nclass VariantImpl<Size, Align,\
    \ T, Args...> : public VariantImpl<\n        (sizeof(T) > Size ? sizeof(T) : Size),\n\
    \        (alignof(T) > Align ? alignof(T) : Align),\n        Args...\n    >\n\
    {\n    using Base = VariantImpl<\n        (sizeof(T) > Size ? sizeof(T) : Size),\n\
    \        (alignof(T) > Align ? alignof(T) : Align),\n        Args...\n    >;\n\
    \n    constexpr static int MY_ID = sizeof...(Args);\n\nprotected:\n    void doDestroy()\
    \ {\n        if (this->type() == MY_ID) {\n            this->type() = NO_TYPE;\n\
    \            reinterpret_cast<T*>(this->data())->~T();\n        } else {\n   \
    \         Base::doDestroy();\n        }\n    }\n\n    template<typename P>\n \
    \   constexpr static int typeId() {\n        return std::is_same<P, T>::value\
    \ ?\n            MY_ID :\n            Base::template typeId<P>();\n    }\n\n \
    \   void copy(char* dst) const {\n        if (this->type() == MY_ID) {\n     \
    \       new(dst) T(*reinterpret_cast<const T*>(this->data()));\n        } else\
    \ {\n            Base::copy(dst);\n        }\n    }\n\n    void move(char* dst)\
    \ const {\n        if (this->type() == MY_ID) {\n            new(dst) T(std::move(*reinterpret_cast<const\
    \ T*>(this->data())));\n        } else {\n            Base::copy(dst);\n     \
    \   }\n    }\n\n    void setType(int typeIndex) {\n        if (typeIndex == MY_ID)\
    \ {\n            if (this->type() != NO_TYPE) {\n                throw;\n    \
    \        }\n            assign(T{});\n        } else {\n            Base::setType(typeIndex);\n\
    \        }\n    }\n\n    template<typename V>\n    typename V::return_type applyVisitor(V&&\
    \ v) const {\n        if (this->type() == MY_ID) {\n            return v(*reinterpret_cast<const\
    \ T*>(this->data()));\n        } else {\n            return Base::applyVisitor(std::forward<V>(v));\n\
    \        }\n    }\n\n    using Base::assign;\n\n    void assign(const T& t) {\n\
    \        if (this->type() == NO_TYPE) {\n            new(this->data()) T;\n  \
    \          this->type() = MY_ID;\n        }\n\n        ref() = t;\n    }\n\nprivate:\n\
    \    T& ref() { return *reinterpret_cast<T*>(this->data()); }\n\npublic:\n   \
    \ operator T() const {\n        if (this->type() == MY_ID) {\n            return\
    \ *reinterpret_cast<const T*>(this->data());\n        } else {\n            return\
    \ T();\n        }\n    }\n};\n\ntemplate<typename ... Args>\nclass Variant : public\
    \ VariantImpl<0, 1, Args...> {\n    using Base = VariantImpl<0, 1, Args...>;\n\
    \npublic:\n    Variant() { }\n\n    Variant(const Variant<Args...>& other) {\n\
    \        if (other.type() != NO_TYPE) {\n            other.copy(this->data());\n\
    \            unsafeType() = other.type();\n        }\n    }\n\n    Variant& operator=(const\
    \ Variant<Args...>& other) {\n        if (&other == this) {\n            return\
    \ *this;\n        }\n        if (this->type() != NO_TYPE) {\n            this->doDestroy();\n\
    \        }\n        if (other.type() != NO_TYPE) {\n            other.copy(this->data());\n\
    \            unsafeType() = other.type();\n        }\n        return *this;\n\
    \    }\n\n    Variant(Variant<Args...>&& other) {\n        if (other.type() !=\
    \ NO_TYPE) {\n            other.move(this->data());\n            unsafeType()\
    \ = other.type();\n        } else {\n            unsafeType() = other.type();\n\
    \        }\n    }\n\n    Variant& operator=(Variant<Args...>&& other) {\n    \
    \    if (&other == this) {\n            return *this;\n        }\n        if (this->type()\
    \ != NO_TYPE) {\n            this->doDestroy();\n        }\n        if (other.type()\
    \ != NO_TYPE) {\n            other.move(this->data());\n            unsafeType()\
    \ = other.type();\n        }\n        return *this;\n    }\n\n    ~Variant() {\n\
    \        if (type() != NO_TYPE) {\n            this->doDestroy();\n        }\n\
    \    }\n\n    template<typename T>\n    Variant(const T& t) : Variant() {\n  \
    \      this->assign(t);\n    }\n\n    template<typename T>\n    T& ref() {\n \
    \       return *ptr<T>();\n    }\n\n    template<typename T>\n    const T& cref()\
    \ const {\n        auto ptr = cptr<T>();\n        if (ptr == 0) {\n          \
    \  throw std::logic_error(\"jngen::Variant: taking a reference for\"\n       \
    \         \" a type which is not active now\");\n        }\n        return *ptr;\n\
    \    }\n\n    bool operator==(const Variant& v) const { return compareTo(v) ==\
    \ 0; }\n    bool operator!=(const Variant& v) const { return compareTo(v) != 0;\
    \ }\n    bool operator< (const Variant& v) const { return compareTo(v) <  0; }\n\
    \    bool operator> (const Variant& v) const { return compareTo(v) >  0; }\n \
    \   bool operator<=(const Variant& v) const { return compareTo(v) <= 0; }\n  \
    \  bool operator>=(const Variant& v) const { return compareTo(v) >= 0; }\n\n \
    \   template<typename V>\n    typename V::return_type applyVisitor(V&& v) const\
    \ {\n        return Base::applyVisitor(std::forward<V>(v));\n    }\n\n    int\
    \ type() const { return Base::type(); }\n\n    void setType(int typeIndex) {\n\
    \        if (typeIndex == NO_TYPE) {\n            throw std::logic_error(\"jngen::Variant::setType():\"\
    \n                \" calling with NO_TYPE is invalid\");\n        }\n        if\
    \ (this->type() == typeIndex) {\n            return;\n        }\n        if (this->type()\
    \ != NO_TYPE) {\n            this->doDestroy();\n        }\n        Base::setType(typeIndex);\n\
    \    }\n\n    bool empty() const { return Base::type() == NO_TYPE; }\n\n    template<typename\
    \ T>\n    constexpr static bool hasType() {\n        return Base::template typeId<T>()\
    \ != NO_TYPE;\n    }\n\nprivate:\n    template<typename T_>\n    decay_t<T_>*\
    \ ptr() {\n        using T = decay_t<T_>;\n        if (type() != this->template\
    \ typeId<T>()) {\n            if (type() != NO_TYPE) {\n                this->doDestroy();\n\
    \            }\n            ::new(this->data()) T;\n            unsafeType() =\
    \ this->template typeId<T>();\n        }\n        return reinterpret_cast<T*>(this->data());\n\
    \    }\n\n    template<typename T_>\n    const decay_t<T_>* cptr() const {\n \
    \       using T = decay_t<T_>;\n        if (type() != this->template typeId<T>())\
    \ {\n            return nullptr;\n        }\n        return reinterpret_cast<const\
    \ T*>(this->data());\n    }\n\n    int& unsafeType() {\n        return Base::type();\n\
    \    }\n\n    int compareTo(const Variant& other) const;\n};\n\nstruct OstreamVisitor\
    \ {\n    using return_type = void;\n\n    template<typename T>\n    void operator()(const\
    \ T& t) {\n        JNGEN_PRINT(t);\n    }\n    std::ostream& out;\n    const OutputModifier&\
    \ mod;\n};\n\ntemplate<typename V>\nstruct CompareToVisitor {\n    using return_type\
    \ = int;\n\n    template<typename T>\n    int operator()(const T& t) {\n     \
    \   if (t == variant.template cref<T>()) {\n            return 0;\n        }\n\
    \        return t < variant.template cref<T>() ? -1 : 1;\n    }\n\n    const V&\
    \ variant;\n};\n\ntemplate<typename ... Args>\nint Variant<Args...>::compareTo(const\
    \ Variant& other) const {\n    if (empty()) {\n        return other.empty() ?\
    \ 0 : -1;\n    }\n    if (other.empty()) {\n        return 1;\n    }\n\n    if\
    \ (type() != other.type()) {\n        return type() > other.type() ? -1 : 1;\n\
    \    }\n    return applyVisitor(CompareToVisitor<Variant>{other});\n\n}\n\n} //\
    \ namespace variant_detail\n\nusing variant_detail::Variant;\n\ntemplate<typename\
    \ ... Args>\nJNGEN_DECLARE_SIMPLE_PRINTER(Variant<Args...>, 5) {\n    if (t.type()\
    \ == jngen::variant_detail::NO_TYPE) {\n        out << \"{empty variant}\";\n\
    \    } else {\n        t.applyVisitor(jngen::variant_detail::OstreamVisitor{out,\
    \ mod});\n    }\n}\n\n} // namespace jngen\n\n\n#line 5569 \"tests/jngen.h\"\n\
    \nnamespace jngen {\n\ntemplate<typename ... Args>\nclass VariantArray : public\
    \ GenericArray<Variant<Args...>> {\npublic:\n    using Base = GenericArray<Variant<Args...>>;\n\
    \    using BaseVariant = Variant<Args...>;\n\n    using Base::Base;\n\n    VariantArray()\
    \ {}\n\n    /* implicit */ VariantArray(const Base& base) :\n            Base(base)\n\
    \    {  }\n\n    template<typename T, typename = typename std::enable_if<\n  \
    \      BaseVariant::template hasType<T>()>::type>\n    VariantArray(const std::vector<T>&\
    \ other) {\n        std::copy(other.begin(), other.end(), std::back_inserter(*this));\n\
    \    }\n\n    template<typename T, typename = typename std::enable_if<\n     \
    \   BaseVariant::template hasType<T>()>::type>\n    VariantArray(std::vector<T>&&\
    \ other) {\n        std::move(other.begin(), other.end(), std::back_inserter(*this));\n\
    \        GenericArray<T>().swap(other);\n    }\n\n    template<typename T, typename\
    \ = typename std::enable_if<\n        BaseVariant::template hasType<T>()>::type>\n\
    \    operator GenericArray<T>() const\n    {\n        return GenericArray<T>(this->begin(),\
    \ this->end());\n    }\n\n    bool hasNonEmpty() const {\n        for (const auto&\
    \ x: *this) {\n            if (!x.empty()) {\n                return true;\n \
    \           }\n        }\n        return false;\n    }\n\n    int anyType() const\
    \ {\n        for (const auto& x: *this) {\n            if (!x.empty()) {\n   \
    \             return x.type();\n            }\n        }\n        return 0;\n\
    \    }\n\n};\n\n} // namespace jngen\n\n#line 5630 \"tests/jngen.h\"\n\n\nnamespace\
    \ jngen {\n\n#define JNGEN_DEFAULT_WEIGHT_TYPES int, double, std::string, char,\
    \ std::pair<int, int>\n\n#if defined(JNGEN_EXTRA_WEIGHT_TYPES)\n#define JNGEN_WEIGHT_TYPES\
    \ JNGEN_DEFAULT_WEIGHT_TYPES , JNGEN_EXTRA_WEIGHT_TYPES\n#else\n#define JNGEN_WEIGHT_TYPES\
    \ JNGEN_DEFAULT_WEIGHT_TYPES\n#endif\n\nusing Weight = Variant<JNGEN_WEIGHT_TYPES>;\n\
    using WeightArray = VariantArray<JNGEN_WEIGHT_TYPES>;\n\n} // namespace jngen\n\
    \nusing jngen::Weight;\nusing jngen::WeightArray;\n\n\n#line 5657 \"tests/jngen.h\"\
    \n\nnamespace jngen {\n\nclass GenericGraph {\npublic:\n    virtual ~GenericGraph()\
    \ {}\n\n    virtual int n() const { return adjList_.size(); }\n    virtual int\
    \ m() const { return numEdges_; }\n\n    bool directed() const { return directed_;\
    \ }\n\n    // u, v: labels\n    virtual void addEdge(int u, int v, const Weight&\
    \ w = Weight{});\n    virtual bool isConnected() const { return dsu_.isConnected();\
    \ }\n\n    virtual int vertexLabel(int v) const { return vertexLabel_.at(v); }\n\
    \    virtual int vertexByLabel(int v) const { return vertexByLabel_.at(v); }\n\
    \n    // v: label\n    // return: array<label>\n    virtual Array edges(int v)\
    \ const;\n\n    // return: array<label, label>\n    virtual Arrayp edges() const;\n\
    \n    // order: by labels\n    // TODO: think about ordering here\n    virtual\
    \ void setVertexWeights(const WeightArray& weights);\n    // v: label\n    virtual\
    \ void setVertexWeight(int v, const Weight& weight);\n\n    virtual void setEdgeWeights(const\
    \ WeightArray& weights);\n    virtual void setEdgeWeight(size_t index, const Weight&\
    \ weight);\n\n    // v: label\n    virtual Weight vertexWeight(int v) const;\n\
    \    virtual Weight edgeWeight(size_t index) const;\n\n    // TODO: should it\
    \ really be public?\n    virtual void doPrintEdges(\n        std::ostream& out,\
    \ const OutputModifier& mod) const;\n\n    virtual bool operator==(const GenericGraph&\
    \ other) const;\n    virtual bool operator!=(const GenericGraph& other) const;\n\
    \    virtual bool operator< (const GenericGraph& other) const;\n    virtual bool\
    \ operator> (const GenericGraph& other) const;\n    virtual bool operator<=(const\
    \ GenericGraph& other) const;\n    virtual bool operator>=(const GenericGraph&\
    \ other) const;\n\n    void initWithEdges(int n, const Arrayp& edges);\n\nprotected:\n\
    \    static WeightArray prepareWeightArray(WeightArray a, int requiredSize);\n\
    \n    void doShuffle();\n    void doShuffleAllBut(const Array& except);\n    void\
    \ doShuffleEdges();\n\n    void extend(size_t size);\n\n    // v: vertex number\n\
    \    // returns: array<number>\n    Array internalEdges(int v) const;\n\n    //\
    \ u, v: vertex numbers\n    void addEdgeUnsafe(int u, int v);\n\n    // v: vertex\
    \ number\n    // returns: vertex number\n    int edgeOtherEnd(int v, int edgeId)\
    \ const;\n\n    void permuteEdges(const Array& order);\n\n    void normalizeEdges();\n\
    \n    int compareTo(const GenericGraph& other) const;\n\n    int numEdges_ = 0;\n\
    \n    bool directed_ = false;\n\n    Dsu dsu_;\n    std::vector<Array> adjList_;\n\
    \    Array vertexLabel_;\n    Array vertexByLabel_;\n    Arrayp edges_;\n\n  \
    \  WeightArray vertexWeights_;\n    WeightArray edgeWeights_;\n};\n\ntemplate<>\n\
    struct Hash<GenericGraph> {\n    uint64_t operator()(const GenericGraph& graph)\
    \ const {\n        uint64_t h = 0;\n        for (int i = 0; i < graph.n(); ++i)\
    \ {\n            impl::hashCombine(h, Hash<Array>{}(graph.edges(i)));\n      \
    \  }\n        return h;\n    }\n};\n\n} // namespace jngen\n\nJNGEN_DEFINE_STD_HASH(jngen::GenericGraph);\n\
    \n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_GENERIC_GRAPH_INL_H\n#ifndef\
    \ JNGEN_INCLUDE_GENERIC_GRAPH_INL_H\n#error File \"generic_graph_inl.h\" must\
    \ not be included directly.\n#endif\n\nnamespace jngen {\n\nvoid GenericGraph::setVertexWeights(const\
    \ WeightArray& weights) {\n    ensure(\n        static_cast<int>(weights.size())\
    \ == n(),\n        \"The argument of setVertexWeights must have exactly n elements\"\
    );\n    vertexWeights_.resize(n());\n    for (int i = 0; i < n(); ++i) {\n   \
    \     vertexWeights_[i] = weights[vertexByLabel(i)];\n    }\n}\n\nvoid GenericGraph::setVertexWeight(int\
    \ v, const Weight& weight) {\n    ensure(v < n(), \"setVertexWeight\");\n    v\
    \ = vertexByLabel(v);\n\n    vertexWeights_.extend(v + 1);\n    vertexWeights_[v]\
    \ = weight;\n}\n\nvoid GenericGraph::setEdgeWeights(const WeightArray& weights)\
    \ {\n    ensure(\n        static_cast<int>(weights.size()) == m(),\n        \"\
    The argument of setEdgeWeights must have exactly m elements\");\n    edgeWeights_\
    \ = weights;\n}\n\nvoid GenericGraph::setEdgeWeight(size_t index, const Weight&\
    \ weight) {\n    ensure(static_cast<int>(index) < m(), \"setEdgeWeight\");\n \
    \   edgeWeights_.extend(index + 1);\n    edgeWeights_[index] = weight;\n}\n\n\
    Weight GenericGraph::vertexWeight(int v) const {\n    ensure(v < n(), \"vertexWeight\"\
    );\n    size_t index = vertexByLabel(v);\n    if (index >= vertexWeights_.size())\
    \ {\n        return Weight{};\n    }\n    return vertexWeights_[index];\n}\n\n\
    Weight GenericGraph::edgeWeight(size_t index) const {\n    ensure(static_cast<int>(index)\
    \ < m(), \"edgeWeight\");\n    if (index >= edgeWeights_.size()) {\n        return\
    \ Weight{};\n    }\n    return edgeWeights_[index];\n}\n\nArray GenericGraph::edges(int\
    \ v) const {\n\n    ensure(v < n(), \"Graph::edges(v)\");\n    v = vertexByLabel(v);\n\
    \n    Array result = internalEdges(v);\n    for (auto& x: result) {\n        x\
    \ = vertexLabel(x);\n    }\n\n    return result;\n}\n\nArrayp GenericGraph::edges()\
    \ const {\n    auto edges = edges_;\n    for (auto& e: edges) {\n        e.first\
    \ = vertexLabel(e.first);\n        e.second = vertexLabel(e.second);\n    }\n\
    \    return edges;\n}\n\nWeightArray GenericGraph::prepareWeightArray(WeightArray\
    \ a, int requiredSize) {\n    ENSURE(a.hasNonEmpty(), \"Attempt to print empty\
    \ weight array\");\n\n    a.extend(requiredSize);\n    int type = a.anyType();\n\
    \    for (auto& x: a) {\n        if (x.empty()) {\n            x.setType(type);\n\
    \        }\n    }\n\n    return a;\n}\n\nvoid GenericGraph::doShuffle() {\n  \
    \  // this if is to be removed after all checks pass\n    if (vertexLabel_.size()\
    \ < static_cast<size_t>(n())) {\n        ENSURE(false, \"GenericGraph::doShuffle\"\
    );\n        vertexLabel_ = Array::id(n());\n    }\n\n    vertexLabel_.shuffle();\n\
    \    vertexByLabel_ = vertexLabel_.inverse();\n\n    doShuffleEdges();\n}\n\n\
    void GenericGraph::doShuffleAllBut(const Array& except) {\n    Array index = except.sorted();\n\
    \    Array needed = Array::id(n());\n    needed.erase(std::set_difference(\n \
    \               needed.begin(), needed.end(),\n                index.begin(),\
    \ index.end(),\n                needed.begin()), needed.end());\n    Array neededShuffled\
    \ = needed.shuffled();\n    Array perm = Array::id(n());\n    for (size_t i =\
    \ 0; i < needed.size(); ++i) {\n        perm[needed[i]] = neededShuffled[i];\n\
    \    }\n\n    vertexLabel_ = vertexLabel_.subseq(perm);\n    vertexByLabel_ =\
    \ vertexLabel_.inverse();\n\n    doShuffleEdges();\n}\n\nvoid GenericGraph::doShuffleEdges()\
    \ {\n    if (!directed_) {\n        for (auto& edge: edges_) {\n            if\
    \ (rnd.next(2)) {\n                std::swap(edge.first, edge.second);\n     \
    \       }\n        }\n    }\n\n    permuteEdges(Array::id(numEdges_).shuffled());\n\
    }\n\nvoid GenericGraph::extend(size_t size) {\n    checkLargeParameter(size);\n\
    \    size_t oldSize = n();\n    if (size > oldSize) {\n        adjList_.resize(size);\n\
    \        vertexLabel_ += Array::id(size - oldSize, oldSize);\n        vertexByLabel_\
    \ += Array::id(size - oldSize, oldSize);\n        dsu_.extend(size);\n    }\n\
    }\n\nArray GenericGraph::internalEdges(int v) const {\n    Array result;\n   \
    \ std::transform(\n        adjList_[v].begin(),\n        adjList_[v].end(),\n\
    \        std::back_inserter(result),\n        [this, v](int x) { return edgeOtherEnd(v,\
    \ x); }\n    );\n    return result;\n}\n\nvoid GenericGraph::addEdgeUnsafe(int\
    \ u, int v) {\n    int id = numEdges_++;\n    edges_.emplace_back(u, v);\n\n \
    \   ENSURE(u < n() && v < n(), \"GenericGraph::addEdgeUnsafe\");\n\n    adjList_[u].push_back(id);\n\
    \    if (!directed_ && u != v) {\n        adjList_[v].push_back(id);\n    }\n\
    }\n\nint GenericGraph::edgeOtherEnd(int v, int edgeId) const {\n    ENSURE(edgeId\
    \ < numEdges_);\n    const auto& edge = edges_[edgeId];\n    if (edge.first ==\
    \ v) {\n        return edge.second;\n    }\n    ENSURE(!directed_);\n    ENSURE(edge.second\
    \ == v);\n    return edge.first;\n}\n\nvoid GenericGraph::permuteEdges(const Array&\
    \ order) {\n    ENSURE(static_cast<int>(order.size()) == m(), \"GenericGraph::permuteEdges\"\
    );\n\n    edges_ = edges_.subseq(order);\n\n    auto newByOld = order.inverse();\n\
    \    for (int v = 0; v < n(); ++v) {\n        for (auto& x: adjList_[v]) {\n \
    \           x = newByOld[x];\n        }\n    }\n\n    if (edgeWeights_.hasNonEmpty())\
    \ {\n        edgeWeights_.extend(m());\n        edgeWeights_ = edgeWeights_.subseq(order);\n\
    \    }\n}\n\nvoid GenericGraph::addEdge(int u, int v, const Weight& w) {\n   \
    \ extend(std::max(u, v) + 1);\n\n    u = vertexByLabel(u);\n    v = vertexByLabel(v);\n\
    \n    dsu_.unite(u, v);\n    addEdgeUnsafe(u, v);\n\n    if (!w.empty()) {\n \
    \       setEdgeWeight(m() - 1, w);\n    }\n}\n\nvoid GenericGraph::doPrintEdges(\n\
    \    std::ostream& out, const OutputModifier& mod) const\n{\n    bool pendingEndline\
    \ = false;\n    if (mod.printN) {\n        out << n();\n        if (mod.printM)\
    \ {\n            out << \" \" << m();\n        }\n        pendingEndline = true;\n\
    \    } else if (mod.printM) {\n        out << m();\n        pendingEndline = true;\n\
    \    }\n\n    if (n() == 0) {\n        return;\n    }\n\n    if (vertexWeights_.hasNonEmpty())\
    \ {\n        auto vertexWeights = prepareWeightArray(vertexWeights_, n());\n \
    \       if (pendingEndline) {\n            out << \"\\n\";\n        }\n      \
    \  for (int i = 0; i < n(); ++i) {\n            if (i > 0) {\n               \
    \ out << \" \";\n            }\n            JNGEN_PRINT_NO_MOD(vertexWeights[vertexByLabel(i)]);\n\
    \        }\n        pendingEndline = true;\n    }\n\n    if (m() == 0) {\n   \
    \     return;\n    }\n\n    if (pendingEndline) {\n        out << \"\\n\";\n \
    \   }\n\n    auto t(mod);\n    {\n        auto mod(t);\n\n        Arrayp edges\
    \ = this->edges();\n        mod.printN = false;\n        if (edgeWeights_.hasNonEmpty())\
    \ {\n            auto edgeWeights = prepareWeightArray(edgeWeights_, m());\n \
    \           for (int i = 0; i < m(); ++i) {\n                if (i > 0) {\n  \
    \                  out << \"\\n\";\n                }\n                JNGEN_PRINT(edges[i]);\n\
    \                out << \" \";\n                JNGEN_PRINT_NO_MOD(edgeWeights[i]);\n\
    \            }\n        } else {\n            JNGEN_PRINT(edges);\n        }\n\
    \    }\n}\n\nbool GenericGraph::operator==(const GenericGraph& other) const {\n\
    \    return compareTo(other) == 0;\n}\n\nbool GenericGraph::operator!=(const GenericGraph&\
    \ other) const {\n    return compareTo(other) != 0;\n}\n\nbool GenericGraph::operator<(const\
    \ GenericGraph& other) const {\n    return compareTo(other) == -1;\n}\n\nbool\
    \ GenericGraph::operator>(const GenericGraph& other) const {\n    return compareTo(other)\
    \ == 1;\n}\n\nbool GenericGraph::operator<=(const GenericGraph& other) const {\n\
    \    return compareTo(other) != 1;\n}\n\nbool GenericGraph::operator>=(const GenericGraph&\
    \ other) const {\n    return compareTo(other) != -1;\n}\n\nvoid GenericGraph::normalizeEdges()\
    \ {\n    if (!config.normalizeEdges) {\n        return;\n    }\n    ENSURE(\n\
    \        vertexLabel_ == Array::id(n()),\n        \"Can call normalizeEdges()\
    \ only on newly created graph\");\n\n    if (!directed_) {\n        for (auto&\
    \ edge: edges_) {\n            if (edge.first > edge.second) {\n             \
    \   std::swap(edge.first, edge.second);\n            }\n        }\n    }\n\n \
    \   auto order = Array::id(numEdges_).sorted(\n        [this](int i, int j) {\n\
    \            return edges_[i] < edges_[j];\n        });\n\n    permuteEdges(order);\n\
    }\n\nint GenericGraph::compareTo(const GenericGraph& other) const {\n    if (n()\
    \ != other.n()) {\n        return n() < other.n() ? -1 : 1;\n    }\n    for (int\
    \ i = 0; i < n(); ++i) {\n        auto e1 = edges(i).sorted();\n        auto e2\
    \ = other.edges(i).sorted();\n        if (e1 != e2) {\n            return e1 <\
    \ e2 ? -1 : 1;\n        }\n    }\n    return 0;\n}\n\nvoid GenericGraph::initWithEdges(int\
    \ n, const Arrayp& edges) {\n    ENSURE(this->n() == 0, \"Can call initWithEdges\
    \ only on empty graph\");\n    extend(n);\n\n    edges_ = edges;\n    numEdges_\
    \ = edges.size();\n\n\n    Array degree(n);\n    for (const auto& edge: edges)\
    \ {\n        ++degree[edge.first];\n        if (!directed_ && edge.first != edge.second)\
    \ {\n            ++degree[edge.second];\n        }\n\n        dsu_.unite(edge.first,\
    \ edge.second);\n    }\n    for (int i = 0; i < n; ++i) {\n        adjList_[i].reserve(degree[i]);\n\
    \    }\n    for (size_t id = 0; id != edges.size(); ++id) {\n        const auto&\
    \ edge = edges[id];\n        adjList_[edge.first].push_back(id);\n        if (!directed_\
    \ && edge.first != edge.second) {\n            adjList_[edge.second].push_back(id);\n\
    \        }\n    }\n\n    normalizeEdges();\n}\n\n} // namespace jngen\n#undef\
    \ JNGEN_INCLUDE_GENERIC_GRAPH_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#line 6140\
    \ \"tests/jngen.h\"\n\nnamespace jngen {\n\nclass Tree : public ReprProxy<Tree>,\
    \ public GenericGraph {\npublic:\n    Tree() {\n        extend(1);\n    }\n\n\
    \    Tree(const GenericGraph& gg) : GenericGraph(gg) {\n        extend(1);\n \
    \       ensure(\n                dsu_.numComponents() == n() - m(),\n        \
    \        \"Cannot create a tree from a graph with cycles\");\n    }\n\n    void\
    \ addEdge(int u, int v, const Weight& w = Weight{}) override;\n\n    bool canAddEdge(int\
    \ u, int v);\n\n    Array parents(int root) const;\n\n    Tree& shuffle();\n \
    \   Tree shuffled() const;\n    Tree& shuffleAllBut(const Array& except);\n  \
    \  Tree shuffledAllBut(const Array& except) const;\n\n    Tree link(int vInThis,\
    \ const Tree& other, int vInOther);\n    Tree glue(int vInThis, const Tree& other,\
    \ int vInOther);\n\n    static Tree bamboo(int size);\n    static Tree random(int\
    \ size);\n    static Tree randomPrim(int size, int elongation = 0);\n    static\
    \ Tree randomKruskal(int size);\n    static Tree star(int size);\n    static Tree\
    \ caterpillar(int size, int length);\n    static Tree binary(int size);\n    static\
    \ Tree kary(int size, int k);\n\n    static Tree fromPruferSequence(const Array&\
    \ code);\n\n    void doPrintParents(std::ostream& out, const OutputModifier& mod)\
    \ const;\n};\n\nJNGEN_DECLARE_SIMPLE_PRINTER(Tree, 2) {\n    ensure(t.isConnected(),\
    \ \"Cannot print a tree: it is not connected\");\n\n    if (mod.printEdges) {\n\
    \        t.doPrintEdges(out, mod);\n    } else {\n        t.doPrintParents(out,\
    \ mod);\n    }\n}\n\ntemplate<>\nstruct Hash<Tree> {\n    uint64_t operator()(const\
    \ Tree& t) const {\n        return Hash<GenericGraph>{}(t);\n    }\n};\n\n} //\
    \ namespace jngen\n\nJNGEN_DEFINE_STD_HASH(jngen::Tree);\n\nusing jngen::Tree;\n\
    \n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_TREE_INL_H\n#ifndef JNGEN_INCLUDE_TREE_INL_H\n\
    #error File \"tree_inl.h\" must not be included directly.\n#endif\n\nvoid Tree::addEdge(int\
    \ u, int v, const Weight& w) {\n    extend(std::max(u, v) + 1);\n\n    u = vertexByLabel(u);\n\
    \    v = vertexByLabel(v);\n\n    int ret = dsu_.unite(u, v);\n    ensure(ret,\
    \ \"A cycle appeared in the tree\");\n\n    addEdgeUnsafe(u, v);\n\n    if (!w.empty())\
    \ {\n        setEdgeWeight(m() - 1, w);\n    }\n}\n\nbool Tree::canAddEdge(int\
    \ u, int v) {\n    u = vertexByLabel(u);\n    v = vertexByLabel(v);\n    return\
    \ dsu_.getRoot(u) != dsu_.getRoot(v);\n}\n\nArray Tree::parents(int root) const\
    \ {\n    ensure(isConnected(), \"Tree::parents(int): Tree is not connected\");\n\
    \    root = vertexByLabel(root);\n\n    Array parents(n());\n    parents[root]\
    \ = -1;\n    std::vector<int> used(n());\n    std::vector<int> queue{root};\n\
    \    for (size_t i = 0; i < queue.size(); ++i) {\n        int v = queue[i];\n\
    \        used[v] = true;\n        for (auto to: internalEdges(v)) {\n        \
    \    if (!used[to]) {\n                parents[to] = v;\n                queue.push_back(to);\n\
    \            }\n        }\n    }\n\n    for (auto& x: parents) {\n        if (x\
    \ != -1) {\n            x = vertexLabel(x);\n        }\n    }\n\n    return parents;\n\
    }\n\nTree& Tree::shuffle() {\n    doShuffle();\n    return *this;\n}\n\nTree Tree::shuffled()\
    \ const {\n    Tree t = *this;\n    return t.shuffle();\n}\n\nTree& Tree::shuffleAllBut(const\
    \ Array& except) {\n    doShuffleAllBut(except);\n    return *this;\n}\n\nTree\
    \ Tree::shuffledAllBut(const Array& except) const {\n    Tree g(*this);\n    return\
    \ g.shuffleAllBut(except);\n}\n\nTree Tree::link(int vInThis, const Tree& other,\
    \ int vInOther) {\n    ensure(vInThis < n(), \"Cannot link a nonexistent vertex\"\
    );\n    ensure(vInOther < other.n(), \"Cannot link to a nonexistent vertex\");\n\
    \n    Tree t(*this);\n\n    for (const auto& e: other.edges()) {\n        t.addEdge(e.first\
    \ + n(), e.second + n());\n    }\n\n    t.addEdge(vInThis, vInOther + n());\n\n\
    \    return t;\n}\n\nTree Tree::glue(int vInThis, const Tree& other, int vInOther)\
    \ {\n    ensure(vInThis < n(), \"Cannot glue a nonexistent vertex\");\n    ensure(vInOther\
    \ < other.n(), \"Cannot glue to a nonexistent vertex\");\n\n    auto newLabel\
    \ = [vInThis, vInOther, &other, this] (int v) {\n        if (v < vInOther) {\n\
    \            return n() + v;\n        } else if (v == vInOther) {\n          \
    \  return vInThis;\n        } else {\n            return n() + v - 1;\n      \
    \  }\n    };\n\n    Tree t(*this);\n\n    for (const auto& e: other.edges()) {\n\
    \        t.addEdge(newLabel(e.first), newLabel(e.second));\n    }\n\n    ensure(t.n()\
    \ == n() + other.n() - 1);\n\n    return t;\n}\n\n// Tree generators go here\n\
    \nTree Tree::bamboo(int size) {\n    ensure(size > 0, \"Number of vertices in\
    \ the tree must be positive\");\n    checkLargeParameter(size);\n    Tree t;\n\
    \    for (int i = 0; i + 1 < size; ++i) {\n        t.addEdge(i, i+1);\n    }\n\
    \    t.normalizeEdges();\n    return t;\n}\n\nTree Tree::random(int size) {\n\
    \    ensure(size > 0, \"Number of vertices in the tree must be positive\");\n\
    \    checkLargeParameter(size);\n    if (size == 1) {\n        return Tree();\n\
    \    }\n    return fromPruferSequence(Array::random(size - 2, size));\n}\n\nTree\
    \ Tree::randomPrim(int size, int elongation) {\n    ensure(size > 0, \"Number\
    \ of vertices in the tree must be positive\");\n    checkLargeParameter(size);\n\
    \    Tree t;\n    for (int v = 1; v < size; ++v) {\n        int parent = rnd.wnext(v,\
    \ elongation);\n        t.addEdge(parent, v);\n    }\n    t.normalizeEdges();\n\
    \    return t;\n}\n\nTree Tree::randomKruskal(int size) {\n    ensure(size > 0,\
    \ \"Number of vertices in the tree must be positive\");\n    checkLargeParameter(size);\n\
    \    Tree t;\n    t.extend(size);\n    while (!t.isConnected()) {\n        auto\
    \ e = rnd.nextp(size, dpair);\n        if (t.canAddEdge(e.first, e.second)) {\n\
    \            t.addEdge(e.first, e.second);\n        }\n    }\n    return t;\n\
    }\n\nTree Tree::star(int size) {\n    ensure(size > 0, \"Number of vertices in\
    \ the tree must be positive\");\n    checkLargeParameter(size);\n    Tree t;\n\
    \    for (int i = 1; i < size; ++i) {\n        t.addEdge(0, i);\n    }\n    t.normalizeEdges();\n\
    \    return t;\n}\n\nTree Tree::caterpillar(int size, int length) {\n    ensure(size\
    \ > 0, \"Number of vertices in the tree must be positive\");\n    ensure(length\
    \ > 0, \"Length of the caterpillar must be positive\");\n    checkLargeParameter(size);\n\
    \    ensure(length <= size);\n    Tree t = Tree::bamboo(length);\n    for (int\
    \ i = length; i < size; ++i) {\n        t.addEdge(rnd.next(length), i);\n    }\n\
    \    t.normalizeEdges();\n    return t;\n}\n\nTree Tree::binary(int size) {\n\
    \    return kary(size, 2);\n}\n\nTree Tree::kary(int size, int k) {\n    ensure(size\
    \ > 0, \"Number of vertices in the tree must be positive\");\n    checkLargeParameter(size);\n\
    \n    Tree t;\n    for (int i = 1; i < size; ++i) {\n        t.addEdge((i - 1)\
    \ / k, i);\n    }\n    t.normalizeEdges();\n    return t;\n}\n\nTree Tree::fromPruferSequence(const\
    \ Array& code) {\n    std::vector<int> degree(code.size() + 2, 1);\n    for (int\
    \ v: code) {\n        ++degree[v];\n    }\n\n    std::set<int> leaves;\n    for\
    \ (size_t v = 0; v != degree.size(); ++v) {\n        if (degree[v] == 1) {\n \
    \           leaves.insert(v);\n        }\n    }\n\n    Tree t;\n    for (int v:\
    \ code) {\n        ENSURE(!leaves.empty());\n        int to = *leaves.begin();\n\
    \        leaves.erase(leaves.begin());\n        if (--degree[v] == 1) {\n    \
    \        leaves.insert(v);\n        }\n\n        t.addEdge(v, to);\n    }\n\n\
    \    ENSURE(leaves.size() == 2u);\n    t.addEdge(*leaves.begin(), *leaves.rbegin());\n\
    \    t.normalizeEdges();\n    return t;\n\n}\n\nvoid Tree::doPrintParents(std::ostream&\
    \ out, const OutputModifier& mod) const {\n    int root = mod.printParents;\n\
    \    if (root == -1) {\n        root = 0;\n    }\n\n    auto parents = this->parents(root);\n\
    \    if (mod.printParents == -1) {\n        parents.erase(parents.begin());\n\
    \    }\n\n    if (mod.printN) {\n        out << n() << \"\\n\";\n    }\n\n   \
    \ // TODO: avoid copy-paste from doPrintEdges\n    if (mod.printWeights && vertexWeights_.hasNonEmpty())\
    \ {\n        auto vertexWeights = prepareWeightArray(vertexWeights_, n());\n \
    \       for (int i = 0; i < n(); ++i) {\n            if (i > 0) {\n          \
    \      out << \" \";\n            }\n            JNGEN_PRINT_NO_MOD(vertexWeights[vertexByLabel(i)]);\n\
    \        }\n        out << \"\\n\";\n    }\n\n    auto t(mod);\n    {\n      \
    \  auto mod(t);\n        mod.printN = false;\n\n        if (mod.printWeights &&\
    \ edgeWeights_.hasNonEmpty()) {\n            ensure(false, \"Printing parents\
    \ and edge weights is not supported\");\n            ensure(\n               \
    \ mod.printParents == -1,\n                \"Root must not be set to any exact\
    \ value when printing a tree \"\n                \"with edge weights. To fix it,\
    \ either set printParents() \"\n                \"or printWeights(false)\");\n\
    \            ENSURE(root == 0);\n            // TODO: some code to be here\n \
    \       } else {\n            JNGEN_PRINT(parents);\n        }\n    }\n}\n\n#undef\
    \ JNGEN_INCLUDE_TREE_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#line 6498 \"tests/jngen.h\"\
    \n\nnamespace jngen {\n\nclass Graph : public ReprProxy<Graph>, public GenericGraph\
    \ {\n    using BuilderProxy = graph_detail::BuilderProxy;\n    using Traits =\
    \ graph_detail::Traits;\n\n    friend class graph_detail::GraphRandom;\n    friend\
    \ class graph_detail::BuilderProxy;\n\npublic:\n    virtual ~Graph() {}\n    Graph()\
    \ {}\n\n    Graph(int n) {\n        extend(n);\n    }\n\n    Graph(const GenericGraph&\
    \ gg) : GenericGraph(gg) {}\n\n    void setN(int n);\n\n    Graph& shuffle();\n\
    \    Graph shuffled() const;\n    Graph& shuffleAllBut(const Array& except);\n\
    \    Graph shuffledAllBut(const Array& except) const;\n\n    static BuilderProxy\
    \ random(int n, int m);\n    static BuilderProxy complete(int n);\n    static\
    \ BuilderProxy empty(int n);\n    static BuilderProxy cycle(int n);\n    static\
    \ BuilderProxy randomStretched(\n            int n, int m, int elongation, int\
    \ spread);\n    static BuilderProxy randomBipartite(int n1, int n2, int m);\n\
    \    static BuilderProxy completeBipartite(int n1, int n2);\n};\n\ninline void\
    \ Graph::setN(int n) {\n    ensure(n >= this->n(), \"Cannot lessen number of vertices\
    \ in the graph\");\n    extend(n);\n}\n\ninline Graph& Graph::shuffle() {\n  \
    \  doShuffle();\n    return *this;\n}\n\ninline Graph Graph::shuffled() const\
    \ {\n    Graph g(*this);\n    return g.shuffle();\n}\n\ninline Graph& Graph::shuffleAllBut(const\
    \ Array& except) {\n    doShuffleAllBut(except);\n    return *this;\n}\n\ninline\
    \ Graph Graph::shuffledAllBut(const Array& except) const {\n    Graph g(*this);\n\
    \    return g.shuffleAllBut(except);\n}\n\nJNGEN_DECLARE_SIMPLE_PRINTER(Graph,\
    \ 2) {\n    t.doPrintEdges(out, mod);\n}\n\nJNGEN_DECLARE_SIMPLE_PRINTER(graph_detail::BuilderProxy,\
    \ 2) {\n    JNGEN_PRINT(t.g());\n}\n\ntemplate<>\nstruct Hash<Graph> {\n    uint64_t\
    \ operator()(const Graph& g) const {\n        return Hash<GenericGraph>{}(g);\n\
    \    };\n};\n\n} // namespace jngen\n\nusing jngen::Graph;\n\nJNGEN_DEFINE_STD_HASH(jngen::Graph);\n\
    \n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_GRAPH_INL_H\n#ifndef JNGEN_INCLUDE_GRAPH_INL_H\n\
    #error File \"graph_inl.h\" must not be included directly.\n#endif\n\n\nnamespace\
    \ jngen {\n\nnamespace graph_detail {\n\nGraph BuilderProxy::g() const {\n   \
    \ return builder_(traits_);\n}\n\nBuilderProxy::operator Graph() const {\n   \
    \ return g();\n}\n\nclass GraphRandom {\n    using BuilderProxy = graph_detail::BuilderProxy;\n\
    \    using Traits = graph_detail::Traits;\n\npublic:\n    GraphRandom() {\n  \
    \      static bool created = false;\n        ensure(!created, \"jngen::GraphRandom\
    \ should be created only once\");\n        created = true;\n    }\n\n    static\
    \ BuilderProxy random(int n, int m) {\n        ensure(\n            n >= 0 &&\
    \ m >= 0,\n            \"Number of vertices and edges in the graph must be nonnegative\"\
    );\n        checkLargeParameter(n);\n        checkLargeParameter(m);\n       \
    \ return BuilderProxy(Traits(n, m), &doRandom);\n    }\n\n    static BuilderProxy\
    \ complete(int n) {\n        ensure(\n            n >= 0,\n            \"Number\
    \ of vertices and edges in the graph must be nonnegative\");\n        checkLargeParameter(n\
    \ * n);\n        return BuilderProxy(Traits(n), [](Traits t) {\n            Graph\
    \ g;\n            g.setN(t.n);\n            if (t.directed) {\n              \
    \  g.directed_ = true;\n            }\n            for (int i = 0; i < t.n; ++i)\
    \ {\n                for (int j = 0; j <= i; ++j) {\n                    if (i\
    \ == j) {\n                        if (t.allowLoops) {\n                     \
    \       g.addEdge(i, j);\n                        }\n                        continue;\n\
    \                    }\n\n                    if (t.directed) {\n            \
    \            if (t.acyclic) {\n                            g.addEdge(i, j);\n\
    \                        } else if (t.allowAntiparallel) {\n                 \
    \           g.addEdge(i, j);\n                            g.addEdge(j, i);\n \
    \                       } else {\n                            if (rnd.next(2))\
    \ {\n                                g.addEdge(i, j);\n                      \
    \      } else {\n                                g.addEdge(j, i);\n          \
    \                  }\n                        }\n                    } else {\n\
    \                        g.addEdge(i, j);\n                    }\n           \
    \     }\n            }\n            g.normalizeEdges();\n            return g;\n\
    \        });\n    }\n\n    static BuilderProxy empty(int n) {\n        ensure(\n\
    \            n >= 0,\n            \"Number of vertices and edges in the graph\
    \ must be nonnegative\");\n        checkLargeParameter(n);\n        return BuilderProxy(Traits(n),\
    \ [](Traits t) {\n            ensure(\n                t.n <= 1 || !t.connected,\n\
    \                \"Empty graph on >1 vertices cannot be connected\");\n      \
    \      Graph g;\n            if (t.directed) {\n                g.directed_ =\
    \ true;\n            }\n            g.setN(t.n);\n            return g;\n    \
    \    });\n    }\n\n    static BuilderProxy cycle(int n) {\n        ensure(\n \
    \           n >= 0,\n            \"Number of vertices and edges in the graph must\
    \ be nonnegative\");\n        checkLargeParameter(n);\n        return BuilderProxy(Traits(n),\
    \ [](Traits t) {\n            Graph g;\n            if (t.directed) {\n      \
    \          g.directed_ = true;\n                ensure(!t.acyclic, \"Cannot generate\
    \ acyclic cycle\");\n            }\n            for (int i = 0; i < t.n; ++i)\
    \ {\n                g.addEdge(i, (i+1)%t.n);\n            }\n            g.normalizeEdges();\n\
    \            return g;\n        });\n    }\n\n    static BuilderProxy randomStretched(\n\
    \            int n, int m, int elongation, int spread)\n    {\n        ensure(\n\
    \            n >= 0 && m >= 0,\n            \"Number of vertices and edges in\
    \ the graph must be nonnegative\");\n        checkLargeParameter(n);\n       \
    \ checkLargeParameter(m);\n        return BuilderProxy(Traits(n, m), [elongation,\
    \ spread](Traits t) {\n            return doRandomStretched(t, elongation, spread);\n\
    \        });\n    }\n\n    static BuilderProxy randomBipartite(int n1, int n2,\
    \ int m) {\n        ensure(\n            n1 >= 0 && n2 >= 0 && m >= 0,\n     \
    \       \"Number of vertices and edges in the graph must be nonnegative\");\n\
    \        checkLargeParameter(n1 + n2);\n        checkLargeParameter(m);\n    \
    \    return BuilderProxy(Traits(0, m), [n1, n2](Traits t) {\n                return\
    \ doRandomBipartite(t, n1, n2);\n        });\n    }\n\n\n    static BuilderProxy\
    \ completeBipartite(int n1, int n2) {\n        ensure(\n            n1 >= 0 &&\
    \ n2 >= 0,\n            \"Number of vertices and edges in the graph must be nonnegative\"\
    );\n        checkLargeParameter(n1 * n2);\n        return BuilderProxy(Traits(0,\
    \ 0), [n1, n2](Traits t) {\n            ensure(!t.directed, \"Directed bipartite\
    \ graphs are not supported\");\n\n            Arrayp edges;\n            edges.reserve(n1\
    \ * n2);\n            for (int u = 0; u < n1; ++u) {\n                for (int\
    \ v = 0; v < n2; ++v) {\n                    edges.emplace_back(u, v + n1);\n\
    \                }\n            }\n\n            Graph g;\n            g.initWithEdges(n1\
    \ + n2, edges);\n            return g;\n        });\n    }\n\nprivate:\n    static\
    \ Graph doRandom(Traits t) {\n        int n = t.n;\n        int m = t.m;\n\n \
    \       if (!t.allowMulti) {\n            ensure(m <= maxEdges(n, t), \"Too many\
    \ edges in the graph\");\n        }\n\n        std::unordered_set<std::pair<int,\
    \ int>> usedEdges;\n\n        if (t.connected) {\n            ensure(m >= n -\
    \ 1, \"Not enough edges for a connected graph\");\n            auto treeEdges\
    \ = Tree::random(n).edges();\n            if (t.directed) {\n                for\
    \ (auto& edge: treeEdges) {\n                    if (rnd.next(2)) {\n        \
    \                std::swap(edge.first, edge.second);\n                    }\n\
    \                }\n            }\n            usedEdges.insert(treeEdges.begin(),\
    \ treeEdges.end());\n            ENSURE(usedEdges.size() == static_cast<size_t>(n\
    \ - 1));\n        }\n\n        auto edgeIsGood = [&usedEdges, t](std::pair<int,\
    \ int> edge) {\n            if (!t.allowMulti && usedEdges.count(edge)) {\n  \
    \              return false;\n            }\n            if (t.directed && !t.allowAntiparallel\
    \ &&\n                    usedEdges.count({edge.second, edge.first}))\n      \
    \      {\n                return false;\n            }\n            return true;\n\
    \        };\n\n        Arrayp result(usedEdges.begin(), usedEdges.end());\n  \
    \      result.reserve(m);\n\n        while (result.size() < static_cast<size_t>(m))\
    \ {\n            auto edge = randomEdge(n, t);\n            if (edgeIsGood(edge))\
    \ {\n                usedEdges.insert(edge);\n                result.push_back(edge);\n\
    \            }\n        }\n\n        Graph graph;\n\n        if (t.directed &&\
    \ t.acyclic) {\n            makeAcyclic(result);\n        }\n        if (t.directed)\
    \ {\n            graph.directed_ = true;\n        }\n\n        graph.initWithEdges(n,\
    \ result);\n        return graph;\n    }\n\n    static Graph doRandomStretched(Traits\
    \ t, int elongation, int spread) {\n        Tree tree = Tree::randomPrim(t.n,\
    \ elongation);\n        Array parents = tree.parents(0);\n        parents[0] =\
    \ 0;\n\n\n        auto treeEdges = tree.edges();\n        if (t.directed && !t.acyclic)\
    \ {\n            for (auto& edge: treeEdges) {\n                if (rnd.next(2))\
    \ {\n                    std::swap(edge.first, edge.second);\n               \
    \ }\n            }\n        }\n\n        Arrayp edges = treeEdges;\n        edges.reserve(t.m);\n\
    \n        std::unordered_set<std::pair<int, int>> usedEdges(\n            treeEdges.begin(),\
    \ treeEdges.end());\n\n        auto edgeIsGood = [&usedEdges, t](std::pair<int,\
    \ int> edge) {\n            if (!t.allowMulti && usedEdges.count(edge)) {\n  \
    \              return false;\n            }\n            if (t.directed && !t.allowAntiparallel\
    \ &&\n                    usedEdges.count({edge.second, edge.first}))\n      \
    \      {\n                return false;\n            }\n            return true;\n\
    \        };\n\n        constexpr size_t MAX_ATTEMPTS = 1000;\n        size_t attemptsToFail\
    \ = MAX_ATTEMPTS;\n\n        while (static_cast<int>(edges.size()) != t.m) {\n\
    \            if (--attemptsToFail == 0) {\n                ensure(false, format(\"\
    Cannot generate random stretched graph \"\n                    \"with parameters\
    \ %d, %d, %d, %d\",\n                    t.n, t.m, elongation, spread));\n   \
    \         }\n            int u = rnd.next(t.n);\n            int up = rnd.next(0,\
    \ spread);\n            int v = u;\n            for (int iter = 0; iter < up;\
    \ ++iter) {\n                v = parents[v];\n            }\n\n            ENSURE(v\
    \ <= u);\n\n            if (!t.allowLoops && u == v) {\n                continue;\n\
    \            }\n\n            if (!edgeIsGood({v, u})) {\n                continue;\n\
    \            }\n\n            if (t.directed && !t.acyclic && rnd.next(2)) {\n\
    \                std::swap(u, v);\n            }\n\n            edges.emplace_back(v,\
    \ u);\n            attemptsToFail = MAX_ATTEMPTS;\n        }\n\n        Graph\
    \ graph;\n        if (t.directed) {\n            graph.directed_ = true;\n   \
    \     }\n\n        graph.initWithEdges(t.n, edges);\n        return graph;\n \
    \   }\n\n    static Graph doRandomBipartite(Traits t, int n1, int n2) {\n    \
    \    int m = t.m;\n\n        if (!t.allowMulti) {\n            ensure(m <= static_cast<long\
    \ long>(n1) * n2,\n                    \"Too many edges in the graph\");\n   \
    \     }\n\n        ensure(!t.directed, \"Directed bipartite graphs are not supported\"\
    );\n\n        std::unordered_set<std::pair<int, int>> usedEdges;\n\n        if\
    \ (t.connected) {\n            ensure(m >= n1 + n2 - 1, \"Not enough edges for\
    \ a connected graph\");\n            auto pruferCode = Array::random(n2 - 1, 0,\
    \ n1 - 1) +\n                Array::random(n1 - 1, n1, n1 + n2 - 1);\n       \
    \     pruferCode.shuffle();\n            auto treeEdges = Tree::fromPruferSequence(pruferCode).edges();\n\
    \            usedEdges.insert(treeEdges.begin(), treeEdges.end());\n         \
    \   ENSURE(usedEdges.size() == static_cast<size_t>(n1 + n2 - 1));\n        }\n\
    \n        auto edgeIsGood = [&usedEdges, t](std::pair<int, int> edge) {\n    \
    \        if (!t.allowMulti && usedEdges.count(edge)) {\n                return\
    \ false;\n            }\n            if (t.directed && !t.allowAntiparallel &&\n\
    \                    usedEdges.count({edge.second, edge.first}))\n           \
    \ {\n                return false;\n            }\n            return true;\n\
    \        };\n\n        Arrayp result(usedEdges.begin(), usedEdges.end());\n  \
    \      result.reserve(m);\n\n        while (result.size() < static_cast<size_t>(m))\
    \ {\n            int u = rnd.next(0, n1 - 1);\n            int v = rnd.next(n1,\
    \ n1 + n2 - 1);\n            std::pair<int, int> edge(u, v);\n            if (edgeIsGood(edge))\
    \ {\n                usedEdges.insert(edge);\n                result.push_back(edge);\n\
    \            }\n        }\n\n        Graph graph;\n\n        graph.initWithEdges(n1\
    \ + n2, result);\n        return graph;\n    }\n\n    static std::pair<int, int>\
    \ randomEdge(int n, const Traits& t) {\n        return rnd.nextp(n, RandomPairTraits{!t.directed,\
    \ !t.allowLoops});\n    }\n\n    static long long maxEdges(int n, const Traits&\
    \ t) {\n        ENSURE(!t.allowMulti);\n        long long res = static_cast<long\
    \ long>(n) * (n-1);\n        if (!(t.directed && t.allowAntiparallel)) {\n   \
    \         res /= 2;\n        }\n        if (t.allowLoops) {\n            res +=\
    \ n;\n        }\n        return res;\n    }\n\n    static void makeAcyclic(Arrayp&\
    \ edges) {\n        auto numbering = Array::id(edges.size()).shuffle();\n    \
    \    for (auto& edge: edges) {\n            if (numbering[edge.first] > numbering[edge.second])\
    \ {\n                std::swap(edge.first, edge.second);\n            }\n    \
    \    }\n    }\n};\n\n} // namespace graph_detail\n\nGraph::BuilderProxy Graph::random(int\
    \ n, int m) {\n    return graph_detail::GraphRandom::random(n, m);\n}\n\nGraph::BuilderProxy\
    \ Graph::complete(int n) {\n    return graph_detail::GraphRandom::complete(n);\n\
    }\n\nGraph::BuilderProxy Graph::empty(int n) {\n    return graph_detail::GraphRandom::empty(n);\n\
    }\n\nGraph::BuilderProxy Graph::cycle(int n) {\n    return graph_detail::GraphRandom::cycle(n);\n\
    }\n\nGraph::BuilderProxy Graph::randomStretched(\n        int n, int m, int elongation,\
    \ int spread) {\n    return graph_detail::GraphRandom::randomStretched(n, m, elongation,\
    \ spread);\n}\n\nGraph::BuilderProxy Graph::randomBipartite(int n1, int n2, int\
    \ m) {\n    return graph_detail::GraphRandom::randomBipartite(n1, n2, m);\n}\n\
    \nGraph::BuilderProxy Graph::completeBipartite( int n1, int n2) {\n    return\
    \ graph_detail::GraphRandom::completeBipartite(n1, n2);\n}\n\n} // namespace jngen\n\
    #undef JNGEN_INCLUDE_GRAPH_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#line 7001\
    \ \"tests/jngen.h\"\n\nnamespace jngen {\nnamespace suites {\n\nJNGEN_CHAINING_TRAITS(GeneralGraphSuiteTraits,\
    \ allowLoops, allowMulti, connected)\n\nclass GeneralGraphSuite : public BaseTestSuite<Graph,\
    \ GeneralGraphSuiteTraits, int, int> {\n    graph_detail::BuilderProxy&& apply(graph_detail::BuilderProxy&&\
    \ builder) const {\n        builder.allowLoops(conf_._allowLoops);\n        builder.allowMulti(conf_._allowMulti);\n\
    \        builder.connected(conf_._connected);\n        return std::move(builder);\n\
    \    }\n\n    int selectMForRandom(int n, int m, double ratio) const {\n     \
    \   if (conf_._connected) {\n            return std::min(m, n + static_cast<int>((m\
    \ - n + 1) * ratio));\n        } else {\n            return std::max(1, static_cast<int>(m\
    \ * ratio));\n        }\n    }\n\n    Graph randomWithRatio(int n, int m, double\
    \ ratio) const {\n        return apply(Graph::random(n, selectMForRandom(n, m,\
    \ ratio))).g();\n    }\n\npublic:\n    GeneralGraphSuite() : BaseTestSuite(\"\
    GeneralGraphSuite\") {\n#define JNGEN_PRODUCER_ARGS int n, int m\n\n        JNGEN_ADD_PRODUCER(random0.001)\
    \ {\n            return randomWithRatio(n, m, 0.001);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.005)\
    \ {\n            return randomWithRatio(n, m, 0.005);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.01)\
    \ {\n            return randomWithRatio(n, m, 0.01);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.02)\
    \ {\n            return randomWithRatio(n, m, 0.02);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.05)\
    \ {\n            return randomWithRatio(n, m, 0.05);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.1)\
    \ {\n            return randomWithRatio(n, m, 0.1);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.2)\
    \ {\n            return randomWithRatio(n, m, 0.2);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.3)\
    \ {\n            return randomWithRatio(n, m, 0.3);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.4)\
    \ {\n            return randomWithRatio(n, m, 0.4);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.6)\
    \ {\n            return randomWithRatio(n, m, 0.6);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.7)\
    \ {\n            return randomWithRatio(n, m, 0.7);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.9)\
    \ {\n            return randomWithRatio(n, m, 0.9);\n        };\n\n        JNGEN_ADD_PRODUCER(random1)\
    \ {\n            return randomWithRatio(n, m, 1);\n        };\n\n        JNGEN_ADD_PRODUCER(cycle)\
    \ {\n            (void)m;\n            return Graph::cycle(n);\n        };\n\n\
    \        JNGEN_ADD_PRODUCER(complete) {\n            int size = 1;\n         \
    \   while (size <= n && size * (size - 1) / 2 +\n                    (conf_._allowLoops\
    \ ? size : 0) <= m) {\n                ++size;\n            }\n            return\
    \ apply(Graph::complete(size - 1));\n        };\n\n        JNGEN_ADD_PRODUCER(bamboo)\
    \ {\n            (void)m;\n            return Graph(Tree::bamboo(n));\n      \
    \  };\n\n        JNGEN_ADD_PRODUCER(star) {\n            (void)m;\n          \
    \  return Graph(Tree::star(n));\n        };\n\n        JNGEN_ADD_PRODUCER(wheel)\
    \ {\n            Graph g = Tree::star(n);\n            int edges = m - (n - 1);\n\
    \            for (int i = 1; i < n && edges > 0; ++i) {\n                g.addEdge(i,\
    \ i == n-1 ? 1 : i+1);\n            }\n            return g;\n        };\n\n#undef\
    \ JNGEN_PRODUCER_ARGS\n    }\n};\n\n} // namespace test_suites\n} // namespace\
    \ jngen\n\n\n#line 7125 \"tests/jngen.h\"\n\nnamespace jngen {\nnamespace suites\
    \ {\n\nJNGEN_CHAINING_TRAITS(GeneralTreeSuiteTraits, _)\n\nclass GeneralTreeSuite\
    \ : public BaseTestSuite<Tree, GeneralTreeSuiteTraits, int> {\npublic:\n    GeneralTreeSuite()\
    \ : BaseTestSuite(\"GeneralTreeSuite\") {\n#define JNGEN_PRODUCER_ARGS int n\n\
    \n        JNGEN_ADD_PRODUCER(random1) {\n            return Tree::random(n);\n\
    \        };\n\n        JNGEN_ADD_PRODUCER(random2) {\n            return Tree::random(n);\n\
    \        };\n\n        JNGEN_ADD_PRODUCER(random3) {\n            return Tree::random(n);\n\
    \        };\n\n        JNGEN_ADD_PRODUCER(bamboo) {\n            return Tree::bamboo(n);\n\
    \        };\n\n        JNGEN_ADD_PRODUCER(shuffled_bamboo) {\n            return\
    \ Tree::bamboo(n).shuffled();\n        };\n\n        JNGEN_ADD_PRODUCER(3branches)\
    \ {\n            int k = (n - 1) / 3 + 1;\n\n            Tree t = Tree::bamboo(k);\n\
    \            t = t.glue(0, Tree::bamboo(k), 0);\n            t = t.glue(0, Tree::bamboo(k),\
    \ 0);\n\n            ENSURE(t.n() <= n);\n\n            return t;\n        };\n\
    \n        JNGEN_ADD_PRODUCER(sqrt_branches) {\n            int k = std::sqrt(n)\
    \ + 1;\n            Tree t = Tree::bamboo(k);\n            while (t.n() + k -\
    \ 1 <= n) {\n                t = t.glue(0, Tree::bamboo(k), 0);\n            }\n\
    \            ENSURE(t.n() <= n);\n            return t;\n        };\n\n      \
    \  JNGEN_ADD_PRODUCER(branches_123) {\n            Tree t = Tree::bamboo(2);\n\
    \            for (int i = 2; t.n() + i <= n; ++i) {\n                t = t.link(0,\
    \ Tree::bamboo(i), 0);\n            }\n            ENSURE(t.n() < n);\n      \
    \      return t;\n        };\n\n        JNGEN_ADD_PRODUCER(binary) {\n       \
    \     return Tree::binary(n);\n        };\n\n        JNGEN_ADD_PRODUCER(3ary)\
    \ {\n            return Tree::kary(n, 3);\n        };\n\n        JNGEN_ADD_PRODUCER(4ary)\
    \ {\n            return Tree::kary(n, 4);\n        };\n\n        JNGEN_ADD_PRODUCER(50ary)\
    \ {\n            return Tree::kary(n, 50);\n        };\n\n        JNGEN_ADD_PRODUCER(500ary)\
    \ {\n            return Tree::kary(n, 500);\n        };\n\n        JNGEN_ADD_PRODUCER(star)\
    \ {\n            return Tree::star(n);\n        };\n\n        JNGEN_ADD_PRODUCER(shuffled_star)\
    \ {\n            return Tree::star(n).shuffled();\n        };\n\n        JNGEN_ADD_PRODUCER(caterpillar_len90)\
    \ {\n            return Tree::caterpillar(n, n * 0.9);\n        };\n\n       \
    \ JNGEN_ADD_PRODUCER(caterpillar_len50) {\n            return Tree::caterpillar(n,\
    \ n * 0.5);\n        };\n\n        JNGEN_ADD_PRODUCER(caterpillar_len10) {\n \
    \           return Tree::caterpillar(n, n * 0.1);\n        };\n\n        JNGEN_ADD_PRODUCER(broom_n/2)\
    \ {\n            auto t1 = Tree::bamboo(n/2);\n            auto t2 = Tree::star(n\
    \ - n/2);\n            return t1.link(n/2 - 1, t2, 0);\n        };\n\n       \
    \ JNGEN_ADD_PRODUCER(random_w-100) {\n            return Tree::randomPrim(n, -100);\n\
    \        };\n\n        JNGEN_ADD_PRODUCER(random_w-50) {\n            return Tree::randomPrim(n,\
    \ -50);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w-10) {\n           \
    \ return Tree::randomPrim(n, -10);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w-5)\
    \ {\n            return Tree::randomPrim(n, -5);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w0)\
    \ {\n            return Tree::randomPrim(n, 0);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w5)\
    \ {\n            return Tree::randomPrim(n, 5);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w10)\
    \ {\n            return Tree::randomPrim(n, 10);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w50)\
    \ {\n            return Tree::randomPrim(n, 50);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w100)\
    \ {\n            return Tree::randomPrim(n, 100);\n        };\n\n#undef JNGEN_PRODUCER_ARGS\n\
    \    }\n};\n\n} // namespace test_suites\n} // namespace jngen\n\n\nnamespace\
    \ jngen {\n\nstruct TestSuites {\n    suites::GeneralGraphSuite graph;\n    suites::GeneralTreeSuite\
    \ tree;\n};\n\nJNGEN_EXTERN TestSuites testSuites;\n\n} // namespace jngen\n\n\
    using jngen::testSuites;\n#pragma GCC diagnostic pop // -Wconversion\n#if __clang__major\
    \ >= 5\n#pragma GCC diagnostic pop // -Wunused-lambda-capture\n#endif\n"
  code: "/*\n  Copyright (c) 2016-2018 Ivan Smirnov\n\n  Permission is hereby granted,\
    \ free of charge, to any person obtaining a copy\n  of this software and associated\
    \ documentation files (the \"Software\"), to deal\n  in the Software without restriction,\
    \ including without limitation the rights\n  to use, copy, modify, merge, publish,\
    \ distribute, sublicense, and/or sell\n  copies of the Software, and to permit\
    \ persons to whom the Software is\n  furnished to do so, subject to the following\
    \ conditions:\n\n  The above copyright notice and this permission notice shall\
    \ be included in all\n  copies or substantial portions of the Software.\n\n  THE\
    \ SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n \
    \ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n \
    \ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
    \  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY,\
    \ WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF\
    \ OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\
    */\n\n/*\n    This file is automatically generated and is not supposed to be edited\n\
    \  directly. Source code can be found on https://github.com/ifsmirnov/jngen.\n\
    \n  Follow the same link for docs and reference.\n*/\n\n#define JNGEN_VERSION\
    \ 0.1\n\n// https://github.com/ifsmirnov/jngen/issues/5\n#pragma GCC diagnostic\
    \ push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n\n// this warning is\
    \ buggy in clang >= 5\n#if __clang_major__ >= 5\n#pragma GCC diagnostic push\n\
    #pragma GCC diagnostic ignored \"-Wunused-lambda-capture\"\n#endif\n\n#define\
    \ JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, name) \\\nint _ ## name = 0; \\\n\
    Class& name(int val = 1) { _ ## name = val; return *this; }\n\n#define JNGEN_CHAINING_TRAITS_INNER_0(Class)\n\
    #define JNGEN_CHAINING_TRAITS_INNER_1(Class, arg)       JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg)\n#define JNGEN_CHAINING_TRAITS_INNER_2(Class, arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_1(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_3(Class,\
    \ arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_2(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_4(Class, arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_3(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_5(Class,\
    \ arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_4(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_6(Class, arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_5(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_7(Class,\
    \ arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_6(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_8(Class, arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_7(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_9(Class,\
    \ arg, ...)  JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_8(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_10(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_9(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_11(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_10(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_12(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_11(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_13(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_12(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_14(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_13(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_15(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_14(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_16(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_15(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_17(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_16(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_18(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_17(Class, __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_19(Class,\
    \ arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class, arg) JNGEN_CHAINING_TRAITS_INNER_18(Class,\
    \ __VA_ARGS__)\n#define JNGEN_CHAINING_TRAITS_INNER_20(Class, arg, ...) JNGEN_DEFINE_CHAINING_TRAITS_FIELD(Class,\
    \ arg) JNGEN_CHAINING_TRAITS_INNER_19(Class, __VA_ARGS__)\n\n#define JNGEN_GET_CHAINING_TRAITS_INNER_IMPL(p1,\
    \ p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18,\
    \ p19, p20, x, ...) x\n\n#define JNGEN_GET_CHAINING_TRAITS_INNER(...) JNGEN_GET_CHAINING_TRAITS_INNER_IMPL(\\\
    \n        __VA_ARGS__,\\\n        JNGEN_CHAINING_TRAITS_INNER_20,\\\n        JNGEN_CHAINING_TRAITS_INNER_19,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_18,\\\n        JNGEN_CHAINING_TRAITS_INNER_17,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_16,\\\n        JNGEN_CHAINING_TRAITS_INNER_15,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_14,\\\n        JNGEN_CHAINING_TRAITS_INNER_13,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_12,\\\n        JNGEN_CHAINING_TRAITS_INNER_11,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_10,\\\n        JNGEN_CHAINING_TRAITS_INNER_9,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_8,\\\n        JNGEN_CHAINING_TRAITS_INNER_7,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_6,\\\n        JNGEN_CHAINING_TRAITS_INNER_5,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_4,\\\n        JNGEN_CHAINING_TRAITS_INNER_3,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_2,\\\n        JNGEN_CHAINING_TRAITS_INNER_1,\\\
    \n        JNGEN_CHAINING_TRAITS_INNER_0)\n\n#define JNGEN_CHAINING_TRAITS(Class,\
    \ ...) \\\n    struct Class { JNGEN_GET_CHAINING_TRAITS_INNER(__VA_ARGS__)(Class,\
    \ __VA_ARGS__) };\n\nnamespace jngen {\n\nstruct Config {\n    bool generateLargeObjects\
    \ = false;\n    bool largeOptionIndices = false;\n    bool normalizeEdges = true;\n\
    };\n\n#ifdef JNGEN_DECLARE_ONLY\nextern\n#endif\nConfig config;\n\n} // namespace\
    \ jngen\n\nusing jngen::config;\n\n\n#include <chrono>\n#include <cstdlib>\n#include\
    \ <iostream>\n#include <map>\n#include <stdexcept>\n#include <string>\n#include\
    \ <type_traits>\n#include <vector>\n\n#ifdef JNGEN_DECLARE_ONLY\n#define JNGEN_EXTERN\
    \ extern\n#else\n#define JNGEN_EXTERN\n#endif\n\nnamespace jngen {\n\nclass Exception\
    \ : public std::runtime_error {\npublic:\n    explicit Exception(const std::string&\
    \ s) :\n        std::runtime_error(\"Assertion `\" + s + \"' failed.\")\n    {\
    \  }\n\n    Exception(const std::string& assertMsg, const std::string& expl) :\n\
    \        std::runtime_error(expl + \" (assertion `\" + assertMsg + \"' failed).\"\
    )\n    {  }\n};\n\nclass InternalException : public Exception {\npublic:\n   \
    \ explicit InternalException(const std::string& s) : Exception(s) {}\n\n    InternalException(const\
    \ std::string& assertMsg, const std::string& expl) :\n        Exception(assertMsg,\
    \ expl)\n    {  }\n};\n\n} // namespace jngen\n\n#define JNGEN_ENSURE1(exType,\
    \ cond)\\\ndo\\\n    if (!(cond)) {\\\n        throw exType(#cond);\\\n    }\\\
    \nwhile (false)\n\n#define JNGEN_ENSURE2(exType, cond, msg)\\\ndo\\\n    if (!(cond))\
    \ {\\\n        throw exType(#cond, msg);\\\n    }\\\nwhile (false)\n\n#define\
    \ JNGEN_GET_MACRO(_1, _2, NAME, ...) NAME\n\n#define ensure(...) JNGEN_GET_MACRO(__VA_ARGS__,\
    \ JNGEN_ENSURE2, JNGEN_ENSURE1)\\\n    (jngen::Exception, __VA_ARGS__)\n#define\
    \ ENSURE(...) JNGEN_GET_MACRO(__VA_ARGS__, JNGEN_ENSURE2, JNGEN_ENSURE1)\\\n \
    \   (jngen::InternalException, __VA_ARGS__)\n\nnamespace jngen {\n\ntemplate<typename\
    \ ... Args>\nstd::string format(const std::string& fmt, Args... args) {\n    constexpr\
    \ static char BUF_SIZE = 64;\n    static char BUFFER[BUF_SIZE];\n\n    int bufSize\
    \ = BUF_SIZE;\n    char *buf = BUFFER;\n\n    while (true) {\n        int ret\
    \ = std::snprintf(buf, bufSize, fmt.c_str(), args...);\n        if (ret < bufSize)\
    \ {\n            break;\n        }\n\n        if (bufSize != BUF_SIZE) {\n   \
    \         delete[] buf;\n        }\n\n        bufSize *= 2;\n        buf = new\
    \ char[bufSize];\n    }\n\n    std::string result(buf);\n\n    if (bufSize !=\
    \ BUF_SIZE) {\n        delete[] buf;\n    }\n\n    return result;\n}\n\nclass\
    \ ContextTimer {\npublic:\n    ContextTimer(const std::string& name) : name_(name)\
    \ {\n        start_ = std::chrono::steady_clock::now();\n    }\n\n    ContextTimer()\
    \ : ContextTimer(\"\") {}\n\n    ContextTimer(const ContextTimer&) = delete;\n\
    \    ContextTimer& operator=(const ContextTimer&) = delete;\n    ContextTimer(ContextTimer&&)\
    \ = delete;\n    ContextTimer& operator=(ContextTimer&&) = delete;\n\n    ~ContextTimer()\
    \ {\n        auto dif = std::chrono::steady_clock::now() - start_;\n        auto\
    \ ms = std::chrono::duration_cast<std::chrono::milliseconds>(dif);\n        if\
    \ (!name_.empty()) {\n            std::cerr << \"[\" << name_ << \"] \";\n   \
    \     }\n        std::cerr << ms.count() << \" ms\\n\";\n    }\n\nprivate:\n \
    \   std::string name_;\n    std::chrono::steady_clock::time_point start_;\n};\n\
    \ntemplate<typename F>\nauto distribution(int n, F&& f) -> std::map<decltype(f()),\
    \ int> {\n    std::map<decltype(f()), int> dist;\n    for (int i = 0; i < n; ++i)\
    \ {\n        ++dist[f()];\n    }\n    return dist;\n}\n\ninline void checkLargeParameter(int\
    \ n) {\n    if (!config.generateLargeObjects) {\n        constexpr static int\
    \ BOUND = 5e6;\n        ensure(\n            n <= BOUND,\n            \"If you\
    \ want to generate an object of size > 5'000'000, please set \"\n            \"\
    'config.generateLargeObjects = true'.\");\n    }\n}\n\n// Some type traits helpers.\
    \ Based on ideas from TCPPPL v4.\ntemplate<bool B, typename T = void>\nusing enable_if_t\
    \ = typename std::enable_if<B, T>::type;\n\ntemplate<typename T>\nusing decay_t\
    \ = typename std::decay<T>::type;\n\nnamespace util {\n\ninline long long gcd(long\
    \ long a, long long b) {\n    if (a < 0) {\n        a = -a;\n    }\n    if (b\
    \ < 0) {\n        b = -b;\n    }\n\n    while (a && b) {\n        if (a > b) {\n\
    \            a %= b;\n        } else {\n            b %= a;\n        }\n    }\n\
    \    return a + b;\n}\n\ninline std::vector<std::string> split(std::string s,\
    \ char delimiter) {\n    auto strip = [](std::string s) {\n        size_t l =\
    \ 0;\n        while (l < s.size() && s[l] == ' ') {\n            ++l;\n      \
    \  }\n        s = s.substr(l);\n        while (!s.empty() && s.back() == ' ')\
    \ {\n            s.pop_back();\n        }\n        return s;\n    };\n\n    std::vector<std::string>\
    \ result;\n    s += delimiter;\n    std::string cur;\n\n    for (char c: s) {\n\
    \        if (c == delimiter) {\n            result.push_back(strip(cur));\n  \
    \          cur.clear();\n        } else {\n            cur += c;\n        }\n\
    \    }\n\n    return result;\n}\n\n} // namespace util\n\n} // namespace jngen\n\
    \nusing jngen::format;\nusing jngen::ContextTimer;\nusing jngen::distribution;\n\
    \n#include <string>\n#include <utility>\n#include <vector>\n#include <string>\n\
    \nnamespace jngen {\nnamespace drawing {\n\nusing Color = std::string;\n\nstruct\
    \ DrawingEngineState {\n    double width;\n    Color stroke;\n    Color fill;\n\
    \    double opacity;\n};\n\nclass DrawingEngine {\npublic:\n    DrawingEngine()\
    \ {}\n    virtual ~DrawingEngine() {}\n\n    virtual void drawPoint(double x,\
    \ double y) = 0;\n    virtual void drawCircle(double x, double y, double r) =\
    \ 0;\n    virtual void drawSegment(double x1, double y1, double x2, double y2)\
    \ = 0;\n    virtual void drawPolygon(\n        const std::vector<std::pair<double,\
    \ double>>& vertices) = 0;\n    virtual void drawText(\n        double x, double\
    \ y, const std::string& s) = 0;\n\n    virtual void setWidth(double width) = 0;\n\
    \    virtual void setStroke(Color color) = 0;\n    virtual void setFill(Color\
    \ color) = 0;\n    virtual void setOpacity(double opacity) = 0;\n\n    virtual\
    \ double width() const = 0;\n    virtual Color stroke() const = 0;\n    virtual\
    \ Color fill() const = 0;\n    virtual double opacity() const = 0;\n\n    DrawingEngineState\
    \ saveState() {\n        return { width(), stroke(), fill(), opacity() };\n  \
    \  }\n\n    void restoreState(const DrawingEngineState& state) {\n        setWidth(state.width);\n\
    \        setStroke(state.stroke);\n        setFill(state.fill);\n        setOpacity(state.opacity);\n\
    \    }\n};\n\n}} // namespace jngen::drawing\n\n\n#include <sstream>\n#include\
    \ <string>\n\nnamespace jngen {\nnamespace drawing {\n\nclass SvgEngine : public\
    \ DrawingEngine {\npublic:\n    SvgEngine(double x1 = 0, double y1 = 0, double\
    \ x2 = 50, double y2 = 50);\n\n    virtual ~SvgEngine() {}\n\n    virtual void\
    \ drawPoint(double x, double y) override;\n    virtual void drawCircle(double\
    \ x, double y, double r) override;\n    virtual void drawSegment(\n        double\
    \ x1, double y1, double x2, double y2) override;\n    virtual void drawPolygon(\n\
    \        const std::vector<std::pair<double, double>>& vertices) override;\n \
    \   virtual void drawText(\n        double x, double y, const std::string& s)\
    \ override;\n\n    virtual void setWidth(double width) override;\n    virtual\
    \ void setStroke(Color color) override;\n    virtual void setFill(Color color)\
    \ override;\n    virtual void setOpacity(double opacity) override;\n\n    virtual\
    \ double width() const override { return width_; }\n    virtual Color stroke()\
    \ const override { return strokeColor_; }\n    virtual Color fill() const override\
    \ { return fillColor_; }\n    virtual double opacity() const override { return\
    \ opacity_; }\n\n    std::string serialize() const;\n\nprivate:\n    double lerpX(double\
    \ x) const;\n    double lerpY(double y) const;\n    double scaleSize(double size)\
    \ const;\n\n    std::string getStyle() const;\n\n    std::ostringstream output_;\n\
    \n    double width_;\n    Color strokeColor_;\n    Color fillColor_;\n    double\
    \ opacity_;\n\n    double x1_, y1_, x2_, y2_; // borders\n};\n\n}} // namespace\
    \ jngen::drawing\n\n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_SVG_ENGINE_INL_H\n\
    #ifndef JNGEN_INCLUDE_SVG_ENGINE_INL_H\n#error File \"svg_engine_inl.h\" must\
    \ not be included directly.\n#endif\n\n#include <cmath>\n#include <cstdlib>\n\n\
    namespace jngen {\nnamespace drawing {\n\nstatic char buf[10000];\nconstexpr static\
    \ double WIDTH_SCALE = 8;\nconstexpr static double CANVAS_SIZE = 2000;\nconstexpr\
    \ static int FONT_SIZE = 64;\n\nnamespace {\n\nconst char* colorToString(const\
    \ Color& color) {\n    const static char* NONE = \"none\";\n    if (color.empty())\
    \ {\n        return NONE;\n    }\n    return color.c_str();\n}\n\n// Given x \\\
    in [l, r], return linear interpolation to [L, R]\ndouble lerp(double x, double\
    \ l, double r, double L, double R) {\n    return L + (R - L) * ((x - l) / (r -\
    \ l));\n}\n\n} // namespace\n\nSvgEngine::SvgEngine(double x1, double y1, double\
    \ x2, double y2) :\n    width_(1.0),\n    opacity_(1.0),\n    x1_(x1),\n    y1_(y1),\n\
    \    x2_(x2),\n    y2_(y2)\n{  }\n\nvoid SvgEngine::drawPoint(double x, double\
    \ y) {\n    x = lerpX(x);\n    y = lerpY(y);\n    double w = width_ * WIDTH_SCALE\
    \ * 1.5;\n    std::sprintf(\n        buf,\n        \"<circle cx='%f' cy='%f' r='%f'\
    \ fill='%s' opacity='%f'/>\",\n        x, y, w, colorToString(strokeColor_), opacity_\n\
    \    );\n    output_ << buf << \"\\n\";\n}\n\nvoid SvgEngine::drawCircle(double\
    \ x, double y, double r) {\n    x = lerpX(x);\n    y = lerpY(y);\n    r = scaleSize(r);\n\
    \    std::sprintf(\n        buf,\n        \"<circle cx='%f' cy='%f' r='%f' style='%s'/>\"\
    ,\n        x, y, r, getStyle().c_str()\n    );\n    output_ << buf << \"\\n\"\
    ;\n}\n\nvoid SvgEngine::drawPolygon(\n    const std::vector<std::pair<double,\
    \ double>>& points)\n{\n    output_ << \"<polygon points='\";\n    for (const\
    \ auto& point: points) {\n        output_ << lerpX(point.first) << \",\" << lerpY(point.second)\
    \ << \" \";\n    }\n    output_ << \"' style='\" << getStyle() << \"'/>\\n\";\n\
    }\n\nvoid SvgEngine::drawSegment(\n        double x1, double y1, double x2, double\
    \ y2)\n{\n    x1 = lerpX(x1);\n    y1 = lerpY(y1);\n    x2 = lerpX(x2);\n    y2\
    \ = lerpY(y2);\n    if (std::fabs(x1 - x2) < 1e-9) {\n        x1 = std::round(x1);\n\
    \        x2 = std::round(x2);\n    }\n    if (std::fabs(y1 - y2) < 1e-9) {\n \
    \       y1 = std::round(y1);\n        y2 = std::round(y2);\n    }\n    std::sprintf(\n\
    \        buf,\n        \"<line x1='%f' y1='%f' x2='%f' y2='%f' style='%s'/>\"\
    ,\n        x1, y1, x2, y2, getStyle().c_str()\n    );\n    output_ << buf << \"\
    \\n\";\n}\n\nvoid SvgEngine::drawText(\n    double x, double y, const std::string&\
    \ s)\n{\n    x = std::round(lerpX(x));\n    y = std::round(lerpY(y));\n    std::sprintf(\n\
    \        buf,\n        \"<text x='%f' y='%f' font-size='%d' font-family='Helvetica'>%s</text>\"\
    ,\n        x, y, FONT_SIZE, s.c_str()\n    );\n    output_ << buf << \"\\n\";\n\
    }\n\nvoid SvgEngine::setWidth(double width) {\n    width_ = width;\n}\n\nvoid\
    \ SvgEngine::setStroke(Color color) {\n    strokeColor_ = color;\n}\n\nvoid SvgEngine::setFill(Color\
    \ color) {\n    fillColor_ = color;\n}\n\nvoid SvgEngine::setOpacity(double opacity)\
    \ {\n    opacity_ = opacity;\n}\n\nstd::string SvgEngine::serialize() const {\n\
    \    int offset = std::sprintf(\n        buf,\n        \"<svg xmlns='http://www.w3.org/2000/svg'\
    \ \"\n        \"viewBox='%f %f %f %f'>\\n\",\n        0.0, 0.0, CANVAS_SIZE, CANVAS_SIZE\
    \ * (y2_ - y1_) / (x2_ - x1_)\n    );\n    std::sprintf(\n        buf + offset,\n\
    \        \"<circle cx='%f' cy='%f' r='%f' fill='white'/>\\n\",\n        CANVAS_SIZE/2,\
    \ CANVAS_SIZE/2,\n        std::hypot(CANVAS_SIZE, CANVAS_SIZE * (y2_ - y1_) /\
    \ (x2_ - x1_))\n    );\n\n    return buf + output_.str() + \"</svg>\\n\";\n}\n\
    \ndouble SvgEngine::lerpX(double x) const {\n    return lerp(x, x1_, x2_, 0.,\
    \ CANVAS_SIZE);\n}\n\ndouble SvgEngine::lerpY(double y) const {\n    return lerp(y,\
    \ y2_, y1_, 0., CANVAS_SIZE * (y2_ - y1_) / (x2_ - x1_));\n}\n\ndouble SvgEngine::scaleSize(double\
    \ size) const {\n    return size * CANVAS_SIZE / (x2_ - x1_);\n}\n\nstd::string\
    \ SvgEngine::getStyle() const {\n    static char buf[1024];\n    std::sprintf(\n\
    \        buf,\n        \"stroke-width:%f;stroke:%s;fill:%s;opacity:%f\",\n   \
    \     width_ * WIDTH_SCALE,\n        colorToString(strokeColor_),\n        colorToString(fillColor_),\n\
    \        opacity_\n    );\n    return buf;\n}\n\n}} // namespace jngen::drawing\n\
    \n#undef JNGEN_INCLUDE_SVG_ENGINE_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#include\
    \ <algorithm>\n#include <cmath>\n#include <fstream>\n#include <functional>\n#include\
    \ <initializer_list>\n#include <map>\n#include <memory>\n#include <stdexcept>\n\
    #include <string>\n#include <utility>\n#include <vector>\n\nnamespace jngen {\n\
    namespace drawing {\n\nclass Drawer {\npublic:\n    Drawer();\n\n    template<typename\
    \ P>\n    void point(const P& p);\n    template<typename T>\n    void point(T\
    \ x, T y);\n\n    template<typename P>\n    void circle(const P& p, double radius);\n\
    \    template<typename T>\n    void circle(T x, T y, double radius);\n\n    template<typename\
    \ P>\n    void segment(const P& p1, const P& p2);\n    template<typename T>\n\
    \    void segment(T x1, T y1, T x2, T y2);\n\n    template<typename P>\n    void\
    \ polygon(const std::vector<P>& points);\n    template<typename P>\n    void polygon(std::initializer_list<P>\
    \ points);\n\n    void setWidth(double width);\n\n    void setColor(const std::string&\
    \ color);\n\n    void setStroke(const std::string& color);\n\n    void setFill(const\
    \ std::string& color);\n\n    void setOpacity(double opacity);\n\n    void enableGrid(bool\
    \ value) {\n        gridEnabled_ = value;\n    }\n\n    void dumpSvg(const std::string&\
    \ filename);\n\nprivate:\n    struct Point {\n        double x, y;\n        Point()\
    \ {}\n        Point(double x, double y) : x(x), y(y) {}\n    };\n\n    template<typename\
    \ T>\n    Point extractCoords(const T& pt) {\n        return Point(pt.x, pt.y);\n\
    \    }\n\n    template<typename T>\n    Point extractCoords(const std::pair<T,\
    \ T>& pt) {\n        return Point(pt.first, pt.second);\n    }\n\n    typedef\
    \ std::function<void(DrawingEngine*)> DrawRequest;\n\n    typedef std::pair<Point,\
    \ Point> Bbox;\n\n    static Bbox emptyBbox();\n\n    static Bbox unite(const\
    \ Bbox& lhs, const Bbox& rhs);\n\n    static Bbox bbox(const Point& p);\n    static\
    \ Bbox bbox(const std::pair<Point, double>& circle);\n\n    Bbox getBbox() const;\n\
    \n    static Bbox viewportByBbox(const Bbox& bbox);\n\n    void drawAll();\n \
    \   void drawGrid(const Bbox& bbox);\n\n    std::vector<DrawRequest> requests_;\n\
    \n    DrawingEngine* engine_;\n    Bbox bbox_;\n    int requestId_ = 0;\n    bool\
    \ gridEnabled_ = true;\n};\n\ntemplate<typename P>\nvoid Drawer::point(const P&\
    \ p_) {\n    Point p = extractCoords(p_);\n    bbox_ = unite(bbox_ , bbox(Point(p.x,\
    \ p.y)));\n    requests_.push_back([p](DrawingEngine* engine) {\n        engine->drawPoint(p.x,\
    \ p.y);\n    });\n}\n\ntemplate<typename T>\nvoid Drawer::point(T x, T y) {\n\
    \    point(Point(x, y));\n}\n\ntemplate<typename P>\nvoid Drawer::circle(const\
    \ P& p_, double radius) {\n    Point p = extractCoords(p_);\n    bbox_ = unite(bbox_\
    \ , bbox({Point(p.x, p.y), radius}));\n    requests_.push_back([p, radius](DrawingEngine*\
    \ engine) {\n        engine->drawCircle(p.x, p.y, radius);\n    });\n}\n\ntemplate<typename\
    \ T>\nvoid Drawer::circle(T x, T y, double radius) {\n    circle(Point(x, y),\
    \ radius);\n}\n\ntemplate<typename P>\nvoid Drawer::segment(const P& p1_, const\
    \ P& p2_) {\n    Point p1 = extractCoords(p1_);\n    Point p2 = extractCoords(p2_);\n\
    \    bbox_ = unite(bbox_ , bbox(Point(p1.x, p1.y)));\n    bbox_ = unite(bbox_\
    \ , bbox(Point(p2.x, p2.y)));\n    requests_.push_back([p1, p2](DrawingEngine*\
    \ engine) {\n        engine->drawSegment(p1.x, p1.y, p2.x, p2.y);\n    });\n}\n\
    \ntemplate<typename T>\nvoid Drawer::segment(T x1, T y1, T x2, T y2) {\n    segment(Point(x1,\
    \ y1), Point(x2, y2));\n}\n\ntemplate<typename P>\nvoid Drawer::polygon(const\
    \ std::vector<P>& points) {\n    for (const auto& p: points) {\n        bbox_\
    \ = unite(bbox_, bbox(extractCoords(p)));\n    }\n\n    requests_.push_back([points,\
    \ this](DrawingEngine* engine) {\n        std::vector<std::pair<double, double>>\
    \ enginePoints;\n        for (const auto& p: points) {\n            Point pt =\
    \ extractCoords(p);\n            enginePoints.emplace_back(pt.x, pt.y);\n    \
    \    }\n        engine->drawPolygon(enginePoints);\n    });\n}\n\ntemplate<typename\
    \ P>\nvoid Drawer::polygon(std::initializer_list<P> points) {\n    polygon(std::vector<P>(points.begin(),\
    \ points.end()));\n}\n\n#ifndef JNGEN_DECLARE_ONLY\n\nDrawer::Drawer() : bbox_(emptyBbox())\
    \ {\n    setFill(\"\");\n    setStroke(\"black\");\n}\n\nvoid Drawer::setWidth(double\
    \ width) {\n    requests_.push_back([width](DrawingEngine* engine) {\n       \
    \ engine->setWidth(width);\n    });\n}\n\nvoid Drawer::setColor(const std::string&\
    \ color) {\n    setStroke(color);\n    setFill(color);\n}\n\nvoid Drawer::setStroke(const\
    \ std::string& color) {\n    requests_.push_back([color](DrawingEngine* engine)\
    \ {\n        engine->setStroke(color);\n    });\n}\n\nvoid Drawer::setFill(const\
    \ std::string& color) {\n    requests_.push_back([color](DrawingEngine* engine)\
    \ {\n        engine->setFill(color);\n    });\n}\n\nvoid Drawer::setOpacity(double\
    \ opacity) {\n    requests_.push_back([opacity](DrawingEngine* engine) {\n   \
    \     engine->setOpacity(opacity);\n    });\n}\n\nDrawer::Bbox Drawer::emptyBbox()\
    \ {\n    const static double inf = 1e18;\n    return { Point{inf, inf}, Point{-inf,\
    \ -inf} };\n}\n\nDrawer::Bbox Drawer::unite(const Bbox& lhs, const Bbox& rhs)\
    \ {\n    return Bbox{\n            Point{\n                std::min(lhs.first.x,\
    \ rhs.first.x),\n                std::min(lhs.first.y, rhs.first.y)},\n      \
    \      Point{\n                std::max(lhs.second.x, rhs.second.x),\n       \
    \         std::max(lhs.second.y, rhs.second.y)}\n    };\n}\n\nDrawer::Bbox Drawer::bbox(const\
    \ Point& p) {\n    return {p, p};\n}\n\nDrawer::Bbox Drawer::bbox(const std::pair<Point,\
    \ double>& circle) {\n    Point p;\n    double radius;\n    std::tie(p, radius)\
    \ = circle;\n    return {\n            Point{p.x - radius, p.y - radius},\n  \
    \          Point{p.x + radius, p.y + radius}\n    };\n}\n\n/*\nGiven a bbox of\
    \ points, returns a bbox with following properties:\n    - at least 5% margin\
    \ at each side is blank\n    - side lengths differ by at most 1.6\n    - side\
    \ length is at least 10\n    - if it is possible to include (0, 0), include it\
    \ explicitly\n */\nDrawer::Bbox Drawer::viewportByBbox(const Bbox& bbox) {\n \
    \   constexpr static double MIN_SIZE = 10.0;\n    constexpr static double MAX_RATIO\
    \ = 1.6;\n    constexpr static double MARGIN_RATIO = 0.05;\n    constexpr static\
    \ double MAX_RELATIVE_DISTANCE_TO_ZERO = 0.2;\n\n    double lx = bbox.first.x;\n\
    \    double rx = bbox.second.x;\n    double ly = bbox.first.y;\n    double ry\
    \ = bbox.second.y;\n\n    auto extendToSize = [&](double& l, double &r, double\
    \ size) {\n        double shift = (size - (r - l)) / 2;\n        l -= shift;\n\
    \        r += shift;\n    };\n\n    auto extendInterval = [&](double& l, double\
    \ &r) {\n        if (r - l < MIN_SIZE) {\n            if (l >= -1e-9 && r < MIN_SIZE)\
    \ {\n                l = 0;\n                r = MIN_SIZE;\n\n            } else\
    \ if (r <= 1e-9 && l >= -MIN_SIZE) {\n                l = -MIN_SIZE;\n       \
    \         r = 0;\n            } else {\n                extendToSize(l, r, MIN_SIZE);\n\
    \            }\n        }\n\n        if ((l > 0 || r < 0) && std::min(std::abs(l),\
    \ std::abs(r)) <=\n                (r - l) * MAX_RELATIVE_DISTANCE_TO_ZERO)\n\
    \        {\n            if (l > 0) {\n                l = 0;\n            } else\
    \ {\n                r = 0;\n            }\n        }\n\n        double margin\
    \ = (r - l) * MARGIN_RATIO;\n        l -= margin;\n        r += margin;\n    };\n\
    \n    extendInterval(lx, rx);\n    extendInterval(ly, ry);\n\n    if ((rx - lx)\
    \ / (ry - ly) > MAX_RATIO) {\n        extendToSize(ly, ry, (rx - lx) / MAX_RATIO);\n\
    \    } else if ((ry - ly) / (rx - lx) > MAX_RATIO) {\n        extendToSize(lx,\
    \ rx, (ry - ly) / MAX_RATIO);\n    }\n\n    return { Point(lx, ly), Point(rx,\
    \ ry) };\n}\n\nvoid Drawer::drawAll() {\n    for (const auto& request: requests_)\
    \ {\n        request(engine_);\n    }\n}\n\nvoid Drawer::drawGrid(const Bbox&\
    \ bbox) {\n    const static std::vector<int> STEP_DELTA = {20, 25, 20};\n    //\
    \ Step goes like 1, 2, 5, 10, 20, 50, 100, ...\n    constexpr static int SMALL_IN_BIG\
    \ = 5;\n    constexpr static int THRESHOLD = 8;\n    constexpr static int MAX_SPREAD_TO_DRAW_ALL_TICKS\
    \ = 13;\n    constexpr static double TEXT_OFFSET_RATIO = 0.01;\n\n    auto savedState\
    \ = engine_->saveState();\n\n    int step = 5;\n    double spread = std::min(\n\
    \        bbox.second.x - bbox.first.x,\n        bbox.second.y - bbox.first.y);\n\
    \    size_t deltaPos = 2;\n    while (spread / step > THRESHOLD) {\n        step\
    \ = step * STEP_DELTA[deltaPos] / 10;\n        if (++deltaPos == STEP_DELTA.size())\
    \ {\n            deltaPos = 0;\n        }\n    }\n\n    engine_->setWidth(0.5);\n\
    \    engine_->setStroke(\"lightgrey\");\n\n    double smallStep = 1.0 * step /\
    \ SMALL_IN_BIG;\n\n    for (\n            double tick = std::ceil(bbox.first.x\
    \ / smallStep) * smallStep;\n            tick < bbox.second.x;\n            tick\
    \ += smallStep)\n    {\n        if (std::lround(tick) % step != 0) {\n       \
    \     engine_->drawSegment(tick, bbox.first.y, tick, bbox.second.y);\n       \
    \ }\n    }\n\n    for (\n            double tick = std::ceil(bbox.first.y / smallStep)\
    \ * smallStep;\n            tick < bbox.second.y;\n            tick += smallStep)\n\
    \    {\n        if (std::lround(tick) % step != 0) {\n            engine_->drawSegment(bbox.first.x,\
    \ tick, bbox.second.x, tick);\n        }\n    }\n\n    engine_->setWidth(0.75);\n\
    \    engine_->setStroke(\"grey\");\n\n    for (\n            double tick = std::ceil(bbox.first.x\
    \ / step) * step;\n            tick < bbox.second.x;\n            tick += step)\n\
    \    {\n        engine_->drawSegment(tick, bbox.first.y, tick, bbox.second.y);\n\
    \    }\n\n    for (\n            double tick = std::ceil(bbox.first.y / step)\
    \ * step;\n            tick < bbox.second.y;\n            tick += step)\n    {\n\
    \        engine_->drawSegment(bbox.first.x, tick, bbox.second.x, tick);\n    }\n\
    \n    const double textOffsetX =\n        (bbox.second.x - bbox.first.x) * TEXT_OFFSET_RATIO;\n\
    \    const double textOffsetY =\n        (bbox.second.y - bbox.first.y) * TEXT_OFFSET_RATIO;\n\
    \n    auto format = [](double x) {\n        static char buf[10];\n        std::sprintf(buf,\
    \ \"%d\", int(std::lround(x)));\n        return std::string(buf);\n    };\n\n\
    \    if (spread < MAX_SPREAD_TO_DRAW_ALL_TICKS) {\n        step = 1;\n    }\n\n\
    \    for (\n            double tick = std::ceil(bbox.first.y / step) * step;\n\
    \            tick < bbox.second.y;\n            tick += step)\n    {\n       \
    \ engine_->drawText(\n            bbox.first.x + textOffsetX, tick + textOffsetX,\
    \ format(tick));\n    }\n\n    for (\n            double tick = std::ceil(bbox.first.x\
    \ / step) * step;\n            tick < bbox.second.x;\n            tick += step)\n\
    \    {\n        engine_->drawText(\n            tick + textOffsetY, bbox.first.y\
    \ + textOffsetY, format(tick));\n    }\n\n\n    if (spread <= MAX_SPREAD_TO_DRAW_ALL_TICKS)\
    \ {\n        step = 1;\n    }\n\n    engine_->restoreState(savedState);\n}\n\n\
    void Drawer::dumpSvg(const std::string& filename) {\n    if (requests_.empty())\
    \ {\n        return;\n    }\n\n    auto bbox = bbox_;\n    auto viewport = viewportByBbox(bbox);\n\
    \    std::unique_ptr<SvgEngine> svgEngine(new SvgEngine(\n        viewport.first.x,\
    \ viewport.first.y,\n        viewport.second.x, viewport.second.y));\n\n    engine_\
    \ = svgEngine.get();\n    if (gridEnabled_) {\n        drawGrid(viewport);\n \
    \   }\n    drawAll();\n\n    std::string svg = svgEngine->serialize();\n\n   \
    \ std::ofstream out(filename);\n    out << svg;\n    out.close();\n}\n\n#endif\
    \ // JNGEN_DECLARE_ONLY\n\n}} // namespace jngen::drawing\n\nusing jngen::drawing::Drawer;\n\
    using jngen::drawing::Color;\n\n#include <algorithm>\n#include <vector>\n\nnamespace\
    \ jngen {\n\nclass Dsu {\npublic:\n    int getRoot(int x);\n\n    bool unite(int\
    \ x, int y);\n\n    bool isConnected() const { return components <= 1; }\n\n \
    \   int numComponents() const { return components; }\n\n    void extend(size_t\
    \ size);\n\nprivate:\n    std::vector<int> parent;\n    std::vector<int> rank;\n\
    \n    int components = 0;\n};\n\n#ifndef JNGEN_DECLARE_ONLY\n\nint Dsu::getRoot(int\
    \ x) {\n    extend(x);\n\n    return parent[x] == x ? x : (parent[x] = getRoot(parent[x]));\n\
    }\n\nbool Dsu::unite(int x, int y) {\n    extend(std::max(x, y) + 1);\n\n    x\
    \ = getRoot(x);\n    y = getRoot(y);\n    if (x == y) {\n        return false;\n\
    \    }\n\n    if (rank[x] > rank[y]) {\n        std::swap(x, y);\n    }\n    if\
    \ (rank[y] == rank[x]) {\n        ++rank[y];\n    }\n    parent[x] = y;\n\n  \
    \  --components;\n\n    return true;\n}\n\nvoid Dsu::extend(size_t x) {\n    size_t\
    \ last = parent.size() - 1;\n    while (parent.size() < x) {\n        ++components;\n\
    \        parent.push_back(++last);\n        rank.push_back(0);\n    }\n}\n\n#endif\
    \ // JNGEN_DECLARE_ONLY\n\n} // namespace jngen\n\n\nnamespace jngen {\nnamespace\
    \ impl {\n\n// Generated with util/generate_prime_rehash_policy.cpp\n// Necessary\
    \ for anti-unordered_set test.\nextern const unsigned int primeList[]\n#ifndef\
    \ JNGEN_DECLARE_ONLY\n= {\n2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67,\n71, 73, 79, 83, 89, 97, 103, 109, 113, 127, 137, 139, 149,\
    \ 157, 167, 179,\n193, 199, 211, 227, 241, 257, 277, 293, 313, 337, 359, 383,\
    \ 409, 439,\n467, 503, 541, 577, 619, 661, 709, 761, 823, 887, 953, 1031, 1109,\
    \ 1193,\n1289, 1381, 1493, 1613, 1741, 1879, 2029, 2179, 2357, 2549, 2753, 2971,\n\
    3209, 3469, 3739, 4027, 4349, 4703, 5087, 5503, 5953, 6427, 6949, 7517,\n8123,\
    \ 8783, 9497, 10273, 11113, 12011, 12983, 14033, 15173, 16411, 17749,\n19183,\
    \ 20753, 22447, 24281, 26267, 28411, 30727, 33223, 35933, 38873,\n42043, 45481,\
    \ 49201, 53201, 57557, 62233, 67307, 72817, 78779, 85229,\n92203, 99733, 107897,\
    \ 116731, 126271, 136607, 147793, 159871, 172933,\n187091, 202409, 218971, 236897,\
    \ 256279, 277261, 299951, 324503, 351061,\n379787, 410857, 444487, 480881, 520241,\
    \ 562841, 608903, 658753, 712697,\n771049, 834181, 902483, 976369, 1056323, 1142821,\
    \ 1236397, 1337629, 1447153,\n1565659, 1693859, 1832561, 1982627, 2144977, 2320627,\
    \ 2510653, 2716249,\n2938679, 3179303, 3439651, 3721303, 4026031, 4355707, 4712381,\
    \ 5098259,\n5515729, 5967347, 6456007, 6984629, 7556579, 8175383, 8844859, 9569143,\n\
    10352717, 11200489\n}\n#endif // JNGEN_DECLARE_ONLY\n;\n\n} // namespace impl\n\
    } // namespace jngen\n\n#include <functional>\n\nnamespace jngen {\n\nclass Graph;\n\
    \nnamespace graph_detail {\n\nclass GraphRandom;\n\nstruct Traits {\n    int n;\n\
    \    int m;\n    bool directed = false;\n    bool acyclic = false;\n    bool allowLoops\
    \ = false;\n    bool allowMulti = false;\n    bool allowAntiparallel = false;\n\
    \    bool connected = false;\n\n    Traits() {}\n    explicit Traits(int n) :\
    \ n(n) {}\n    Traits(int n, int m) : n(n), m(m) {}\n};\n\nclass BuilderProxy\
    \ {\npublic:\n    BuilderProxy(\n            Traits traits,\n            std::function<Graph(Traits)>\
    \ builder) :\n        traits_(traits),\n        builder_(builder)\n    {  }\n\n\
    \    Graph g() const;\n\n    operator Graph() const;\n\n    BuilderProxy& allowLoops(bool\
    \ value = true) {\n        traits_.allowLoops = value;\n        return *this;\n\
    \    }\n\n    BuilderProxy& allowMulti(bool value = true) {\n        traits_.allowMulti\
    \ = value;\n        return *this;\n    }\n\n    BuilderProxy& allowAntiparallel(bool\
    \ value = true) {\n        traits_.allowAntiparallel = value;\n        return\
    \ *this;\n    }\n\n    BuilderProxy& connected(bool value = true) {\n        traits_.connected\
    \ = value;\n        return *this;\n    }\n\n    BuilderProxy& directed(bool value\
    \ = true) {\n        traits_.directed = value;\n        return *this;\n    }\n\
    \n    BuilderProxy& acyclic(bool value = true) {\n        traits_.acyclic = value;\n\
    \        return *this;\n    }\n\nprivate:\n    Traits traits_;\n    std::function<Graph(Traits)>\
    \ builder_;\n};\n\n} // namespace graph_detail\n\n} // namespace jngen\n\n\n#include\
    \ <iterator>\n#include <unordered_set>\n#include <vector>\n#include <type_traits>\n\
    #include <utility>\n\nnamespace jngen {\n\ntemplate<typename T, typename Enable\
    \ = void>\nstruct Hash;\n\nnamespace impl {\n\ninline void hashCombine(uint64_t&\
    \ h, uint64_t k) {\n    const uint64_t m = 0xc6a4a7935bd1e995;\n    const int\
    \ r = 47;\n\n    k *= m;\n    k ^= k >> r;\n    k *= m;\n\n    h ^= k;\n    h\
    \ *= m;\n\n    h += 0xe6546b64;\n}\n\ntemplate<typename Iterator>\nvoid hashCombine(uint64_t&\
    \ h, Iterator begin, Iterator end) {\n    Hash<typename std::iterator_traits<Iterator>::value_type>\
    \ hash;\n    while (begin != end) {\n        hashCombine(h, hash(*begin++));\n\
    \    }\n}\n\n} // namespace impl\n\ntemplate<typename T>\nstruct Hash<\n     \
    \   T,\n        enable_if_t<std::is_integral<T>::value>>\n{\n    uint64_t operator()(const\
    \ T& t) const {\n        uint64_t h = 0;\n        impl::hashCombine(h, t);\n \
    \       return h;\n    }\n};\n\n#define JNGEN_DEFINE_STD_HASH(Type)\\\nnamespace\
    \ std {\\\ntemplate<>\\\nstruct hash<Type> {\\\n    size_t operator()(const Type&\
    \ value) const {\\\n        return jngen::Hash<Type>{}(value);\\\n    }\\\n};\\\
    \n}\n\n#define JNGEN_DEFINE_STD_HASH_TEMPLATE(T, Type)\\\nnamespace std {\\\n\
    template<typename T>\\\nstruct hash<Type> {\\\n    size_t operator()(const Type&\
    \ value) const {\\\n        return jngen::Hash<Type>{}(value);\\\n    }\\\n};\\\
    \n}\n\ntemplate<typename T>\nstruct Hash<std::vector<T>> {\n    uint64_t operator()(const\
    \ std::vector<T>& elements) const {\n        uint64_t h = 0;\n        impl::hashCombine(h,\
    \ elements.size());\n        impl::hashCombine(h, elements.begin(), elements.end());\n\
    \        return h;\n    }\n};\n\ntemplate<typename T, typename U>\nstruct Hash<std::pair<T,\
    \ U>> {\n    uint64_t operator()(const std::pair<T, U>& value) const {\n     \
    \   uint64_t h = 0;\n        impl::hashCombine(h, Hash<T>{}(value.first));\n \
    \       impl::hashCombine(h, Hash<U>{}(value.second));\n        return h;\n  \
    \  }\n};\n\n} // namespace jngen\n\nJNGEN_DEFINE_STD_HASH_TEMPLATE(T, std::vector<T>);\n\
    \nnamespace std {\ntemplate<typename T, typename U>\nstruct hash<std::pair<T,\
    \ U>> {\n    size_t operator()(const std::pair<T, U>& value) const {\n       \
    \ return jngen::Hash<std::pair<T, U>>{}(value);\n    }\n};\n} // namespace std\n\
    \n\n#include <algorithm>\n#include <cctype>\n#include <functional>\n#include <set>\n\
    #include <string>\n#include <utility>\n#include <vector>\n\n// TODO: adequate\
    \ error messages\n\nnamespace jngen {\n\nclass Pattern {\n    friend class Parser;\n\
    public:\n    Pattern() : isOrPattern(false), min(1), max(1) {}\n    Pattern(const\
    \ std::string& s);\n\n    std::string next(std::function<int(int)>&& rnd) const;\n\
    \nprivate:\n    Pattern(Pattern p, std::pair<int, int> quantity);\n\n    Pattern(std::vector<char>\
    \ chars, std::pair<int, int> quantity);\n\n    std::vector<char> chars;\n    std::vector<Pattern>\
    \ children;\n    bool isOrPattern;\n    int min;\n    int max;\n\n    static std::map<std::string,\
    \ Pattern> cachedPatterns_;\n};\n\nclass Parser {\npublic:\n    Pattern parse(const\
    \ std::string& s) {\n        this->s = s;\n        pos = 0;\n        return parsePattern();\n\
    \    }\n\nprivate:\n    static bool isControl(char c);\n\n    static int control(int\
    \ c);\n\n    int next();\n\n    int peek() const;\n\n    int peekAndMove(size_t&\
    \ newPos) const;\n\n    // TODO: catch overflows\n    int readInt();\n\n    std::pair<int,\
    \ int> parseRange();\n\n    std::pair<int, int> tryParseQuantity();\n\n    std::vector<char>\
    \ parseBlock();\n\n    Pattern parsePattern();\n\n    std::string s;\n    size_t\
    \ pos;\n};\n\n} // namespace jngen\n\n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_PATTERN_INL_H\n\
    #ifndef JNGEN_INCLUDE_PATTERN_INL_H\n#error File \"pattern_inl.h\" must not be\
    \ included directly.\n#endif\n\nnamespace jngen {\n\nPattern::Pattern(const std::string&\
    \ s) {\n    auto iter = cachedPatterns_.find(s);\n    if (iter != cachedPatterns_.end())\
    \ {\n        *this = iter->second;\n        return;\n    }\n    *this = Parser().parse(s);\n\
    \    cachedPatterns_[s] = *this;\n}\n\nPattern::Pattern(Pattern p, std::pair<int,\
    \ int> quantity) :\n    isOrPattern(false),\n    min(quantity.first),\n    max(quantity.second)\n\
    {\n    children.push_back(std::move(p));\n}\n\nPattern::Pattern(std::vector<char>\
    \ chars, std::pair<int, int> quantity) :\n    chars(std::move(chars)),\n    isOrPattern(false),\n\
    \    min(quantity.first),\n    max(quantity.second)\n{  }\n\nstd::map<std::string,\
    \ Pattern> Pattern::cachedPatterns_;\n\nstd::string Pattern::next(std::function<int(int)>&&\
    \ rnd) const {\n    if (isOrPattern) {\n        ENSURE(!children.empty());\n \
    \       return children[rnd(children.size())].next(std::move(rnd));\n    }\n\n\
    \    ENSURE( (!!chars.empty()) ^ (!!children.empty()) );\n\n    int count;\n \
    \   if (min == max) {\n        count = min;\n    } else {\n        count = min\
    \ + rnd(max - min + 1);\n    }\n\n    std::string result;\n    for (int i = 0;\
    \ i < count; ++i) {\n        if (!children.empty()) {\n            for (const\
    \ Pattern& p: children) {\n                result += p.next(std::move(rnd));\n\
    \            }\n        } else {\n            result += chars[rnd(chars.size())];\n\
    \        }\n    }\n\n    return result;\n}\n\nbool Parser::isControl(char c) {\n\
    \    static const std::string CONTROL_CHARS = \"()[]{}|?\";\n    return CONTROL_CHARS.find(c)\
    \ != std::string::npos;\n}\n\nint Parser::control(int c) {\n    return c >> 8;\n\
    }\n\nint Parser::next() {\n    size_t newPos;\n    int result = peekAndMove(newPos);\n\
    \    pos = newPos;\n    return result;\n}\n\nint Parser::peek() const {\n    size_t\
    \ dummy;\n    return peekAndMove(dummy);\n}\n\nint Parser::peekAndMove(size_t&\
    \ newPos) const {\n    newPos = pos;\n    if (pos == s.size()) {\n        return\
    \ -1;\n    }\n    if (s[pos] == '\\\\') {\n        ensure(\n            pos+1\
    \ < s.size(),\n            \"Backslash at the end of the pattern is illegal\"\
    );\n        newPos += 2;\n        return s[pos+1];\n    }\n\n    ++newPos;\n \
    \   int ret = s[pos];\n    return isControl(ret) ? (ret << 8) : ret;\n}\n\n//\
    \ TODO: catch overflows\nint Parser::readInt() {\n    ENSURE(std::isdigit(peek()));\n\
    \n    int res = 0;\n    while (std::isdigit(peek())) {\n        res = res * 10\
    \ + next() - '0';\n    }\n    return res;\n}\n\nstd::pair<int, int> Parser::parseRange()\
    \ {\n    ENSURE(control(next()) == '{');\n\n    int from = readInt();\n\n    int\
    \ nxt = next();\n    if (control(nxt) == '}') {\n        return {from, from};\n\
    \    } else if (nxt == ',' || nxt == '-') {\n        int to = readInt();\n   \
    \     ENSURE(control(next()) == '}');\n        return {from, to};\n    } else\
    \ {\n        ensure(false, \"cannot parse character range\");\n    }\n}\n\nstd::pair<int,\
    \ int> Parser::tryParseQuantity() {\n    std::pair<int, int> quantity = {1, 1};\n\
    \n    int qchar = peek();\n    if (control(qchar) == '?') {\n        quantity\
    \ = {0, 1};\n        next();\n    } else if (control(qchar) == '{') {\n      \
    \  quantity = parseRange();\n    }\n\n    return quantity;\n}\n\nstd::vector<char>\
    \ Parser::parseBlock() {\n    std::vector<char> allowed;\n    char last = -1;\n\
    \    bool inRange = false;\n    while (control(peek()) != ']') {\n        char\
    \ c = next(); // buggy on cases like [a-}]\n        ENSURE(c != -1);\n\n     \
    \   if (c == '-') {\n            ensure(!inRange, \"invalid pattern\");\n    \
    \        inRange = true;\n        } else if (inRange) {\n            ensure(c\
    \ >= last, \"invalid pattern\");\n            for (char i = last; i <= c; ++i)\
    \ {\n                allowed.push_back(i);\n            }\n            inRange\
    \ = false;\n            last = -1;\n        } else {\n            if (last !=\
    \ -1) {\n                allowed.push_back(last);\n            }\n           \
    \ last = c;\n        }\n    }\n\n    ENSURE(control(next()) == ']');\n\n    ENSURE(!inRange);\n\
    \    if (last != -1) {\n        allowed.push_back(last);\n    }\n\n    std::sort(allowed.begin(),\
    \ allowed.end());\n    return allowed;\n}\n\nPattern Parser::parsePattern() {\n\
    \    std::vector<Pattern> orPatterns;\n    Pattern cur;\n\n    while (true) {\n\
    \        int nxt = next();\n        if (nxt == -1 || control(nxt) == ')') {\n\
    \            break;\n        } else if (control(nxt) == '(') {\n            Pattern\
    \ p = parsePattern();\n            cur.children.push_back(Pattern(p, tryParseQuantity()));\n\
    \        } else if (control(nxt) == '|') {\n            orPatterns.emplace_back();\n\
    \            std::swap(orPatterns.back(), cur);\n        } else {\n          \
    \  std::vector<char> chars;\n            if (control(nxt) == '[') {\n        \
    \        chars = parseBlock();\n            } else {\n                ENSURE(!control(nxt));\n\
    \                chars = {static_cast<char>(nxt)};\n            }\n\n        \
    \    cur.children.push_back(Pattern(chars, tryParseQuantity()));\n        }\n\
    \    }\n\n    if (orPatterns.empty()) {\n        return cur;\n    } else {\n \
    \       orPatterns.emplace_back();\n        std::swap(orPatterns.back(), cur);\n\
    \n        Pattern p;\n        p.isOrPattern = true;\n        p.children = orPatterns;\n\
    \        return p;\n    }\n}\n\n} // namespace jngen\n#undef JNGEN_INCLUDE_PATTERN_INL_H\n\
    #endif // JNGEN_DECLARE_ONLY\n\nusing jngen::Pattern;\n\n\n#include <algorithm>\n\
    #include <cmath>\n#include <cstdlib>\n#include <iterator>\n#include <limits>\n\
    #include <random>\n#include <string>\n#include <type_traits>\n#include <utility>\n\
    #include <vector>\n\nnamespace jngen {\n\nvoid assertRandomEngineConsistency();\n\
    void assertIntegerSizes();\nvoid registerGen(int argc, char *argv[], int version\
    \ = 1);\n\nclass Random;\n\nclass BaseTypedRandom {\npublic:\n    BaseTypedRandom(Random&\
    \ random) : random(random) {}\n\nprotected:\n    Random& random;\n};\n\ntemplate<typename\
    \ T>\nstruct TypedRandom;\n\nuint64_t maskForBound(uint64_t bound);\n\ntemplate<typename\
    \ Result, typename Source>\nResult uniformRandom(Result bound, Random& random,\
    \ Source (Random::*method)()) {\n    static_assert(sizeof(Result) <= sizeof(Source),\n\
    \        \"uniformRandom: Source type must be at least as large as Result type\"\
    );\n#ifdef JNGEN_FAST_RANDOM\n    return (random.*method)() % bound;\n#else\n\
    \    Source mask = maskForBound(bound);\n    while (true) {\n        Source outcome\
    \ = (random.*method)() & mask;\n        if (outcome < static_cast<Source>(bound))\
    \ {\n            return outcome;\n        }\n    }\n#endif\n}\n\nclass Random\
    \ {\npublic:\n    Random() {\n        assertRandomEngineConsistency();\n     \
    \   assertIntegerSizes();\n        std::vector<uint32_t> seedSeq;\n        //\
    \ 4 random_device calls is enough for everyone\n        std::random_device rd;\n\
    \        for (size_t i = 0; i < 4; ++i) {\n            seedSeq.push_back(rd());\n\
    \        }\n        seed(seedSeq);\n\n    }\n\n    void seed(uint32_t val);\n\
    \    void seed(const std::vector<uint32_t>& seed);\n\n    uint32_t next();\n \
    \   uint64_t next64();\n    double nextf();\n\n    int next(int n);\n    long\
    \ long next(long long n);\n    size_t next(size_t n);\n    double next(double\
    \ n);\n\n    int next(int l, int r);\n    long long next(long long l, long long\
    \ r);\n    size_t next(size_t l, size_t r);\n    double next(double l, double\
    \ r);\n\n    int wnext(int n, int w);\n    long long wnext(long long n, int w);\n\
    \    size_t wnext(size_t n, int w);\n    double wnext(double n, int w);\n\n  \
    \  int wnext(int l, int r, int w);\n    long long wnext(long long l, long long\
    \ r, int w);\n    size_t wnext(size_t l, size_t r, int w);\n    double wnext(double\
    \ l, double r, int w);\n\n    std::string next(const std::string& pattern);\n\n\
    \    template<typename ... Args>\n    std::string next(const std::string& pattern,\
    \ Args... args) {\n        return next(format(pattern, args...));\n    }\n\n \
    \   template<typename T, typename ... Args>\n    T tnext(Args... args) {\n   \
    \     return TypedRandom<T>{*this}.next(args...);\n    }\n\n    template<typename\
    \ ... Args>\n    std::pair<int, int> nextp(Args... args) {\n        return tnext<std::pair<int,\
    \ int>>(args...);\n    }\n\n    template<typename Iterator>\n    auto choice(Iterator\
    \ begin, Iterator end)\n            -> typename std::iterator_traits<Iterator>::value_type\n\
    \    {\n        auto length = std::distance(begin, end);\n        ensure(length\
    \ > 0, \"Cannot select from a range of negative length\");\n        size_t index\
    \ = tnext<size_t>(length);\n        std::advance(begin, index);\n        return\
    \ *begin;\n    }\n\n    template<typename Container>\n    typename Container::value_type\
    \ choice(const Container& container) {\n        ensure(!container.empty(), \"\
    Cannot select from an empty container\");\n        return choice(container.begin(),\
    \ container.end());\n    }\n\n    template<typename T>\n    T choice(const std::initializer_list<T>&\
    \ ilist) {\n        return choice(ilist.begin(), ilist.end());\n    }\n\n    template<typename\
    \ Numeric>\n    size_t nextByDistribution(const std::vector<Numeric>& distribution)\
    \ {\n        ensure(!distribution.empty(), \"Cannot sample by empty distribution\"\
    );\n        Numeric sum = std::accumulate(\n                distribution.begin(),\
    \ distribution.end(), Numeric(0));\n        auto x = next(sum);\n        for (size_t\
    \ i = 0; i < distribution.size(); ++i) {\n            if (x < distribution[i])\
    \ {\n                return i;\n            }\n            x -= distribution[i];\n\
    \        }\n        return distribution.size() - 1;\n    }\n\n    template<typename\
    \ Numeric>\n    size_t nextByDistribution(const std::initializer_list<Numeric>&\
    \ ilist) {\n        // TODO: looks suboptimal\n        return nextByDistribution(std::vector<Numeric>(ilist));\n\
    \    }\n\nprivate:\n    template<typename T, typename ...Args>\n    T smallWnext(int\
    \ w, Args... args) {\n        ENSURE(std::abs(w) <= WNEXT_LIMIT);\n        T result\
    \ = next(args...);\n        while (w > 0) {\n            result = std::max(result,\
    \ next(args...));\n            --w;\n        }\n        while (w < 0) {\n    \
    \        result = std::min(result, next(args...));\n            ++w;\n       \
    \ }\n        return result;\n    }\n\n    double realWnext(int w) {\n        if\
    \ (w == 0) {\n            return nextf();\n        } else if (w > 0) {\n     \
    \       return std::pow(nextf(), 1.0 / (w + 1));\n        } else {\n         \
    \   return 1.0 - std::pow(nextf(), 1.0 / (-w + 1));\n        }\n    }\n\n    std::mt19937\
    \ randomEngine_;\n    constexpr static int WNEXT_LIMIT = 8;\n};\n\nJNGEN_EXTERN\
    \ Random rnd;\n\ntemplate<>\nstruct TypedRandom<int> : public BaseTypedRandom\
    \ {\n    using BaseTypedRandom::BaseTypedRandom;\n    int next(int n) { return\
    \ random.next(n); }\n    int next(int l, int r) { return random.next(l, r); }\n\
    };\n\ntemplate<>\nstruct TypedRandom<double> : public BaseTypedRandom {\n    using\
    \ BaseTypedRandom::BaseTypedRandom;\n    double next(double n) { return random.next(n);\
    \ }\n    double next(double l, double r) { return random.next(l, r); }\n};\n\n\
    template<>\nstruct TypedRandom<long double> : public BaseTypedRandom {\n    using\
    \ BaseTypedRandom::BaseTypedRandom;\n    double next(double n) { return random.next(n);\
    \ }\n    double next(double l, double r) { return random.next(l, r); }\n};\n\n\
    template<>\nstruct TypedRandom<long long> : public BaseTypedRandom {\n    using\
    \ BaseTypedRandom::BaseTypedRandom;\n    long long next(long long n) { return\
    \ random.next(n); }\n    long long next(long long l, long long r) { return random.next(l,\
    \ r); }\n};\n\ntemplate<>\nstruct TypedRandom<size_t> : public BaseTypedRandom\
    \ {\n    using BaseTypedRandom::BaseTypedRandom;\n    size_t next(size_t n) {\
    \ return random.next(n); }\n    size_t next(size_t l, size_t r) { return random.next(l,\
    \ r); }\n};\n\ntemplate<>\nstruct TypedRandom<char> : public BaseTypedRandom {\n\
    \    using BaseTypedRandom::BaseTypedRandom;\n    char next(char n) { return random.next(n);\
    \ }\n    char next(char l, char r) { return random.next(l, r); }\n};\n\ntemplate<typename\
    \ T>\nstruct TypedRandom : public BaseTypedRandom {\n    using BaseTypedRandom::BaseTypedRandom;\n\
    \    template<typename ... Args>\n    T next(Args... args) { return random.next(args...);\
    \ }\n};\n\nstruct RandomPairTraits {\n    const bool ordered;\n    const bool\
    \ distinct;\n};\n\n#ifdef JNGEN_DECLARE_ONLY\nextern RandomPairTraits opair, dpair,\
    \ odpair, dopair;\n#else\nRandomPairTraits opair{true, false};\nRandomPairTraits\
    \ dpair{false, true};\nRandomPairTraits odpair{true, true};\nRandomPairTraits\
    \ dopair{true, true};\n#endif\n\ntemplate<>\nstruct TypedRandom<std::pair<int,\
    \ int>> : public BaseTypedRandom {\n    using BaseTypedRandom::BaseTypedRandom;\n\
    \n    std::pair<int, int> next(int n) {\n        return next(n, {false, false});\n\
    \    }\n    std::pair<int, int> next(int l, int r) {\n        return next(l, r,\
    \ {false, false});\n    }\n\n    std::pair<int, int> next(int n, RandomPairTraits\
    \ traits) {\n        int first = rnd.next(n);\n        int second;\n        do\
    \ {\n            second = rnd.next(n);\n        } while (traits.distinct && first\
    \ == second);\n        if (traits.ordered && first > second) {\n            std::swap(first,\
    \ second);\n        }\n        return {first, second};\n    }\n    std::pair<int,\
    \ int> next(int l, int r, RandomPairTraits traits) {\n        auto res = next(r-l+1,\
    \ traits);\n        res.first += l;\n        res.second += l;\n        return\
    \ res;\n    }\n\nprivate:\n    std::pair<int, int> ordered(std::pair<int, int>\
    \ pair) const {\n        if (pair.first > pair.second) {\n            std::swap(pair.first,\
    \ pair.second);\n        }\n        return pair;\n    }\n};\n\n} // namespace\
    \ jngen\n\nusing jngen::Random;\n\nusing jngen::rnd;\nusing jngen::opair;\nusing\
    \ jngen::dpair;\nusing jngen::dopair;\nusing jngen::odpair;\n\nusing jngen::registerGen;\n\
    \n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_RANDOM_INL_H\n#ifndef JNGEN_INCLUDE_RANDOM_INL_H\n\
    #error File \"random_inl.h\" must not be included directly.\n#endif\n\nnamespace\
    \ jngen {\n\nvoid assertRandomEngineConsistency() {\n    std::mt19937 engine(1234);\n\
    \    ENSURE(engine() == 822569775,\n        \"std::mt19937 doesn't conform to\
    \ the C++ standard\");\n    ENSURE(engine() == 2137449171,\n        \"std::mt19937\
    \ doesn't conform to the C++ standard\");\n    ENSURE(engine() == 2671936806,\n\
    \        \"std::mt19937 doesn't conform to the C++ standard\");\n}\n\nvoid assertIntegerSizes()\
    \ {\n    static_assert(\n        std::numeric_limits<unsigned char>::max() ==\
    \ 255,\n        \"max(unsigned char) != 255\");\n    static_assert(sizeof(int)\
    \ == 4, \"sizeof(int) != 4\");\n    static_assert(sizeof(long long) == 8, \"sizeof(long\
    \ long) != 8\");\n    static_assert(\n        sizeof(size_t) == 4 || sizeof(size_t)\
    \ == 8,\n        \"sizeof(size_t) is neither 4 nor 8\");\n    static_assert(\n\
    \        sizeof(std::size_t) == sizeof(size_t),\n        \"sizeof(size_t) != sizeof(std::size_t)\"\
    );\n}\n\nvoid registerGen(int argc, char *argv[], int version) {\n    (void)version;\
    \ // unused, only for testlib.h compatibility\n\n    std::vector<uint32_t> seed;\n\
    \    for (int i = 1; i < argc; ++i) {\n        int startPosition = seed.size();\n\
    \        seed.emplace_back();\n        for (char *s = argv[i]; *s; ++s) {\n  \
    \          ++seed[startPosition];\n            seed.push_back(*s);\n        }\n\
    \    }\n    rnd.seed(seed);\n}\n\nuint64_t maskForBound(uint64_t bound) {\n  \
    \  --bound;\n    uint64_t mask = ~0;\n    if ((mask >> 32) >= bound) mask >>=\
    \ 32;\n    if ((mask >> 16) >= bound) mask >>= 16;\n    if ((mask >> 8 ) >= bound)\
    \ mask >>= 8 ;\n    if ((mask >> 4 ) >= bound) mask >>= 4 ;\n    if ((mask >>\
    \ 2 ) >= bound) mask >>= 2 ;\n    if ((mask >> 1 ) >= bound) mask >>= 1 ;\n  \
    \  return mask;\n}\n\nvoid Random::seed(uint32_t val) {\n    randomEngine_.seed(val);\n\
    }\n\nvoid Random::seed(const std::vector<uint32_t>& seed) {\n    std::seed_seq\
    \ seq(seed.begin(), seed.end());\n    randomEngine_.seed(seq);\n}\n\nuint32_t\
    \ Random::next() {\n    return randomEngine_();\n}\n\nuint64_t Random::next64()\
    \ {\n    uint64_t a = next();\n    uint64_t b = next();\n    return (a << 32)\
    \ ^ b;\n}\n\ndouble Random::nextf() {\n    return (double)randomEngine_() / randomEngine_.max();\n\
    }\n\nint Random::next(int n) {\n    ensure(n > 0);\n    return uniformRandom(n,\
    \ *this, (uint32_t (Random::*)())&Random::next);\n}\n\nlong long Random::next(long\
    \ long n) {\n    ensure(n > 0);\n    return uniformRandom(n, *this, &Random::next64);\n\
    }\n\nsize_t Random::next(size_t n) {\n    ensure(n > 0);\n    return uniformRandom(n,\
    \ *this, &Random::next64);\n}\n\ndouble Random::next(double n) {\n    ensure(n\
    \ >= 0);\n    return nextf() * n;\n}\n\nint Random::next(int l, int r) {\n   \
    \ ensure(l <= r);\n    uint32_t n = static_cast<uint32_t>(r) - l + 1;\n    return\
    \ l + uniformRandom(\n        n, *this, (uint32_t (Random::*)())&Random::next);\n\
    }\n\nlong long Random::next(long long l, long long r) {\n    ensure(l <= r);\n\
    \    uint64_t n = static_cast<uint64_t>(r) - l + 1;\n    return l + uniformRandom(n,\
    \ *this, &Random::next64);\n}\n\nsize_t Random::next(size_t l, size_t r) {\n \
    \   ensure(l <= r);\n    uint64_t n = static_cast<uint64_t>(r) - l + 1;\n    return\
    \ l + uniformRandom(n, *this, &Random::next64);\n}\n\ndouble Random::next(double\
    \ l, double r) {\n    ensure(l <= r);\n    return l + next(r-l);\n}\n\nint Random::wnext(int\
    \ n, int w) {\n    ensure(n > 0);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n   \
    \     return smallWnext<int>(w, n);\n    } else {\n        double t = realWnext(w);\n\
    \        return n * t;\n    }\n}\n\nlong long Random::wnext(long long n, int w)\
    \ {\n    ensure(n > 0);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n        return\
    \ smallWnext<long long>(w, n);\n    } else {\n        return n * realWnext(w);\n\
    \    }\n}\n\nsize_t Random::wnext(size_t n, int w) {\n    ensure(n > 0);\n   \
    \ if (std::abs(w) <= WNEXT_LIMIT) {\n        return smallWnext<size_t>(w, n);\n\
    \    } else {\n        return n * realWnext(w);\n    }\n}\n\ndouble Random::wnext(double\
    \ n, int w) {\n    ensure(n >= 0);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n  \
    \      return smallWnext<double>(w, n);\n    } else {\n        return realWnext(w)\
    \ * n;\n    }\n}\n\nint Random::wnext(int l, int r, int w) {\n    ensure(l <=\
    \ r);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n        return smallWnext<int>(w,\
    \ l, r);\n    } else {\n        uint32_t n = static_cast<uint32_t>(r) - l + 1;\n\
    \        return l + static_cast<uint32_t>(n * realWnext(w));\n    }\n}\n\nlong\
    \ long Random::wnext(long long l, long long r, int w) {\n    ensure(l <= r);\n\
    \    if (std::abs(w) <= WNEXT_LIMIT) {\n        return smallWnext<long long>(w,\
    \ l, r);\n    } else {\n        uint64_t n = static_cast<uint64_t>(r) - l + 1;\n\
    \        return l + static_cast<uint64_t>(n * realWnext(w));\n    }\n}\n\nsize_t\
    \ Random::wnext(size_t l, size_t r, int w) {\n    ensure(l <= r);\n    if (std::abs(w)\
    \ <= WNEXT_LIMIT) {\n        return smallWnext<size_t>(w, l, r);\n    } else {\n\
    \        uint64_t n = static_cast<uint64_t>(r) - l + 1;\n        return l + static_cast<uint64_t>(n\
    \ * realWnext(w));\n    }\n}\n\ndouble Random::wnext(double l, double r, int w)\
    \ {\n    ensure(l <= r);\n    if (std::abs(w) <= WNEXT_LIMIT) {\n        return\
    \ smallWnext<double>(w, l, r);\n    } else {\n        return realWnext(w) * (r\
    \ - l) + l;\n    }\n}\n\nstd::string Random::next(const std::string& pattern)\
    \ {\n    return Pattern(pattern).next([this](int n) { return next(n); });\n}\n\
    \n} // namespace jngen\n#undef JNGEN_INCLUDE_RANDOM_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\
    \n\n#include <iterator>\n#include <sstream>\n#include <string>\n\nnamespace jngen\
    \ {\nnamespace options {\n\nstruct Range {\n    int first;\n    int last;\n  \
    \  int step;\n\n    Range(int first, int last, int step = 1) :\n        first(first),\n\
    \        last(last),\n        step(step)\n    {\n        ensure(first <= last);\n\
    \        ensure(step > 0);\n    }\n\n    class iterator {\n    public:\n     \
    \   using iterator_category = std::forward_iterator_tag;\n        using value_type\
    \ = int;\n        using reference = const int&;\n        using pointer = const\
    \ int*;\n        using difference_type = int;\n\n        iterator(int value, int\
    \ step, int last) :\n            value_(value),\n            step_(step),\n  \
    \          last_(last)\n        {  }\n\n        iterator& operator++() {\n   \
    \         ensure(value_ <= last_, \"Cannot increment past-the-end iterator\");\n\
    \            value_ += step_;\n            return *this;\n        }\n\n      \
    \  iterator operator++(int) {\n            iterator copy = *this;\n          \
    \  ++*this;\n            return copy;\n        }\n\n        int operator*() const\
    \ {\n            ensure(value_ <= last_, \"Cannot dereference past-the-end iterator\"\
    );\n            return value_;\n        }\n\n        bool operator==(const iterator&\
    \ other) const {\n            if (value_ <= last_) {\n                return value_\
    \ == other.value_;\n            }\n            return other.value_ > last_;\n\
    \        }\n\n        bool operator!=(const iterator& other) const {\n       \
    \     return !(*this == other);\n        }\n\n    private:\n        int value_;\n\
    \        int step_;\n        int last_;\n    };\n\n    iterator begin() const\
    \ {\n        return { first, step, last };\n    }\n\n    iterator end() const\
    \ {\n        return { last + 1, step, last };\n    }\n\n    static Range fromString(std::string\
    \ s) {\n        for (char& c: s) {\n            ensure(c != ' ', \"No spaces allowed\
    \ in range description\");\n            if (c == ':') {\n                c = '\
    \ ';\n            }\n        }\n\n        std::istringstream ss(s);\n        int\
    \ first = 1;\n        int last = std::numeric_limits<int>::max() - 1;\n      \
    \  int step = 1;\n        if (!(ss >> first)) {\n            ensure(false, \"\
    Failed to parse range\");\n        }\n        if (!(ss >> last)) {\n         \
    \   return Range(first, last, step);\n        }\n        if (!(ss >> step)) {\n\
    \            return Range(first, last, step);\n        }\n        return Range(first,\
    \ last, step);\n    }\n};\n\n} // namespace options\n} // namespace jngen\n\n\n\
    #include <map>\n#include <sstream>\n#include <string>\n#include <vector>\n\nnamespace\
    \ jngen {\n\nnamespace detail {\n\ntemplate<typename T>\nconstexpr bool isValidOptionType()\
    \ {\n    return std::is_same<T, std::string>::value ||\n        (std::is_arithmetic<T>::value\
    \ && !std::is_same<T, char>::value);\n}\n\ntemplate<typename T>\nusing StringIfCharPtrElseT\
    \ = typename std::conditional<\n    std::is_same<typename std::decay<T>::type,\
    \ const char*>::value ||\n        std::is_same<typename std::decay<T>::type, char*>::value,\n\
    \    std::string,\n    T>::type;\n\n} // namespace detail\n\nstruct Index {\n\
    \    size_t index;\n    std::string name;\n\n    Index(size_t index) : index(index)\
    \ {\n        if (!config.largeOptionIndices) {\n            ensure(\n        \
    \        index < 32,\n                \"Looks like you called getOpt('c'). Consider\
    \ using \"\n                \"getOpt(\\\"c\\\") or set 'config.largeOptionIndices\
    \ = true' \"\n                \"if you indeed have more than 32 options.\");\n\
    \        }\n    }\n\n    Index(const std::string& name) : name(name) {\n     \
    \   ensure(!name.empty(), \"Variable name cannot be empty\");\n    }\n\n    bool\
    \ isNamed() const {\n        return !name.empty();\n    }\n};\n\nstruct VariableMap\
    \ {\n    std::vector<std::string> positional;\n    std::map<std::string, std::string>\
    \ named;\n\n    int count(size_t pos) const {\n        return pos < positional.size();\n\
    \    }\n\n    int count(const std::string& name) const {\n        return named.count(name);\n\
    \    }\n\n    std::string operator[](size_t pos) const {\n        if (!count(pos))\
    \ {\n            return \"\";\n        }\n        return positional.at(pos);\n\
    \    }\n\n    std::string operator[](const std::string& name) const {\n      \
    \  if (!count(name)) {\n            return \"\";\n        }\n        return named.at(name);\n\
    \    }\n\n    int count(const Index& index) const {\n        if (index.isNamed())\
    \ {\n            return count(index.name);\n        } else {\n            return\
    \ count(index.index);\n        }\n    }\n\n    std::string operator[](const Index&\
    \ index) const {\n        if (index.isNamed()) {\n            return (*this)[index.name];\n\
    \        } else {\n            return (*this)[index.index];\n        }\n    }\n\
    \n    void assertExistence(const Index& index) const {\n        if (count(index))\
    \ {\n            return;\n        }\n        if (index.isNamed()) {\n        \
    \    ensure(false, format(\n                    \"There is no variable with name\
    \ '%s'\", index.name.c_str()));\n        } else {\n            ensure(false, format(\n\
    \                    \"There is no variable with index %d\", index.index));\n\
    \        }\n    }\n\n    bool initialized = false;\n};\n\ntemplate<typename T>\n\
    class PendingVariable {\npublic:\n    explicit PendingVariable(std::string value)\
    \ :\n        value_(std::move(value))\n    {  }\n\n    PendingVariable(std::string\
    \ value, T defaultValue) :\n        value_(std::move(value)),\n        default_(std::move(defaultValue))\n\
    \    {  }\n\n    explicit PendingVariable(std::nullptr_t, T defaultValue) :\n\
    \        valid_(false),\n        default_(std::move(defaultValue))\n    {  }\n\
    \n    // We need this check in order to make the following work:\n    // string\
    \ s = getOpt(0);\n    // s = getOpt(0);\n    // Weird things happen if we allow\
    \ all kind of casts. See\n    // https://stackoverflow.com/questions/46740341\n\
    \    template<\n        typename U,\n        typename std::enable_if<\n      \
    \      detail::isValidOptionType<U>()>::type* = nullptr>\n    operator U() const\n\
    \    {\n        if (!valid_) {\n            return static_cast<U>(default_);\n\
    \        }\n\n        std::istringstream ss(value_);\n        U t;\n        if\
    \ (ss >> t) {\n            return t;\n        } else {\n            ensure(\n\
    \                false,\n                format(\n                    \"Cannot\
    \ parse option. Raw value: '%s'\",\n                    value_.c_str()));\n  \
    \      }\n    }\n\n    // TODO: getOpt operators, like getOpt(\"n\") == 100\n\n\
    private:\n    bool valid_ = true;\n    std::string value_;\n    T default_;\n\
    };\n\ntemplate<>\nclass PendingVariable<void> {\npublic:\n    explicit PendingVariable(std::string\
    \ value) :\n        value_(std::move(value))\n    {  }\n\n    // We need this\
    \ check in order to make the following work:\n    // string s = getOpt(0);\n \
    \   // s = getOpt(0);\n    // Weird things happen if we allow all kind of casts.\
    \ See\n    // https://stackoverflow.com/questions/46740341\n    template<\n  \
    \      typename U,\n        typename std::enable_if<\n            detail::isValidOptionType<U>()>::type*\
    \ = nullptr>\n    operator U() const\n    {\n        std::istringstream ss(value_);\n\
    \        U t;\n        if (ss >> t) {\n            return t;\n        } else {\n\
    \            ensure(\n                false,\n                format(\n      \
    \              \"Cannot parse option. Raw value: '%s'\",\n                   \
    \ value_.c_str()));\n        }\n    }\n\nprivate:\n    std::string value_;\n};\n\
    \n// TODO: think about seed as a last argument\ninline VariableMap parseArguments(const\
    \ std::vector<std::string>& args) {\n    VariableMap result;\n\n    auto setNamedVar\
    \ = [&result](\n            const std::string& name,\n            const std::string&\
    \ value)\n    {\n        ensure(\n            !result.count(value),\n        \
    \    \"Named arguments must have distinct names\");\n        result.named[name]\
    \ = value;\n    };\n\n    std::string pendingVarName;\n\n    for (const std::string&\
    \ s: args) {\n        if (s == \"-\") {\n            continue;\n        }\n  \
    \      if (s == \"--\") {\n            break;\n        }\n\n        if (s[0] !=\
    \ '-') {\n            if (!pendingVarName.empty()) {\n                setNamedVar(pendingVarName,\
    \ s);\n                pendingVarName = \"\";\n            } else {\n        \
    \        result.positional.push_back(s);\n            }\n            continue;\n\
    \        }\n\n        if (!pendingVarName.empty()) {\n            result.named[pendingVarName]\
    \ = \"1\";\n            pendingVarName = \"\";\n        }\n\n        std::string\
    \ name;\n        std::string value;\n        bool foundEq = false;\n        for\
    \ (char c: s.substr(1)) {\n            if (!foundEq && c == '=') {\n         \
    \       foundEq = true;\n            } else {\n                if (foundEq) {\n\
    \                    value += c;\n                } else {\n                 \
    \   name += c;\n                }\n            }\n        }\n        if (foundEq)\
    \ {\n            setNamedVar(name, value);\n        } else {\n            pendingVarName\
    \ = name;\n        }\n\n        setNamedVar(name, value);\n    }\n\n    if (!pendingVarName.empty())\
    \ {\n        result.named[pendingVarName] = \"1\";\n    }\n\n    result.initialized\
    \ = true;\n    return result;\n}\n\nJNGEN_EXTERN VariableMap vmap;\n\nnamespace\
    \ detail {\n\ninline PendingVariable<void> getOpt(const Index& index) {\n    ensure(\n\
    \        vmap.initialized,\n        \"parseArgs(args, argv) must be called before\
    \ getOpt(...)\");\n    vmap.assertExistence(index);\n    return PendingVariable<void>(vmap[index]);\n\
    }\n\ntemplate<typename T, typename U = detail::StringIfCharPtrElseT<T>>\nPendingVariable<U>\
    \ getOpt(const Index& index, const T& defaultValue) {\n    ensure(\n        vmap.initialized,\n\
    \        \"parseArgs(args, argv) must be called before getOpt(...)\");\n    if\
    \ (vmap.count(index)) {\n        return PendingVariable<U>(vmap[index], U{defaultValue});\n\
    \    } else {\n        return PendingVariable<U>(nullptr, U{defaultValue});\n\
    \    }\n}\n\ninline bool hasOpt(const Index& index) {\n    return vmap.count(index);\n\
    }\n\ntemplate<typename T>\nbool readVariable(const std::string& value, T& var)\
    \ {\n    std::istringstream ss(value);\n\n    T t;\n    if (ss >> t) {\n     \
    \   var = t;\n        return true;\n    }\n    return false;\n}\n\ninline int\
    \ getNamedImpl(std::vector<std::string>::const_iterator) { return 0; }\n\ntemplate<typename\
    \ T, typename ... Args>\nint getNamedImpl(\n    std::vector<std::string>::const_iterator\
    \ it, T& var, Args&... args)\n{\n    T value;\n    int res = 0;\n    if (readVariable(vmap[*it],\
    \ value)) {\n        var = value;\n        ++res;\n    }\n    res += getNamedImpl(++it,\
    \ args...);\n    return res;\n}\n\ninline int getPositionalImpl(size_t) { return\
    \ 0; }\n\ntemplate<typename T, typename ... Args>\nint getPositionalImpl(size_t\
    \ index, T& var, Args&... args) {\n    T value;\n    int res = 0;\n    if (readVariable(vmap[index],\
    \ value)) {\n        var = value;\n        ++res;\n    }\n    res += getPositionalImpl(index\
    \ + 1, args...);\n    return res;\n}\n\n} // namespace detail\n\ntemplate<typename\
    \ ... Args>\nint doGetNamed(const std::string& names, Args&... args) {\n    ensure(\n\
    \        vmap.initialized,\n        \"parseArgs(args, argv) must be called before\
    \ getNamed(...)\");\n\n    auto namesSplit = util::split(names, ',');\n\n    ENSURE(\n\
    \        namesSplit.size() == sizeof...(args),\n        \"Number of names is not\
    \ equal to number of variables\");\n\n    return detail::getNamedImpl(namesSplit.begin(),\
    \ args...);\n}\n\ntemplate<typename ... Args>\nint getPositional(Args&... args)\
    \ {\n    ensure(\n        vmap.initialized,\n        \"parseArgs(args, argv) must\
    \ be called before getPositional(...)\");\n\n    return detail::getPositionalImpl(0,\
    \ args...);\n}\n\ninline void parseArgs(int argc, char *argv[]) {\n    vmap =\
    \ parseArguments(std::vector<std::string>(argv + 1, argv + argc));\n}\n\ninline\
    \ PendingVariable<void> getOpt(size_t index) {\n    return detail::getOpt(Index(index));\n\
    }\n\ninline PendingVariable<void> getOpt(const std::string& name) {\n    return\
    \ detail::getOpt(Index(name));\n}\n\ntemplate<typename T, typename U = detail::StringIfCharPtrElseT<T>>\n\
    PendingVariable<U> getOpt(size_t index, const T& defaultValue) {\n    return detail::getOpt(Index(index),\
    \ defaultValue);\n}\n\ntemplate<typename T, typename U = detail::StringIfCharPtrElseT<T>>\n\
    PendingVariable<U> getOpt(const std::string& name, const T& defaultValue) {\n\
    \    return detail::getOpt(Index(name), defaultValue);\n}\n\ninline bool hasOpt(size_t\
    \ index) {\n    return vmap.count(index);\n}\n\ninline bool hasOpt(const std::string&\
    \ name) {\n    return vmap.count(name);\n}\n\ninline options::Range parseRange(const\
    \ std::string& value) {\n    return options::Range::fromString(value);\n\n}\n\n\
    } // namespace jngen\n\nusing jngen::parseArgs;\nusing jngen::getOpt;\nusing jngen::hasOpt;\n\
    using jngen::parseRange;\n\nusing jngen::getPositional;\n\n#define getNamed(...)\
    \ ::jngen::doGetNamed(#__VA_ARGS__, __VA_ARGS__)\n\n\n#include <iostream>\n#include\
    \ <type_traits>\n\nnamespace jngen {\n\ntemplate<int N> struct PTag : PTag<N-1>\
    \ {};\ntemplate<> struct PTag<0> {};\nstruct PTagMax : PTag<20> {};\n\nstruct\
    \ OutputModifier {\n    int addition = 0;\n    bool printN = false;\n    bool\
    \ printM = false;\n\n    int printParents;\n    bool printEdges = true;\n    bool\
    \ printWeights = true;\n\n    char sep = ' ';\n};\n\nJNGEN_EXTERN OutputModifier\
    \ defaultMod;\n\ntemplate<typename T>\nclass Repr {\n    friend std::ostream&\
    \ operator<<(std::ostream& out, const Repr& repr) {\n        repr.print(out);\n\
    \        return out;\n    }\n\n    template<typename P>\n    friend Repr<P> repr(const\
    \ P& t);\n\n    template<typename P>\n    friend class ReprProxy;\n\nprotected:\n\
    \    Repr() = delete;\n    Repr(const Repr<T>&) = default;\n    Repr<T>& operator=(const\
    \ Repr<T>&) = default;\n    Repr(Repr<T>&&) = default;\n    Repr<T>& operator=(Repr<T>&&)\
    \ = default;\n\npublic:\n    Repr(const T& object) :\n        object_(object),\n\
    \        mod_(defaultMod)\n    {  }\n\n    Repr<T>& add1(bool value = true) {\n\
    \        mod_.addition = value;\n        return *this;\n    }\n\n    Repr<T>&\
    \ printN(bool value = true) {\n        mod_.printN = value;\n        return *this;\n\
    \    }\n\n    Repr<T>& printM(bool value = true) {\n        mod_.printM = value;\n\
    \        return *this;\n    }\n\n    Repr<T>& printParents(int value = -1) {\n\
    \        mod_.printParents = value;\n        mod_.printEdges = false;\n      \
    \  return *this;\n    }\n\n    Repr<T>& printEdges(bool value = true) {\n    \
    \    mod_.printEdges = value;\n        if (!value) {\n            mod_.printParents\
    \ = -1;\n        }\n        return *this;\n    }\n\n    Repr<T>& printWeights(bool\
    \ value = true) {\n        mod_.printWeights = value;\n        return *this;\n\
    \    }\n\n    Repr<T>& endl(bool value = true) {\n        mod_.sep = value ? '\\\
    n' : ' ';\n        return *this;\n    }\n\nprivate:\n    void print(std::ostream&\
    \ out) const {\n        printValue(out, object_, mod_, PTagMax{});\n    }\n\n\
    \    const T& object_;\n\nprotected:\n    OutputModifier mod_;\n};\n\nclass BaseReprProxy\
    \ {};\n\ntemplate<typename T>\nclass ReprProxy : public BaseReprProxy {\n    friend\
    \ std::ostream& operator<<(std::ostream& out, const ReprProxy& proxy) {\n    \
    \    Repr<T> repr(static_cast<const T&>(proxy));\n        return out << repr;\n\
    \    }\n\npublic:\n    Repr<T> add1(bool value = true) {\n        Repr<T> repr(static_cast<const\
    \ T&>(*this));\n        repr.add1(value);\n        return repr;\n    }\n\n   \
    \ Repr<T> printN(bool value = true) {\n        Repr<T> repr(static_cast<const\
    \ T&>(*this));\n        repr.printN(value);\n        return repr;\n    }\n\n \
    \   Repr<T> printM(bool value = true) {\n        Repr<T> repr(static_cast<const\
    \ T&>(*this));\n        repr.printM(value);\n        return repr;\n    }\n\n \
    \   Repr<T> printParents(int value = -1) {\n        Repr<T> repr(static_cast<const\
    \ T&>(*this));\n        repr.printParents(value);\n        return repr;\n    }\n\
    \n    Repr<T> printEdges(bool value = true) {\n        Repr<T> repr(static_cast<const\
    \ T&>(*this));\n        repr.printEdges(value);\n        return repr;\n    }\n\
    \n    Repr<T> printWeights(bool value = true) {\n        Repr<T> repr(static_cast<const\
    \ T&>(*this));\n        repr.printWeights(value);\n        return repr;\n    }\n\
    \n    Repr<T> endl(bool value = true) {\n        Repr<T> repr(static_cast<const\
    \ T&>(*this));\n        repr.endl(value);\n        return repr;\n    }\n\nprotected:\n\
    \    ReprProxy() {\n        static_assert(\n            std::is_base_of<ReprProxy<T>,\
    \ T>::value,\n            \"ReprProxy<T> must be inherited by T\");\n    }\n};\n\
    \ntemplate<typename T>\nRepr<T> repr(const T& t) {\n    return Repr<T>(t);\n}\n\
    \nclass DefaultModSetter : public Repr<int> {\n    friend DefaultModSetter setMod();\n\
    \nprivate:\n    DefaultModSetter(int val) :\n        Repr<int>(val)\n    {  }\n\
    \npublic:\n    ~DefaultModSetter() {\n        defaultMod = mod_;\n    }\n\n  \
    \  Repr<int>& reset() {\n        mod_ = OutputModifier();\n        return *this;\n\
    \    }\n};\n\ninline DefaultModSetter setMod() {\n    static int dummy = 0;\n\
    \    return DefaultModSetter(dummy);\n}\n\n} // namespace jngen\n\nusing jngen::repr;\n\
    using jngen::setMod;\n\n\n#include <iostream>\n#include <tuple>\n#include <type_traits>\n\
    #include <typeinfo>\n#include <utility>\n#include <vector>\n\nnamespace jngen\
    \ {\n\nnamespace detail {\n\n// TODO: maybe make it more clear SFINAE, like boost::has_left_shift<X,Y>?\n\
    // TODO: make these defines namespace independent\n\n#define JNGEN_DEFINE_FUNCTION_CHECKER(name,\
    \ expr)\\\ntemplate<typename T, typename Enable = void>\\\nclass Has ## name ##\
    \ Helper: public std::false_type {};\\\n\\\ntemplate<typename T>\\\nclass Has\
    \ ## name ## Helper<T,\\\n    decltype(void(\\\n        expr\\\n    ))\\\n> :\
    \ public std::true_type {};\\\n\n#define JNGEN_HAS_FUNCTION(name)\\\n    ::jngen::detail::Has\
    \ ## name ## Helper<T>::value\n\nJNGEN_DEFINE_FUNCTION_CHECKER(\n    OstreamMethod,\n\
    \    std::declval<std::ostream&>().operator<< (std::declval<T>())\n)\n\nJNGEN_DEFINE_FUNCTION_CHECKER(\n\
    \    OstreamFreeFunction,\n    std::operator<<(std::declval<std::ostream&>(),\
    \ std::declval<T>())\n)\n\nJNGEN_DEFINE_FUNCTION_CHECKER(\n    Plus,\n    T(std::declval<T>()\
    \ + 1)\n)\n\nJNGEN_DEFINE_FUNCTION_CHECKER(\n    Container,\n    std::distance(std::declval<T>().begin(),\
    \ std::declval<T>().end())\n)\n\n#define JNGEN_HAS_OSTREAM()\\\n    (JNGEN_HAS_FUNCTION(OstreamMethod)\
    \ ||\\\n        JNGEN_HAS_FUNCTION(OstreamFreeFunction))\n\ntemplate<typename\
    \ T>\nstruct VectorDepth {\n    constexpr static int value = 0;\n};\n\ntemplate<typename\
    \ T, template <typename...> class C>\nstruct VectorDepth<C<T>> {\n    constexpr\
    \ static int value =\n        std::is_base_of<\n            std::vector<T>,\n\
    \            C<T>\n        >::value ? VectorDepth<T>::value + 1 : 0;\n};\n\n}\
    \ // namespace detail\n\n#define JNGEN_DECLARE_PRINTER(constraint, priority)\\\
    \ntemplate<typename T>\\\nauto printValue(\\\n    std::ostream& out, const T&\
    \ t, const OutputModifier& mod, PTag<priority>)\\\n    -> enable_if_t<constraint,\
    \ void>\n\n#define JNGEN_DECLARE_SIMPLE_PRINTER(type, priority)\\\ninline void\
    \ printValue(std::ostream& out, const type& t,\\\n    const OutputModifier& mod,\
    \ PTag<priority>)\n\n#define JNGEN_PRINT(value)\\\nprintValue(out, value, mod,\
    \ PTagMax{})\n\n#define JNGEN_PRINT_NO_MOD(value)\\\nprintValue(out, value, OutputModifier{},\
    \ PTagMax{})\n\nJNGEN_DECLARE_PRINTER(!JNGEN_HAS_OSTREAM(), 0)\n{\n    static\
    \ bool locked = false;\n\n    ensure(\n            !locked,\n            std::string{}\
    \ + \"You are trying to print a type for which \"\n            \"operator<< is\
    \ not defined: \" + typeid(T).name());\n\n    locked = true;\n    (void)mod;\n\
    \    out << t;\n    locked = false;\n}\n\nJNGEN_DECLARE_PRINTER(JNGEN_HAS_OSTREAM(),\
    \ 10)\n{\n    (void)mod;\n    out << t;\n}\n\nJNGEN_DECLARE_PRINTER(\n    JNGEN_HAS_OSTREAM()\
    \ && JNGEN_HAS_FUNCTION(Plus), 11)\n{\n    if (std::is_integral<T>::value) {\n\
    \        out << T(t + mod.addition);\n    } else {\n        out << t;\n    }\n\
    }\n\nJNGEN_DECLARE_PRINTER(detail::VectorDepth<T>::value == 1, 3)\n{\n    if (mod.printN)\
    \ {\n        out << t.size() << \"\\n\";\n    }\n    bool first = true;\n    for\
    \ (const auto& x: t) {\n        if (first) {\n            first = false;\n   \
    \     } else {\n            out << mod.sep;\n        }\n        JNGEN_PRINT(x);\n\
    \    }\n}\n\nJNGEN_DECLARE_PRINTER(detail::VectorDepth<T>::value == 1 &&\n   \
    \ std::tuple_size<typename T::value_type>::value == 2, 4)\n{\n    if (mod.printN)\
    \ {\n        out << t.size() << \"\\n\";\n    }\n\n    bool first = true;\n  \
    \  for (const auto& x: t) {\n        if (first) {\n            first = false;\n\
    \        } else {\n            out << \"\\n\";\n        }\n        JNGEN_PRINT(x);\n\
    \    }\n}\n\nJNGEN_DECLARE_PRINTER(detail::VectorDepth<T>::value == 2, 4)\n{\n\
    \    if (mod.printN) {\n        out << t.size() << (mod.printM ? \" \" : \"\"\
    );\n    }\n    if (mod.printM) {\n        if (t.empty()) {\n            out <<\
    \ 0;\n        } else {\n            auto size = t[0].size();\n            out\
    \ << size;\n            for (const auto& vec: t) {\n                ensure(size\
    \ == vec.size(), \"Size of all matrix elements must \"\n                     \
    \   \"be equal if printM is specified\");\n            }\n        }\n    }\n\n\
    \    if ((mod.printN || mod.printM) && !t.empty()) {\n        out << \"\\n\";\n\
    \    }\n\n    auto tmp = mod;\n    {\n        auto mod = tmp;\n        mod.printN\
    \ = mod.printM = false;\n        bool first = true;\n        for (const auto&\
    \ x: t) {\n            if (first) {\n                first = false;\n        \
    \    } else {\n                out << '\\n';\n            }\n            JNGEN_PRINT(x);\n\
    \        }\n    }\n}\n\nJNGEN_DECLARE_PRINTER(JNGEN_HAS_FUNCTION(Container), 2)\n\
    {\n    if (mod.printN) {\n        out << t.size() << \"\\n\";\n    }\n    bool\
    \ first = true;\n    for (const auto& x: t) {\n        if (first) {\n        \
    \    first = false;\n        } else {\n            out << \" \";\n        }\n\
    \        JNGEN_PRINT(x);\n    }\n}\n\nJNGEN_DECLARE_PRINTER(JNGEN_HAS_FUNCTION(Container)\n\
    \    && std::tuple_size<typename T::value_type>::value == 2, 3)\n{\n    if (mod.printN)\
    \ {\n        out << t.size() << \"\\n\";\n    }\n    bool first = true;\n    for\
    \ (const auto& x: t) {\n        if (first) {\n            first = false;\n   \
    \     } else {\n            out << \"\\n\";\n        }\n        JNGEN_PRINT(x);\n\
    \    }\n}\n\n// http://stackoverflow.com/a/19841470/2159939\n#define JNGEN_COMMA\
    \ ,\n\ntemplate<typename Lhs, typename Rhs>\nJNGEN_DECLARE_SIMPLE_PRINTER(std::pair<Lhs\
    \ JNGEN_COMMA Rhs>, 3)\n{\n    JNGEN_PRINT(t.first);\n    out << \" \";\n    JNGEN_PRINT(t.second);\n\
    }\n\n#undef JNGEN_COMMA\n\n// Following snippet allows writing\n//     cout <<\
    \ pair<int, int>(1, 2) << endl;\n// in user code. I have to put it into separate\
    \ namespace because\n//   1) I don't want to 'use' all operator<< from jngen\n\
    //   2) I cannot do it in global namespace because JNGEN_HAS_OSTREAM relies\n\
    // on that it is in jngen.\nnamespace namespace_for_fake_operator_ltlt {\n\ntemplate<typename\
    \ T>\nauto operator<<(std::ostream& out, const T& t)\n    -> enable_if_t<\n  \
    \          !JNGEN_HAS_OSTREAM() && !std::is_base_of<BaseReprProxy, T>::value,\n\
    \            std::ostream&\n        >\n{\n    // not jngen::printValue, because\
    \ relying on ADL here for printers declared\n    // later (see, e.g., http://stackoverflow.com/questions/42833134)\n\
    \    printValue(out, t, jngen::defaultMod, jngen::PTagMax{});\n    return out;\n\
    }\n\n} // namespace namespace_for_fake_operator_ltlt\n\n// Calling this operator\
    \ inside jngen namespace doesn't work without this line.\nusing namespace jngen::namespace_for_fake_operator_ltlt;\n\
    \n} // namespace jngen\n\nusing namespace jngen::namespace_for_fake_operator_ltlt;\n\
    \n\n#include <algorithm>\n#include <iterator>\n#include <numeric>\n\nnamespace\
    \ jngen {\n\n// TODO: deprecate random_shuffle as done in testlib.h\n\ntemplate<typename\
    \ Iterator>\nvoid shuffle(Iterator begin, Iterator end) {\n    ensure(end >= begin,\
    \ \"Cannot shuffle range of negative length\");\n    size_t size = end - begin;\n\
    \    for (size_t i = 1; i < size; ++i) {\n        std::swap(*(begin + i), *(begin\
    \ + rnd.next(i + 1)));\n    }\n}\n\ntemplate<typename Iterator>\nauto choice(Iterator\
    \ begin, Iterator end)\n        -> typename std::iterator_traits<Iterator>::value_type\n\
    {\n    return rnd.choice(begin, end);\n}\n\ntemplate<typename Container>\ntypename\
    \ Container::value_type choice(const Container& container) {\n    return rnd.choice(container);\n\
    }\n\ntemplate<typename T>\nT choice(std::initializer_list<T> ilist) {\n    return\
    \ choice(ilist.begin(), ilist.end());\n}\n\nnamespace detail {\n\ntemplate<typename\
    \ Collection2D>\ntypename Collection2D::value_type interleave(const Collection2D&\
    \ collection) {\n    std::vector<size_t> sizes;\n    for (const auto& c: collection)\
    \ {\n        sizes.push_back(c.size());\n    }\n    size_t size = std::accumulate(sizes.begin(),\
    \ sizes.end(), 0u);\n\n    typename Collection2D::value_type result;\n    while\
    \ (size > 0) {\n        size_t id = rnd.nextByDistribution(sizes);\n        result.emplace_back(collection[id][collection[id].size()\
    \ - sizes[id]]);\n        --sizes[id];\n\n        --size;\n    }\n\n    return\
    \ result;\n}\n\n} // namespace detail\n\ntemplate<typename Collection2D>\ntypename\
    \ Collection2D::value_type interleave(const Collection2D& collection) {\n    return\
    \ detail::interleave(collection);\n}\n\ntemplate<typename Collection>\nCollection\
    \ interleave(const std::initializer_list<Collection>& ilist) {\n    return detail::interleave<std::vector<Collection>>(ilist);\n\
    }\n\n} // namespace jngen\n\nusing jngen::shuffle;\nusing jngen::choice;\nusing\
    \ jngen::interleave;\n\n\n#include <algorithm>\n#include <initializer_list>\n\
    #include <numeric>\n#include <set>\n#include <string>\n#include <type_traits>\n\
    #include <unordered_set>\n#include <unordered_map>\n#include <utility>\n#include\
    \ <vector>\n\nnamespace jngen {\n\ntemplate<typename T>\nclass GenericArray :\
    \ public ReprProxy<GenericArray<T>>, public std::vector<T> {\npublic:\n    typedef\
    \ std::vector<T> Base;\n\n    using Base::Base;\n\n    GenericArray() {}\n   \
    \ GenericArray(const GenericArray<T>&) = default;\n    GenericArray& operator=(const\
    \ GenericArray<T>&) = default;\n    GenericArray(GenericArray<T>&&) = default;\n\
    \    GenericArray& operator=(GenericArray<T>&&) = default;\n\n    ~GenericArray()\
    \ {}\n\n    /* implicit */ GenericArray(const Base& base) :\n            Base(base)\n\
    \    {  }\n\n    using Base::at;\n    using Base::size;\n    using Base::resize;\n\
    \    using Base::begin;\n    using Base::end;\n    using Base::insert;\n    using\
    \ Base::clear;\n    using Base::erase;\n\n    void extend(size_t requiredSize)\
    \ {\n        checkLargeParameter(requiredSize);\n        if (requiredSize > size())\
    \ {\n            resize(requiredSize);\n        }\n    }\n\n    template<typename\
    \ F, typename ...Args>\n    static GenericArray<T> randomf(size_t size, F func,\
    \ const Args& ... args);\n    template<typename F, typename ...Args>\n    static\
    \ GenericArray<T> randomfUnique(\n            size_t size, F func, const Args&\
    \ ... args);\n    template<typename F, typename ...Args>\n    static GenericArray<T>\
    \ randomfAll(F func, const Args& ... args);\n\n    template<typename ...Args>\n\
    \    static GenericArray<T> random(size_t size, const Args& ... args);\n    template<typename\
    \ ...Args>\n    static GenericArray<T> randomUnique(size_t size, const Args& ...\
    \ args);\n    template<typename ...Args>\n    static GenericArray<T> randomAll(const\
    \ Args& ... args);\n\n    static GenericArray<T> id(size_t size, T start = T{});\n\
    \n    GenericArray<T>& shuffle();\n    GenericArray<T> shuffled() const;\n\n \
    \   GenericArray<T>& reverse();\n    GenericArray<T> reversed() const;\n\n   \
    \ GenericArray<T>& sort();\n    GenericArray<T> sorted() const;\n\n    template<typename\
    \ Comp>\n    GenericArray<T>& sort(Comp&& comp);\n    template<typename Comp>\n\
    \    GenericArray<T> sorted(Comp&& comp) const;\n\n    GenericArray<T>& unique();\n\
    \    GenericArray<T> uniqued() const;\n\n    GenericArray<T> inverse() const;\n\
    \n    template<typename Integer>\n    GenericArray<T> subseq(const std::vector<Integer>&\
    \ indices) const;\n\n    template<typename Integer>\n    GenericArray<T> subseq(\n\
    \        const std::initializer_list<Integer>& indices) const;\n\n    T choice()\
    \ const;\n    GenericArray<T> choice(size_t count) const;\n    GenericArray<T>\
    \ choiceWithRepetition(size_t count) const;\n\n    GenericArray<T>& operator+=(const\
    \ GenericArray<T>& other);\n    GenericArray<T> operator+(const GenericArray<T>&\
    \ other) const;\n\n    GenericArray<T>& operator*=(int k);\n    GenericArray<T>\
    \ operator*(int k) const;\n\n    operator std::string() const;\n};\n\ntemplate<typename\
    \ T>\ntemplate<typename ...Args>\nGenericArray<T> GenericArray<T>::random(size_t\
    \ size, const Args& ... args) {\n    checkLargeParameter(size);\n    GenericArray<T>\
    \ result(size);\n    for (T& x: result) {\n        x = rnd.tnext<T>(args...);\n\
    \    }\n    return result;\n}\n\ntemplate<typename T>\ntemplate<typename F, typename\
    \ ...Args>\nGenericArray<T> GenericArray<T>::randomf(\n        size_t size,\n\
    \        F func,\n        const Args& ... args)\n{\n    checkLargeParameter(size);\n\
    \    GenericArray<T> result(size);\n    for (T& x: result) {\n        x = func(args...);\n\
    \    }\n    return result;\n}\n\nnamespace detail {\n\ntemplate<typename T, typename\
    \ Enable = std::size_t>\nstruct DictContainer {\n    typedef std::set<T> type;\n\
    };\n\ntemplate<typename T>\nstruct DictContainer<T, typename std::hash<T>::result_type>\n\
    {\n    typedef std::unordered_set<T> type;\n};\n\n} // namespace detail\n\ntemplate<typename\
    \ T>\ntemplate<typename F, typename ...Args>\nGenericArray<T> GenericArray<T>::randomfUnique(\n\
    \        size_t size,\n        F func,\n        const Args& ... args)\n{\n   \
    \ typename detail::DictContainer<T>::type set;\n    checkLargeParameter(size);\n\
    \    GenericArray<T> result;\n    result.reserve(size);\n\n    size_t retries\
    \ = (size + 10) * log(size + 10) * 2;\n\n    while (result.size() != size) {\n\
    \        T t = func(args...);\n        if (!set.count(t)) {\n            set.insert(t);\n\
    \            result.push_back(t);\n        }\n\n        if (--retries == 0) {\n\
    \            ensure(false, \"There are not enough unique elements\");\n      \
    \  }\n\n    }\n\n    return result;\n}\n\ntemplate<typename T>\ntemplate<typename\
    \ ...Args>\nGenericArray<T> GenericArray<T>::randomUnique(\n        size_t size,\
    \ const Args& ... args)\n{\n    return GenericArray<T>::randomfUnique(\n     \
    \   size,\n        [](Args... args) { return rnd.tnext<T>(args...); },\n     \
    \   args...);\n}\n\ntemplate<typename T>\ntemplate<typename F, typename ...Args>\n\
    GenericArray<T> GenericArray<T>::randomfAll(\n        F func,\n        const Args&\
    \ ... args)\n{\n    typename detail::DictContainer<T>::type set;\n    GenericArray<T>\
    \ result;\n\n    size_t timeAfterLastHit = 0;\n\n    while (true) {\n        T\
    \ t = func(args...);\n        if (!set.count(t)) {\n            set.insert(t);\n\
    \            result.push_back(t);\n            timeAfterLastHit = 0;\n       \
    \ }\n\n        ++timeAfterLastHit;\n\n        // Probability of finding not all\
    \ elements is about e^{-20} ~= 1e-9\n        if (timeAfterLastHit > (result.size()\
    \ + 10) * 20) {\n            return result;\n        }\n    }\n}\n\ntemplate<typename\
    \ T>\ntemplate<typename ...Args>\nGenericArray<T> GenericArray<T>::randomAll(const\
    \ Args& ... args)\n{\n    return GenericArray<T>::randomfAll(\n        [](Args...\
    \ args) { return rnd.tnext<T>(args...); },\n        args...);\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T> GenericArray<T>::id(size_t size, T start) {\n    constexpr\
    \ bool enable = std::is_integral<T>::value;\n    static_assert(enable, \"Cannot\
    \ call Array<T>::id with non-integral T\");\n    checkLargeParameter(size);\n\n\
    \    if (enable) {\n        GenericArray<T> result(size);\n        std::iota(result.begin(),\
    \ result.end(), start);\n        return result;\n    } else {\n        return\
    \ {};\n    }\n}\n\ntemplate<typename T>\nGenericArray<T>& GenericArray<T>::shuffle()\
    \ {\n    jngen::shuffle(begin(), end());\n    return *this;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T> GenericArray<T>::shuffled() const {\n    auto res = *this;\n\
    \    res.shuffle();\n    return res;\n}\n\ntemplate<typename T>\nGenericArray<T>&\
    \ GenericArray<T>::reverse() {\n    std::reverse(begin(), end());\n    return\
    \ *this;\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::reversed()\
    \ const {\n    auto res = *this;\n    res.reverse();\n    return res;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T>& GenericArray<T>::sort() {\n    std::sort(begin(), end());\n\
    \    return *this;\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::sorted()\
    \ const {\n    auto res = *this;\n    res.sort();\n    return res;\n}\n\ntemplate<typename\
    \ T>\ntemplate<typename Comp>\nGenericArray<T>& GenericArray<T>::sort(Comp&& comp)\
    \ {\n    std::sort(begin(), end(), comp);\n    return *this;\n}\n\ntemplate<typename\
    \ T>\ntemplate<typename Comp>\nGenericArray<T> GenericArray<T>::sorted(Comp&&\
    \ comp) const {\n    auto res = *this;\n    res.sort(comp);\n    return res;\n\
    }\n\ntemplate<typename T>\nGenericArray<T>& GenericArray<T>::unique() {\n    erase(std::unique(begin(),\
    \ end()), end());\n    return *this;\n}\n\ntemplate<typename T>\nGenericArray<T>\
    \ GenericArray<T>::uniqued() const {\n    auto res = *this;\n    res.unique();\n\
    \    return res;\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::inverse()\
    \ const {\n    static_assert(\n        std::is_integral<T>::value,\n        \"\
    Can only take inverse permutation of integral array\");\n    int n = size();\n\
    \n    if (n == 0) {\n        return *this;\n    }\n\n    // sanity check\n   \
    \ ensure(*max_element(begin(), end()) == n-1 &&\n        *min_element(begin(),\
    \ end()) == 0,\n        \"Trying to take inverse of the array which is not a permutation\"\
    );\n\n    const static T NONE = static_cast<T>(-1);\n    GenericArray<T> result(n,\
    \ NONE);\n    for (int i = 0; i < n; ++i) {\n        ensure(result[at(i)] == NONE,\n\
    \            \"Trying to take inverse of the array which is not a permutation\"\
    );\n        result[at(i)] = i;\n    }\n\n    return result;\n}\n\ntemplate<typename\
    \ T>\ntemplate<typename Integer>\nGenericArray<T> GenericArray<T>::subseq(\n \
    \       const std::vector<Integer>& indices) const\n{\n    GenericArray<T> result;\n\
    \    result.reserve(indices.size());\n    for (Integer idx: indices) {\n     \
    \   result.push_back(at(idx));\n    }\n    return result;\n}\n\n// TODO(ifsmirnov):\
    \ ever need to make it faster?\ntemplate<typename T>\ntemplate<typename Integer>\n\
    GenericArray<T> GenericArray<T>::subseq(\n        const std::initializer_list<Integer>&\
    \ indices) const\n{\n    return subseq(std::vector<T>(indices));\n}\n\ntemplate<typename\
    \ T>\nT GenericArray<T>::choice() const {\n    return jngen::choice(begin(), end());\n\
    }\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::choice(size_t count)\
    \ const {\n    ensure(\n        count <= size(),\n        \"Use Array::choiceWithRepetition\
    \ to select more than size() elements\");\n\n    size_t n = size();\n\n    std::unordered_map<size_t,\
    \ size_t> used;\n    std::vector<size_t> res;\n    for (size_t i = 0; i < count;\
    \ ++i) {\n        size_t oldValue = used.count(n-i-1) ? used[n-i-1] : n-i-1;\n\
    \        size_t index = rnd.tnext<size_t>(n-i);\n        res.push_back(used.count(index)\
    \ ? used[index] : index);\n        used[index] = oldValue;\n    }\n\n    return\
    \ subseq(res);\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::choiceWithRepetition(size_t\
    \ count) const {\n    checkLargeParameter(count);\n    GenericArray<T> res(count);\n\
    \    for (T& t: res) {\n        t = choice();\n    }\n    return res;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T>& GenericArray<T>::operator+=(const GenericArray<T>& other)\
    \ {\n    if (&other == this) {\n        return *this *= 2;\n    }\n    insert(end(),\
    \ other.begin(), other.end());\n    return *this;\n}\n\ntemplate<typename T>\n\
    GenericArray<T> GenericArray<T>::operator+(const GenericArray<T>& other) const\
    \ {\n    GenericArray<T> copy(*this);\n    return copy += other;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T>& GenericArray<T>::operator*=(int k) {\n    if (k == 0) {\n\
    \        clear();\n        return *this;\n    }\n\n    this->reserve(size() *\
    \ k);\n\n    std::copy_n(begin(), size() * (k - 1), std::back_inserter(*this));\n\
    \n    return *this;\n}\n\ntemplate<typename T>\nGenericArray<T> GenericArray<T>::operator*(int\
    \ k) const {\n    GenericArray<T> copy(*this);\n    return copy *= k;\n}\n\ntemplate<typename\
    \ T>\nGenericArray<T>::operator std::string() const {\n    static_assert(std::is_same<T,\
    \ char>::value, \"Must not cast\"\n        \" TArray<T> to std::string with 'T'\
    \ != 'char'\");\n    return std::string(begin(), end());\n}\n\n// JNGEN_EXTERN\
    \ template class GenericArray<int>;\n\ntemplate<typename T>\nusing TArray = GenericArray<T>;\n\
    \nusing Array = GenericArray<int>;\nusing Array2d = GenericArray<jngen::GenericArray<int>>;\n\
    using Array64 = GenericArray<long long>;\nusing Arrayf = GenericArray<double>;\n\
    using Arrayp = GenericArray<std::pair<int, int>>;\n\ntemplate<typename T>\njngen::GenericArray<T>\
    \ makeArray(const std::vector<T>& values) {\n    return jngen::GenericArray<T>(values);\n\
    }\n\ntemplate<typename T>\njngen::GenericArray<T> makeArray(const std::initializer_list<T>&\
    \ values) {\n    return jngen::GenericArray<T>(values);\n}\n\ntemplate<typename\
    \ T, typename U>\nTArray<std::pair<T, U>> zip(const TArray<T>& lhs, const TArray<U>&\
    \ rhs) {\n    ensure(\n        lhs.size() == rhs.size(),\n        \"In zip(a,\
    \ b), a and b must have the same size\");\n    TArray<std::pair<T, U>> result;\n\
    \    for (size_t i = 0; i < lhs.size(); ++i) {\n        result.emplace_back(lhs[i],\
    \ rhs[i]);\n    }\n    return result;\n}\n\ntemplate<typename T, typename U>\n\
    TArray<T> arrayCast(const TArray<U>& array) {\n    return TArray<T>(array.begin(),\
    \ array.end());\n}\n\ntemplate<typename T>\nstruct Hash<TArray<T>> {\n    uint64_t\
    \ operator()(const TArray<T>& elements) const {\n        return Hash<std::vector<T>>{}(elements);\n\
    \    }\n};\n\n} // namespace jngen\n\nJNGEN_DEFINE_STD_HASH_TEMPLATE(T, jngen::TArray<T>);\n\
    \nusing jngen::makeArray;\nusing jngen::zip;\nusing jngen::arrayCast;\n\nusing\
    \ jngen::TArray;\n\nusing jngen::Array;\nusing jngen::Array2d;\nusing jngen::Array64;\n\
    using jngen::Arrayf;\nusing jngen::Arrayp;\n\n// This header is named 'math_jngen.h'\
    \ and not 'math.h' because in the latter\n// case it will replace the standard\
    \ 'math.h' if you set jngen folder as the\n// include path.\n\n\n#include <algorithm>\n\
    #include <cmath>\n#include <iterator>\n#include <limits>\n#include <type_traits>\n\
    #include <unordered_set>\n#include <vector>\n\nnamespace jngen {\n\nnamespace\
    \ detail {\n\ninline int multiply(int x, int y, int mod) {\n    return static_cast<long\
    \ long>(x) * y % mod;\n}\n\ninline long long multiply(long long x, long long y,\
    \ long long mod) {\n#if defined(__SIZEOF_INT128__)\n    return static_cast<__int128>(x)\
    \ * y % mod;\n#else\n    long long res = 0;\n    while (y) {\n        if (y&1)\
    \ {\n            res = (static_cast<unsigned long long>(res) + x) % mod;\n   \
    \     }\n        x = (static_cast<unsigned long long>(x) + x) % mod;\n       \
    \ y >>= 1;\n    }\n    return res;\n#endif\n}\n\ninline int power(int x, int k,\
    \ int mod) {\n    int res = 1;\n    while (k) {\n        if (k&1) {\n        \
    \    res = multiply(res, x, mod);\n        }\n        x = multiply(x, x, mod);\n\
    \        k >>= 1;\n    }\n    return res;\n}\n\ninline long long power(long long\
    \ x, long long k, long long mod) {\n    long long res = 1;\n    while (k) {\n\
    \        if (k&1) {\n            res = multiply(res, x, mod);\n        }\n   \
    \     x = multiply(x, x, mod);\n        k >>= 1;\n    }\n    return res;\n}\n\n\
    template<typename I>\nbool millerRabinTest(I n, const std::vector<I>& witnesses)\
    \ {\n    static_assert(\n        std::is_same<I, int>::value || std::is_same<I,\
    \ long long>::value,\n        \"millerRabinTest<int/long long> only is supported\"\
    );\n\n    if (n == 1) {\n        return false;\n    }\n\n    constexpr int LIMIT\
    \ = 10000;\n\n    if (n <= LIMIT) {\n        for (int i = 2; i*i <= n; ++i) {\n\
    \            if (n%i == 0) {\n                return false;\n            }\n \
    \       }\n        return true;\n    }\n\n    int r = 0;\n    I d = n - 1;\n \
    \   while (d % 2 == 0) {\n        ++r;\n        d /= 2;\n    }\n\n    for (I a:\
    \ witnesses) {\n        I x = power(a, d, n);\n        if (x == 1 || x == n -\
    \ 1) {\n            continue;\n        }\n\n        bool composite = true;\n \
    \       for (int i = 0; i < r - 1; ++i) {\n            x = multiply(x, x, n);\n\
    \            if (x == 1) {\n                return false;\n            }\n   \
    \         if (x == n - 1) {\n                i = r;\n                composite\
    \ = false;\n                continue;\n            }\n        }\n        if (composite)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\n} //\
    \ namespace detail\n\ninline bool isPrime(long long n) {\n    const static std::vector<int>\
    \ INT_WITNESSES{2, 7, 61};\n    const static std::vector<long long> LONG_LONG_WITNESSES\n\
    \        {2, 3, 5, 7, 11, 13, 17, 19, 23};\n    // todo: experiment with base\n\
    \    // 2, 325, 9375, 28178, 450775, 9780504, and 1795265022\n    // (guaranteed\
    \ for all integers < 2^64)\n\n    // first strong pseudoprime to i64 bases is\
    \ 3825123056546413051 ~= 3.8e18\n    ensure(n > 0, \"isPrime() is undefined for\
    \ negative numbers\");\n    ensure(\n        n <= static_cast<long long>(3.8e18),\n\
    \        \"isPrime() supports only numbers not greater than 3.8 * 10^18\");\n\n\
    \    if (n < std::numeric_limits<int>::max()) {\n        return detail::millerRabinTest<int>(n,\
    \ INT_WITNESSES);\n    } else {\n        return detail::millerRabinTest<long long>(n,\
    \ LONG_LONG_WITNESSES);\n    }\n}\n\nclass MathRandom {\npublic:\n    MathRandom()\
    \ {\n        static bool created = false;\n        ensure(!created, \"jngen::MathRandom\
    \ should be created only once\");\n        created = true;\n    }\n\n    static\
    \ long long randomPrime(long long n) {\n        ensure(n > 2, format(\"There are\
    \ no primes below %lld\", n));\n        return randomPrime(2, n - 1);\n    }\n\
    \n    static long long randomPrime(long long l, long long r) {\n        ensure(l\
    \ <= r);\n        std::unordered_set<long long> used;\n        while (static_cast<long\
    \ long>(used.size()) < r - l + 1) {\n            long long x = rnd.next(l, r);\n\
    \            if (used.count(x)) {\n                continue;\n            }\n\
    \            used.insert(x);\n            if (isPrime(x)) {\n                return\
    \ x;\n            }\n        }\n        ensure(\n            false,\n        \
    \    format(\n                \"There are no primes between %lld and %lld\",\n\
    \                l, r)\n        );\n    }\n\n    static long long nextPrime(long\
    \ long n) {\n        while (!isPrime(n)) {\n            ++n;\n        }\n    \
    \    return n;\n    }\n\n    static long long previousPrime(long long n) {\n \
    \       ensure(n >= 2, format(\"There are no primes less or equal to %lld\", n));\n\
    \        while (!isPrime(n)) {\n            --n;\n        }\n        return n;\n\
    \    }\n\n    static Array partition(\n            int n,\n            int numParts,\n\
    \            int minSize = 0,\n            int maxSize = -1)\n    {\n        auto\
    \ res = partition(\n            static_cast<long long>(n),\n            numParts,\n\
    \            static_cast<long long>(minSize),\n            static_cast<long long>(maxSize));\n\
    \        return Array(res.begin(), res.end());\n    }\n\n    static Array64 partition(\n\
    \            long long n,\n            int numParts,\n            long long minSize\
    \ = 0,\n            long long maxSize = -1)\n    {\n        if (maxSize == -1)\
    \ {\n            maxSize = n;\n        }\n\n        ensure(n >= 0);\n        ensure(numParts\
    \ >= 0);\n        ensure(numParts * minSize <= n, \"minSize is too large\");\n\
    \        ensure(numParts * maxSize >= n, \"maxSize is too small\");\n        ensure(minSize\
    \ <= maxSize);\n\n        n -= minSize * numParts;\n\n        auto delimiters\
    \ = Array64::random(\n                numParts - 1, 0, n).sorted();\n        delimiters.insert(delimiters.begin(),\
    \ 0);\n        delimiters.push_back(n);\n\n        Array64 partition(numParts);\n\
    \        for (long long i = 0; i < numParts; ++i) {\n            partition[i]\
    \ = delimiters[i + 1] - delimiters[i];\n        }\n        partition.sort().reverse();\n\
    \n        long long remaining = 0;\n\n        long long localMax = maxSize - minSize;\n\
    \        for (auto& x: partition) {\n            if (x > localMax) {\n       \
    \         remaining += x - localMax;\n                x = localMax;\n        \
    \    }\n\n            x += minSize;\n        }\n\n        // Here we try to distribute\
    \ the remaining part in some even manner\n        // between remaining slots.\
    \ Looks like crap anyway, need a smarter way.\n\n        for (int divisor: { 2,\
    \ 1 }) {\n            partition.shuffle();\n            for (auto& x: partition)\
    \ {\n                if (x < maxSize) {\n                    long long add = std::min(\n\
    \                            remaining, (maxSize - x) / divisor);\n          \
    \          x += add;\n                    remaining -= add;\n                }\n\
    \            }\n        }\n\n        ensure(remaining == 0, \"maxSize is too small\"\
    );\n\n        return partition;\n    }\n\n    template<typename T>\n    TArray<TArray<T>>\
    \ partition(\n            TArray<T> elements,\n            int numParts,\n   \
    \         int minSize = 0,\n            int maxSize = -1)\n    {\n        return\
    \ partition(\n            std::move(elements),\n            partition(\n     \
    \           static_cast<int>(elements.size()),\n                numParts,\n  \
    \              minSize,\n                maxSize));\n    }\n\n    template<typename\
    \ T>\n    TArray<TArray<T>> partition(TArray<T> elements, const Array& sizes)\
    \ {\n        size_t total = std::accumulate(sizes.begin(), sizes.end(), size_t(0));\n\
    \        ensure(total == elements.size(), \"sum(sizes) != elements.size()\");\n\
    \        elements.shuffle();\n        TArray<TArray<T>> res;\n        auto it\
    \ = elements.begin();\n        for (int size: sizes) {\n            res.emplace_back();\n\
    \            std::copy(it, it + size, std::back_inserter(res.back()));\n     \
    \       it += size;\n        }\n\n        return res;\n    }\n};\n\nJNGEN_EXTERN\
    \ MathRandom rndm;\n\n} // namespace jngen\n\nusing jngen::isPrime;\n\nusing jngen::rndm;\n\
    \n\n#include <algorithm>\n#include <cstdlib>\n\nnamespace jngen {\n\nenum class\
    \ UnorderedSetCompiler {\n    Gcc4,\n    Gcc5or6,\n    Clang\n};\n\nclass ArrayRandom\
    \ {\npublic:\n    ArrayRandom() {\n        static bool created = false;\n    \
    \    ENSURE(!created, \"jngen::ArrayRandom should be created only once\");\n \
    \       created = true;\n    }\n\n    template<typename F, typename ...Args>\n\
    \    static auto randomf(\n            size_t size,\n            F func,\n   \
    \         Args... args) -> GenericArray<decltype(func(args...))>\n    {\n    \
    \    typedef decltype(func(args...)) T;\n        return GenericArray<T>::randomf(size,\
    \ func, args...);\n    }\n\n    template<typename F, typename ...Args>\n    static\
    \ auto randomfUnique(\n            size_t size,\n            F func,\n       \
    \     Args... args) -> GenericArray<decltype(func(args...))>\n    {\n        typedef\
    \ decltype(func(args...)) T;\n        return GenericArray<T>::randomfUnique(size,\
    \ func, args...);\n    }\n\n    template<typename F, typename ...Args>\n    static\
    \ auto randomfAll(\n            F func,\n            Args... args) -> GenericArray<decltype(func(args...))>\n\
    \    {\n        typedef decltype(func(args...)) T;\n        return GenericArray<T>::randomfAll(func,\
    \ args...);\n    }\n\n    static Array64 antiUnorderedSet(\n        int n,\n \
    \       double maxLoadFactor = 1.0,\n        bool reserve = false,\n        UnorderedSetCompiler\
    \ compiler = UnorderedSetCompiler::Gcc4);\n\nprivate:\n    static Array64 numbersDividingPrime(int\
    \ n, long long p);\n\n    static long long nextPrime(\n        unsigned long long\
    \ x,\n        UnorderedSetCompiler compiler);\n};\n\nJNGEN_EXTERN ArrayRandom\
    \ rnda;\n\n#ifndef JNGEN_DECLARE_ONLY\n\nArray64 ArrayRandom::antiUnorderedSet(\n\
    \    int n,\n    double maxLoadFactor,\n    bool reserve,\n    UnorderedSetCompiler\
    \ compiler)\n{\n    ensure(\n        compiler == UnorderedSetCompiler::Gcc4,\n\
    \        \"unordered set antitest supported only for gcc-4.x yet\");\n\n    ensure(\n\
    \        n <= 1000000,\n        \"unordered set antitest supported only for n\
    \ <= 1e7\");\n\n    int buckets;\n\n    if (reserve) {\n        buckets = nextPrime(std::ceil(n\
    \ / maxLoadFactor), compiler);\n    } else {\n        buckets = 2;\n        for\
    \ (int size = 1; size <= n; ++size) {\n            if (size + 1 > buckets * maxLoadFactor)\
    \ {\n                buckets = nextPrime(buckets * 2, compiler);\n           \
    \ }\n        }\n    }\n\n    return numbersDividingPrime(n, buckets);\n}\n\nArray64\
    \ ArrayRandom::numbersDividingPrime(int n, long long p) {\n    auto a = Array64::id(n);\n\
    \    for (auto& x: a) {\n        x *= p;\n    }\n    return a;\n}\n\nlong long\
    \ ArrayRandom::nextPrime(\n    unsigned long long x,\n    UnorderedSetCompiler\
    \ compiler)\n{\n    ENSURE(compiler == UnorderedSetCompiler::Gcc4);\n\n    const\
    \ static size_t SIZE =\n        sizeof(impl::primeList) / sizeof(impl::primeList[0]);\n\
    \    return *std::lower_bound(impl::primeList, impl::primeList + SIZE, x);\n}\n\
    \n#endif // JNGEN_DECLARE_ONLY\n\n} // namespace jngen\n\nusing jngen::rnda;\n\
    using jngen::UnorderedSetCompiler;\n\n\n#include <algorithm>\n#include <cstdlib>\n\
    #include <iostream>\n#include <set>\n#include <tuple>\n#include <type_traits>\n\
    #include <unordered_set>\n\nnamespace jngen {\n\n#ifdef JNGEN_DECLARE_ONLY\nextern\
    \ long double eps;\n#else\nlong double eps = 1e-9;\n#endif\n\ninline void setEps(long\
    \ double value) {\n    eps = value;\n}\n\ntemplate<typename T, typename U, typename\
    \ Enable = void>\nstruct Comparator {\n    static bool eq(T a, U b) { return a\
    \ == b; }\n    static bool lt(T a, U b) { return a < b; }\n};\n\ntemplate<typename\
    \ T, typename U>\nstruct Comparator<T, U, enable_if_t<\n        std::is_floating_point<T>::value\
    \ || std::is_floating_point<U>::value,\n        void>>\n{\n    static bool eq(T\
    \ a, U b) { return std::abs(b - a) < eps; }\n    static bool lt(T a, U b) { return\
    \ a < b - eps; }\n};\n\ntemplate<typename T, typename U>\nbool eq(T t, U u) {\n\
    \    return Comparator<T, U>().eq(t, u);\n}\n\ntemplate<typename T, typename U>\n\
    bool lt(T t, U u) {\n    return Comparator<T, U>().lt(t, u);\n}\n\ntemplate<typename\
    \ T, typename U> bool ne(T t, U u) { return !eq(t, u); }\ntemplate<typename T,\
    \ typename U> bool le(T t, U u) { return !lt(u, t); }\ntemplate<typename T, typename\
    \ U> bool gt(T t, U u) { return  lt(u, t); }\ntemplate<typename T, typename U>\
    \ bool ge(T t, U u) { return !lt(t, u); }\n\ntemplate<typename T>\nstruct TPoint\
    \ : public ReprProxy<TPoint<T>> {\n    T x, y;\n\n    TPoint() : x(0), y(0) {}\n\
    \    TPoint(T x, T y) : x(x), y(y) {}\n\n    template<typename U>\n    TPoint(const\
    \ TPoint<U>& other) : x(other.x), y(other.y) {}\n\n    TPoint<T> operator+(const\
    \ TPoint<T>& other) const {\n        return TPoint<T>(x + other.x, y + other.y);\n\
    \    }\n\n    TPoint<T>& operator+=(const TPoint<T>& other) {\n        x += other.x;\n\
    \        y += other.y;\n        return *this;\n    }\n\n    TPoint<T> operator-(const\
    \ TPoint<T>& other) const {\n        return TPoint<T>(x - other.x, y - other.y);\n\
    \    }\n\n    TPoint<T>& operator-=(const TPoint<T>& other) {\n        x -= other.x;\n\
    \        y -= other.y;\n        return *this;\n    }\n\n    TPoint<T> operator-()\
    \ const {\n        return TPoint<T>(-x, -y);\n    }\n\n    TPoint<T> operator*(T\
    \ factor) const {\n        return TPoint<T>(x * factor, y * factor);\n    }\n\n\
    \    TPoint<T>& operator*=(T factor) {\n        x *= factor;\n        y *= factor;\n\
    \        return *this;\n    }\n\n    T operator*(const TPoint<T>& other) const\
    \ {\n        return x * other.x + y * other.y;\n    }\n\n    T operator%(const\
    \ TPoint<T>& other) const {\n        return x * other.y - y * other.x;\n    }\n\
    \n    bool operator==(const TPoint<T>& other) const {\n        return eq(x, other.x)\
    \ && eq(y, other.y);\n    }\n\n    bool operator!=(const TPoint<T>& other) const\
    \ {\n        return !(*this == other);\n    }\n\n    bool operator<(const TPoint<T>&\
    \ other) const {\n        if (eq(x, other.x)) {\n            return lt(y, other.y);\n\
    \        }\n        return lt(x, other.x);\n    }\n};\n\nusing Point = TPoint<long\
    \ long>;\nusing Pointf = TPoint<long double>;\n\ntemplate<>\nstruct Hash<Point>\
    \ {\n    uint64_t operator()(const Point& point) const {\n        uint64_t h =\
    \ 0;\n        impl::hashCombine(h, Hash<long long>{}(point.x));\n        impl::hashCombine(h,\
    \ Hash<long long>{}(point.y));\n        return h;\n    }\n};\n\ntemplate<typename\
    \ T>\nJNGEN_DECLARE_SIMPLE_PRINTER(TPoint<T>, 3) {\n    (void)mod;\n    out <<\
    \ t.x << \" \" << t.y;\n}\n\ntemplate<typename T>\nclass TPolygon : public GenericArray<TPoint<T>>\
    \ {\npublic:\n    using Base = GenericArray<TPoint<T>>;\n    using Base::Base;\n\
    \n    TPolygon<T>& shift(const TPoint<T>& vector) {\n        for (auto &pt: *this)\
    \ {\n            pt += vector;\n        }\n        return *this;\n    }\n\n  \
    \  TPolygon<T> shifted(const TPoint<T>& vector) const {\n        auto res = *this;\n\
    \        res.shift(vector);\n        return res;\n    }\n\n    TPolygon<T>& reflect()\
    \ {\n        for (auto& pt: *this) {\n            pt = -pt;\n        }\n     \
    \   return *this;\n    }\n\n    TPolygon<T> reflected() const {\n        auto\
    \ res = *this;\n        res.reflect();\n        return res;\n    }\n};\n\nusing\
    \ Polygon = TPolygon<long long>;\nusing Polygonf = TPolygon<long double>;\n\n\
    template<>\nstruct Hash<Polygon> {\n    uint64_t operator()(const Polygon& p)\
    \ const {\n        return Hash<TArray<Point>>{}(p);\n    }\n};\n\ntemplate<typename\
    \ T>\nJNGEN_DECLARE_SIMPLE_PRINTER(TArray<TPoint<T>>, 5) {\n    // I should avoid\
    \ copy-paste from array printer here but need to output\n    // points with '\\\
    n' separator. Maybe 'mod' should be made non-const?\n    if (mod.printN) {\n \
    \       out << t.size() << \"\\n\";\n    }\n    bool first = true;\n    for (const\
    \ auto& x: t) {\n        if (first) {\n            first = false;\n        } else\
    \ {\n            out << '\\n';\n        }\n        JNGEN_PRINT(x);\n    }\n}\n\
    \nnamespace detail {\n\ntemplate<typename T>\nTPolygon<T> convexHull(TArray<TPoint<T>>\
    \ points) {\n    points.sort().unique();\n\n    if (points.size() <= 2u) {\n \
    \       return points;\n    }\n\n    TArray<TPoint<T>> upper(points.begin(), points.begin()\
    \ + 2);\n    upper.reserve(points.size());\n    int top = 1;\n    for (size_t\
    \ i = 2; i < points.size(); ++i) {\n        while (top >= 1 && ge(\n         \
    \       (upper[top] - upper[top-1]) % (points[i] - upper[top]), 0ll))\n      \
    \  {\n            upper.pop_back();\n            --top;\n        }\n        upper.push_back(points[i]);\n\
    \        ++top;\n    }\n\n    TArray<TPoint<T>> lower(points.begin(), points.begin()\
    \ + 2);\n    lower.reserve(points.size());\n    top = 1;\n    for (size_t i =\
    \ 2; i < points.size(); ++i) {\n        while (top >= 1 && le(\n             \
    \   (lower[top] - lower[top-1]) % (points[i] - lower[top]), 0ll))\n        {\n\
    \            lower.pop_back();\n            --top;\n        }\n        lower.push_back(points[i]);\n\
    \        ++top;\n    }\n    upper.pop_back();\n    upper.erase(upper.begin());\n\
    \    return lower + upper.reversed();\n}\n\ntemplate<typename T>\nTPolygon<T>\
    \ convexPolygonByEllipse(\n        int n, Pointf center, Pointf xAxis, Pointf\
    \ yAxis)\n{\n    return convexHull(rnda.randomf(\n        n,\n        [center,\
    \ xAxis, yAxis] () -> TPoint<T> {\n            static const long double PI = acosl(-1.0);\n\
    \            long double angle = rnd.next(0., PI*2);\n            long double\
    \ sina = sinl(angle);\n            long double cosa = cosl(angle);\n         \
    \   return center + xAxis * cosa + yAxis * sina;\n        }\n    ));\n}\n\n} //\
    \ namespace detail\n\nclass GeometryRandom {\npublic:\n    GeometryRandom() {\n\
    \        static bool created = false;\n        ensure(!created, \"jngen::GeometryRandom\
    \ should be created only once\");\n        created = true;\n    }\n\n    // point\
    \ in [0, C] x [0, C]\n    static Point point(long long C);\n\n    // point in\
    \ [min, max] x [min, max]\n    static Point point(long long min, long long max);\n\
    \n    // point in [X1, Y1] x [X2, Y2]\n    static Point point(\n            long\
    \ long X1, long long Y1,\n            long long X2, long long Y2);\n\n    // point\
    \ in [0, C] x [0, C]\n    static Point pointf(long double C);\n\n    // point\
    \ in [min, max] x [min, max]\n    static Point pointf(long double min, long double\
    \ max);\n\n    // point in [X1, Y1] x [X2, Y2]\n    static Point pointf(\n   \
    \         long double X1, long double Y1,\n            long double X2, long double\
    \ Y2);\n\n\n    static Polygon convexPolygon(int n, long long C);\n    static\
    \ Polygon convexPolygon(int n, long long min, long long max);\n    static Polygon\
    \ convexPolygon(\n            int n,\n            long long X1, long long Y1,\n\
    \            long long X2, long long Y2);\n\n\n    static TArray<Point> pointsInGeneralPosition(int\
    \ n, long long C);\n\n    static TArray<Point> pointsInGeneralPosition(\n    \
    \        int n, long long min, long long max);\n    static TArray<Point> pointsInGeneralPosition(\n\
    \            int n,\n            long long X1, long long Y1,\n            long\
    \ long X2, long long Y2);\n\n};\n\n\nJNGEN_EXTERN GeometryRandom rndg;\n\nJNGEN_EXTERN\
    \ template struct jngen::TPoint<long long>;\nJNGEN_EXTERN template struct jngen::TPoint<long\
    \ double>;\nJNGEN_EXTERN template class jngen::TPolygon<long long>;\nJNGEN_EXTERN\
    \ template class jngen::TPolygon<long double>;\n\nJNGEN_EXTERN template TPolygon<long\
    \ long> detail::convexHull<long long>(\n        TArray<TPoint<long long>> points);\n\
    JNGEN_EXTERN template TPolygon<long double> detail::convexHull<long double>(\n\
    \        TArray<TPoint<long double>> points);\n\n} // namespace jngen\n\nJNGEN_DEFINE_STD_HASH(jngen::Point);\n\
    JNGEN_DEFINE_STD_HASH(jngen::Polygon);\n\nusing jngen::Point;\nusing jngen::Pointf;\n\
    \nusing jngen::Polygon;\nusing jngen::Polygonf;\n\nusing jngen::rndg;\n\nusing\
    \ jngen::setEps;\n\n// workaround for g++-7\nnamespace std {\n\nJNGEN_EXTERN template\
    \ class std::allocator<Point>;\nJNGEN_EXTERN template class std::allocator<Pointf>;\n\
    \n} // namespace std\n\n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_GEOMETRY_INL_H\n\
    #ifndef JNGEN_INCLUDE_GEOMETRY_INL_H\n#error File \"geometry_inl.h\" must not\
    \ be included directly.\n#endif\n\nnamespace jngen {\n\nPoint GeometryRandom::point(long\
    \ long C) {\n    return point(0, 0, C, C);\n}\n\nPoint GeometryRandom::point(long\
    \ long min, long long max) {\n    return point(min, min, max, max);\n}\n\nPoint\
    \ GeometryRandom::point(\n        long long X1, long long Y1,\n        long long\
    \ X2, long long Y2) {\n    long long x = rnd.tnext<long long>(X1, X2);\n    long\
    \ long y = rnd.tnext<long long>(Y1, Y2);\n    return Point(x, y);\n}\n\nPoint\
    \ GeometryRandom::pointf(long double C) {\n    return pointf(0, 0, C, C);\n}\n\
    \nPoint GeometryRandom::pointf(long double min, long double max) {\n    return\
    \ pointf(min, min, max, max);\n}\n\nPoint GeometryRandom::pointf(\n        long\
    \ double X1, long double Y1,\n        long double X2, long double Y2)\n{\n   \
    \ long double x = rnd.tnext<long double>(X1, X2);\n    long double y = rnd.tnext<long\
    \ double>(Y1, Y2);\n    return Pointf(x, y);\n}\n\n\nPolygon GeometryRandom::convexPolygon(int\
    \ n, long long C) {\n    return convexPolygon(n, 0, 0, C, C);\n}\n\nPolygon GeometryRandom::convexPolygon(int\
    \ n, long long min, long long max) {\n    return convexPolygon(n, min, min, max,\
    \ max);\n}\n\nPolygon GeometryRandom::convexPolygon(\n            int n,\n   \
    \         long long X1, long long Y1,\n            long long X2, long long Y2)\n\
    {\n    // todo: off-by-one error?\n    auto dx = X2 - X1;\n    auto dy = Y2 -\
    \ Y1;\n    ensure(n >= 0);\n    Polygon res = detail::convexPolygonByEllipse<long\
    \ long>(\n        n * 10, // BUBEN!\n        Point(dx / 2, dy / 2),\n        Point(dx\
    \ / 2, 0),\n        Point(0, dy / 2)\n    );\n    res.shift(Point(X1, Y1));\n\
    \    for (auto& x: res) {\n        ENSURE(x.x >= X1);\n        ENSURE(x.x <= X2);\n\
    \        ENSURE(x.y >= Y1);\n        ENSURE(x.y <= Y2);\n    }\n\n    ensure(\n\
    \        static_cast<int>(res.size()) >= n,\n        \"Cannot generate a convex\
    \ polygon with so many vertices\");\n\n    return res.subseq(Array::id(res.size()).choice(n).sort());\n\
    }\n\n\nTArray<Point> GeometryRandom::pointsInGeneralPosition(int n, long long\
    \ C) {\n    return pointsInGeneralPosition(n, 0, 0, C, C);\n}\n\nTArray<Point>\
    \ GeometryRandom::pointsInGeneralPosition(\n        int n, long long min, long\
    \ long max)\n{\n    return pointsInGeneralPosition(n, min, min, max, max);\n}\n\
    \nTArray<Point> GeometryRandom::pointsInGeneralPosition(\n        int n,\n   \
    \     long long X1, long long Y1,\n        long long X2, long long Y2)\n{\n  \
    \  struct Line {\n        long long A, B, C; // Ax + By + C = 0\n        Line()\
    \ {}\n        Line(const Point& p1, const Point& p2) {\n            A = p1.y -\
    \ p2.y;\n            B = p2.x - p1.x;\n            C = -(p1.x * A + p1.y * B);\n\
    \n            ENSURE(A != 0 || B != 0);\n\n            long long g = util::gcd(A,\
    \ util::gcd(B, C));\n            A /= g;\n            B /= g;\n            C /=\
    \ g;\n            if (A < 0 || (A == 0 && B < 0)) {\n                A = -A;\n\
    \                B = -B;\n                C = -C;\n            }\n        }\n\n\
    \        bool operator<(const Line& other) const {\n            return std::tie(A,\
    \ B, C) < std::tie(other.A, other.B, other.C);\n        }\n    };\n\n    const\
    \ long long LIMIT = 2e9;\n    ensure(\n        std::abs(X2 - X1) <= LIMIT && X1\
    \ <= LIMIT && X2 <= LIMIT &&\n            std::abs(Y2 - Y1) <= LIMIT && Y1 <=\
    \ LIMIT && Y2 <= LIMIT,\n        \"rndg.pointsInGeneralPosition must not be called\
    \ with coordinates \"\n        \"larger than 2e9\");\n\n    std::set<Line> lines;\n\
    \    std::unordered_set<Point> points;\n\n    TArray<Point> res;\n\n    while\
    \ (static_cast<int>(res.size()) != n) {\n        Point p = point(X1, Y1, X2, Y2);\n\
    \n        if (points.count(p)) {\n            continue;\n        }\n\n       \
    \ if (std::none_of(\n                res.begin(),\n                res.end(),\n\
    \                [&lines, &p] (const Point& q) {\n                    return lines.count(Line(p,\
    \ q));\n                }))\n        {\n            points.insert(p);\n      \
    \      for (const auto& q: res) {\n                lines.emplace(p, q);\n    \
    \        }\n            res.push_back(p);\n        }\n    }\n    return res;\n\
    }\n\n} // namespace jngen\n#undef JNGEN_INCLUDE_GEOMETRY_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\
    \n\n#include <algorithm>\n#include <utility>\n\nnamespace jngen {\n\nclass QueryBuilder\
    \ {\npublic:\n    QueryBuilder() {}\n\n    QueryBuilder(int n);\n    QueryBuilder(int\
    \ l, int r);\n\n    QueryBuilder& minLen(int value);\n    QueryBuilder& maxLen(int\
    \ value);\n    QueryBuilder& range(int n);\n    QueryBuilder& range(int l, int\
    \ r);\n    QueryBuilder& small();\n    QueryBuilder& large();\n    QueryBuilder&\
    \ ordered(bool value);\n\n    std::pair<int, int> next();\n    Arrayp next(int\
    \ m);\n\nprivate:\n    enum class QueryType {\n        Default, Large, Small\n\
    \    };\n\n    QueryType queryType_ = QueryType::Default;\n\n    std::pair<int,\
    \ int> range_; // half-interval\n    std::pair<int, int> lenRange_; // segment\n\
    \    bool ordered_;\n};\n\n#ifndef JNGEN_DECLARE_ONLY\n\nQueryBuilder::QueryBuilder(int\
    \ n) :\n    QueryBuilder(0, n - 1)\n{  }\n\nQueryBuilder::QueryBuilder(int l,\
    \ int r) :\n    range_(l, r + 1),\n    lenRange_(1, r - l + 1),\n    ordered_(true)\n\
    {\n    ensure(l <= r);\n}\n\nQueryBuilder& QueryBuilder::minLen(int value) {\n\
    \    lenRange_.first = value;\n    return *this;\n}\n\nQueryBuilder& QueryBuilder::maxLen(int\
    \ value) {\n    lenRange_.second = value;\n    return *this;\n}\n\nQueryBuilder&\
    \ QueryBuilder::range(int n) {\n    ensure(n > 0);\n    return this->range(0,\
    \ n - 1);\n}\n\nQueryBuilder& QueryBuilder::range(int l, int r) {\n    ensure(l\
    \ <= r);\n    range_ = {l, r+1};\n    lenRange_.second = std::min(lenRange_.second,\
    \ r - l + 1);\n    lenRange_.first = std::min(lenRange_.first, lenRange_.second);\n\
    \    return *this;\n}\n\nQueryBuilder& QueryBuilder::small() {\n    queryType_\
    \ = QueryType::Small;\n    return *this;\n}\n\nQueryBuilder& QueryBuilder::large()\
    \ {\n    queryType_ = QueryType::Large;\n    return *this;\n}\n\nQueryBuilder&\
    \ QueryBuilder::ordered(bool value) {\n    ordered_ = value;\n    return *this;\n\
    }\n\nstd::pair<int, int> QueryBuilder::next() {\n    switch (queryType_) {\n \
    \   case QueryType::Default: {\n        // This is inaccurate to say the least.\
    \ I don't know how to\n        // generate a random segment with length from l\
    \ to r without\n        // calling sqrt.\n        int len = rnd.wnext(lenRange_.first,\
    \ lenRange_.second, -1);\n        int l = rnd.next(range_.first, range_.second\
    \ - len);\n        if (ordered_ || rnd.next(2)) {\n            return {l, l +\
    \ len - 1};\n        } else {\n            return {l + len - 1, l};\n        }\n\
    \    }\n    case QueryType::Large: {\n        ENSURE(false, \"not implemented\"\
    );\n        break;\n    }\n    case QueryType::Small: {\n        ENSURE(false,\
    \ \"not implemented\");\n        break;\n    }\n    default: ENSURE(false, \"\
    Nonexistent option\");\n    }\n}\n\nArrayp QueryBuilder::next(int m) {\n    return\
    \ rnda.randomf(m, [this]() { return next(); });\n}\n\n#endif\n\ntemplate<typename\
    \ ... Args>\nQueryBuilder rndq(Args... args) {\n    return QueryBuilder(args...);\n\
    }\n\n} // namespace jngen\n\nusing jngen::rndq;\n\n\n#include <algorithm>\n#include\
    \ <cmath>\n#include <map>\n#include <set>\n#include <string>\n#include <utility>\n\
    #include <vector>\n\nnamespace jngen {\n\ntypedef std::pair<long long, long long>\
    \ HashBase; // (mod, base)\ntypedef std::pair<std::string, std::string> StringPair;\n\
    \nclass StringRandom {\npublic:\n    StringRandom() {\n        static bool created\
    \ = false;\n        ENSURE(!created, \"jngen::StringRandom should be created only\
    \ once\");\n        created = true;\n    }\n\n    static std::string random(int\
    \ len, const std::string& alphabet = \"a-z\");\n\n    template<typename ... Args>\n\
    \    static std::string random(const std::string& pattern, Args... args) {\n \
    \       return rnd.next(pattern, std::forward(args)...);\n    }\n\n    static\
    \ std::string thueMorse(int len, char first = 'a', char second = 'b');\n\n   \
    \ static std::string abacaba(int len, char first = 'a');\n\n    static StringPair\
    \ antiHash(\n            const std::vector<HashBase>& bases,\n            const\
    \ std::string& alphabet = \"a-z\",\n            int length = -1);\n};\n\nJNGEN_EXTERN\
    \ StringRandom rnds;\n\n} // namespace jngen\n\nusing jngen::rnds;\n\n#ifndef\
    \ JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_RNDS_INL_H\n#ifndef JNGEN_INCLUDE_RNDS_INL_H\n\
    #error File \"rnds_inl.h\" must not be included directly.\n#endif\n\nnamespace\
    \ jngen {\n\nnamespace detail {\n\nint popcount(long long x) {\n    int res =\
    \ 0;\n    while (x) {\n        ++res;\n        x &= x-1;\n    }\n    return res;\n\
    }\n\nint trailingZeroes(long long x) {\n    int res = 0;\n    ENSURE(x != 0);\n\
    \    while (!(x&1)) {\n        ++res;\n        x >>= 1;\n    }\n    return res;\n\
    }\n\nstd::string parseAllowedChars(std::string pattern) {\n    std::string result;\n\
    \    pattern += \"\\0\\0\";\n    for (size_t i = 0; i < pattern.length(); ++i)\
    \ {\n        if (pattern[i] == '-') {\n            result += '-';\n        } else\
    \ if (pattern[i+1] == '-' && pattern[i+2] != '\\0') {\n            for (char c\
    \ = pattern[i]; c <= pattern[i+2]; ++c) {\n                result += c;\n    \
    \        }\n            i += 2;\n        } else {\n            result += pattern[i];\n\
    \        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n\
    }\n\nstd::vector<std::string> extendAntiHash(\n        const std::vector<std::string>&\
    \ chars,\n        HashBase base,\n        int count)\n{\n    ENSURE(count == 2,\
    \ \"Count != 2 is not supported (yet)\");\n\n    size_t baseLength = chars[0].size();\n\
    \    for (const auto& s: chars) {\n        ensure(s.size() == baseLength);\n \
    \   }\n\n    long long mod = base.first;\n    long long p = base.second;\n\n \
    \   long long pPower = 1;\n    for (size_t i = 0; i != baseLength; ++i) {\n  \
    \      pPower = (pPower * p) % mod;\n    }\n\n    std::vector<long long> charHashes;\n\
    \    for (const auto& s: chars) {\n        long long hash = 0;\n        for (char\
    \ c: s) {\n            hash = (hash * p + c) % mod;\n        }\n        charHashes.push_back(hash);\n\
    \    }\n\n    auto computeHash = [&charHashes, mod, pPower](const std::vector<int>&\
    \ a) {\n        long long hash = 0;\n        for (int x: a) {\n            hash\
    \ = (hash * pPower + charHashes[x]) % mod;\n        }\n        return hash;\n\
    \    };\n\n    // This bounds were achieved empirically and should be justified.\n\
    \    int needForMatch;\n    if (count == 2) {\n        needForMatch = 5 * pow(double(mod),\
    \ 0.5);\n    } else {\n        ENSURE(false, \"Only count = 2 is supported yet\"\
    );\n    }\n\n    int length = 2;\n    double wordCount = pow(double(chars.size()),\
    \ double(length));\n\n    while (true) {\n        ++length;\n        wordCount\
    \ *= chars.size();\n        if (wordCount < needForMatch) {\n            continue;\n\
    \        }\n\n        std::vector<std::pair<long long, Array>> words;\n      \
    \  std::map<long long, int> hashCount;\n        std::set<Array> used;\n\n    \
    \    for (int i = 0; i < needForMatch; ++i) {\n            Array w = Array::random(length,\
    \ chars.size());\n            if (used.count(w)) {\n                --i;\n   \
    \             continue;\n            }\n            used.insert(w);\n        \
    \    long long hash = computeHash(w);\n            words.emplace_back(hash, w);\n\
    \            if (++hashCount[hash] == count) {\n                std::vector<std::string>\
    \ result;\n                for (const auto& kv: words) {\n                   \
    \ if (kv.first == hash) {\n                        std::string word;\n       \
    \                 for (int c: kv.second) {\n                            word +=\
    \ chars[c];\n                        }\n                        result.push_back(word);\n\
    \                    }\n                }\n                return result;\n  \
    \          }\n        }\n    }\n}\n\nStringPair minimalAntiHashTest(\n       \
    \ std::vector<HashBase> bases,\n        const std::string allowedChars)\n{\n \
    \   for (auto base: bases) {\n        ensure(base.first >= 0, \"0 < MOD must hold\"\
    );\n        ensure(\n            base.first <= (long long)(2e9),\n           \
    \ \"Modules larger than 2'000'000'000 are not supported yet\");\n        ensure(\n\
    \            0 < base.second && base.second < base.first,\n            \"0 <=\
    \ P < MOD must hold\");\n    }\n\n    std::vector<int> counts;\n    if (bases.size()\
    \ == 1) {\n        counts = {2};\n    } else if (bases.size() == 2) {\n      \
    \  counts = {2, 2};\n    } else {\n        counts.assign(bases.size(), 2);\n \
    \   }\n\n    std::vector<std::string> cur;\n    for (char c: allowedChars) {\n\
    \        cur.emplace_back(1, c);\n    }\n\n    for (size_t i = 0; i != bases.size();\
    \ ++i) {\n        cur = extendAntiHash(cur, bases[i], counts[i]);\n        ensure(static_cast<int>(cur.size())\
    \ == counts[i],\n            \"Cannot generate long enough pair with same hash\"\
    );\n    }\n\n    return {cur[0], cur[1]};\n}\n\n} // namespace detail\n\n\nstd::string\
    \ StringRandom::random(int len, const std::string& alphabet) {\n    checkLargeParameter(len);\n\
    \    std::string chars = detail::parseAllowedChars(alphabet);\n    std::string\
    \ res;\n    res.reserve(len);\n    for (int i = 0; i < len; ++i) {\n        res\
    \ += choice(chars);\n    }\n    return res;\n}\n\nstd::string StringRandom::thueMorse(int\
    \ len, char first, char second) {\n    ensure(len >= 0);\n    checkLargeParameter(len);\n\
    \    std::string res(len, ' ');\n    for (int i = 0; i < len; ++i) {\n       \
    \ res[i] = detail::popcount(i)%2 == 0 ? first : second;\n    }\n    return res;\n\
    }\n\nstd::string StringRandom::abacaba(int len, char first) {\n    ensure(len\
    \ >= 0);\n    checkLargeParameter(len);\n    std::string res(len, ' ');\n    for\
    \ (int i = 0; i < len; ++i) {\n        res[i] = first + detail::trailingZeroes(~i);\n\
    \    }\n    return res;\n}\n\nStringPair StringRandom::antiHash(\n        const\
    \ std::vector<HashBase>& bases,\n        const std::string& alphabet,\n      \
    \  int length)\n{\n    checkLargeParameter(length);\n    std::string allowedChars\
    \ = detail::parseAllowedChars(alphabet);\n    StringPair result = detail::minimalAntiHashTest(bases,\
    \ allowedChars);\n\n    if (length == -1) {\n        return result;\n    }\n\n\
    \    ensure(\n        static_cast<int>(result.first.length()) <= length,\n   \
    \     \"Cannot generate enough long anti-hash test\");\n\n    int extraLength\
    \ = length - result.first.length();\n    int leftSize = rnd.next(0, extraLength);\n\
    \n    std::string left = rnd.next(format(\"[%s]{%d}\", alphabet.c_str(), leftSize));\n\
    \    std::string right =\n        rnd.next(format(\"[%s]{%d}\", alphabet.c_str(),\
    \ extraLength - leftSize));\n\n    return {\n        left + result.first + right,\n\
    \        left + result.second + right\n    };\n}\n\n} // namespace jngen\n#undef\
    \ JNGEN_INCLUDE_RNDS_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#include <algorithm>\n\
    #include <functional>\n#include <iostream>\n#include <iterator>\n#include <string>\n\
    #include <unordered_set>\n#include <vector>\n\nnamespace jngen {\nnamespace suites\
    \ {\n\n#define JNGEN_ADD_PRODUCER(...)\\\n    {\\\n        std::string name =\
    \ #__VA_ARGS__;\\\n        if (name.empty()) {\\\n            name = format(\"\
    noname%d\", (int)names_.size());\\\n        }\\\n        if (std::find(names_.begin(),\
    \ names_.end(), name) != names_.end()) {\\\n            ENSURE(false, format(\"\
    Duplicated test name: '%s'\", name.c_str()));\\\n        }\\\n        names_.emplace_back(name);\\\
    \n    }\\\n    *std::back_inserter(producers_) = [this] (JNGEN_PRODUCER_ARGS)\
    \ -> value_type\n\ntemplate<typename T, typename Traits, typename ... Args>\n\
    class BaseTestSuite {\npublic:\n    explicit BaseTestSuite(const std::string&\
    \ name) : name_(name) {  }\n\n    BaseTestSuite(const BaseTestSuite&) = delete;\n\
    \    BaseTestSuite& operator=(const BaseTestSuite&) = delete;\n\n    size_t size()\
    \ const {\n        return producers_.size();\n    }\n\n    TArray<std::string>\
    \ names() const {\n        return names_;\n    }\n\n    T gen(size_t id, Args...\
    \ args) const {\n        ensure(\n            id < producers_.size(),\n      \
    \      format(\"Cannot generate test #%d in suite '%s', there are only \"\n  \
    \              \"%d\", (int)id, name_.c_str(), (int)producers_.size()));\n   \
    \     return producers_[id](args...);\n    }\n\n    T gen(const std::string& name,\
    \ Args... args) const {\n        size_t pos = std::find(names_.begin(), names_.end(),\
    \ name)\n            - names_.begin();\n        ensure(\n            pos < names_.size(),\n\
    \            format(\"There is no test '%s' in suite '%s'\",\n               \
    \ name.c_str(), name_.c_str()));\n        return gen(pos, args...);\n    }\n\n\
    \    TArray<T> genMany(size_t count, Args... args) const {\n        ensure(\n\
    \            count <= producers_.size(),\n            format(\"Cannot generate\
    \ %d tests in suite '%s', there are only \"\n                \"%d\", (int)count,\
    \ name_.c_str(), (int)producers_.size()));\n\n        TArray<T> result;\n    \
    \    result.reserve(count);\n        for (size_t id = 0; id < count; ++id) {\n\
    \            try {\n                result.push_back(gen(id, args...));\n    \
    \        } catch (...) {\n                std::cerr << \"Cannot generate test\
    \ #\" << id << \" of suite \"\n                    << name_ << \"\\n\";\n    \
    \        }\n        }\n\n        return result;\n    }\n\n    Traits& conf() {\
    \ return conf_; }\n\nprotected:\n    using Producer = std::function<T(Args...)>;\n\
    \    using value_type = T;\n\n    std::vector<Producer> producers_;\n    std::vector<std::string>\
    \ names_;\n\n    Traits conf_;\n\nprivate:\n    std::string name_;\n};\n\n}} //\
    \ namespace jngen::suites\n\n\n#include <algorithm>\n#include <cstdio>\n#include\
    \ <cstdlib>\n\nnamespace jngen {\n\ninline int getInitialTestNo() {\n    char\
    \ *envvar = std::getenv(\"TESTNO\");\n    int testno;\n    if (!envvar || 1 !=\
    \ std::sscanf(envvar, \"%d\", &testno)) {\n        return 1;\n    }\n    return\
    \ testno;\n}\n\n#ifdef JNGEN_DECLARE_ONLY\nextern int nextTestNo;\n#else\nint\
    \ nextTestNo = -1;\n#endif // JNGEN_DECLARE_ONLY\n\nvoid startTest(int testNo);\n\
    \nvoid startTest();\n\nvoid setNextTestNumber(int testNo);\n\nArray64 randomTestSizes(\n\
    \    long long totalSize,\n    int count,\n    long long minSize,\n    long long\
    \ maxSize,\n    const Array64& predefined);\n\nArray randomTestSizes(\n    int\
    \ totalSize,\n    int count,\n    int minSize,\n    int maxSize,\n    const Array&\
    \ predefined);\n\n#ifndef JNGEN_DECLARE_ONLY\n\nvoid startTest(int testNo) {\n\
    \    nextTestNo = testNo + 1;\n    char filename[10];\n    std::sprintf(filename,\
    \ \"%d\", testNo);\n    if (!std::freopen(filename, \"w\", stdout)) {\n      \
    \  ensure(false, format(\"Cannot open the file `%s'\", filename));\n    }\n}\n\
    \nvoid startTest() {\n    if (nextTestNo == -1) {\n        nextTestNo = getInitialTestNo();\n\
    \    }\n\n    startTest(nextTestNo);\n}\n\nvoid setNextTestNumber(int testNo)\
    \ {\n    nextTestNo = testNo;\n}\n\nArray64 randomTestSizes(\n    long long totalSize,\n\
    \    int count,\n    long long minSize,\n    long long maxSize,\n    const Array64&\
    \ predefined)\n{\n    for (auto x: predefined) {\n        totalSize -= x;\n  \
    \  }\n    ensure(totalSize >= 0, \"Sum of predefined test sizes exceeds total\
    \ size\");\n    ensure(count * minSize <= totalSize, \"minSize is too large\"\
    );\n    ensure(count * maxSize >= totalSize, \"maxSize is too small\");\n    ensure(minSize\
    \ <= maxSize);\n\n    return (rndm.partition(totalSize, count, minSize, maxSize)\
    \ +\n            predefined).shuffle();\n}\n\nArray randomTestSizes(\n    int\
    \ totalSize,\n    int count,\n    int minSize,\n    int maxSize,\n    const Array&\
    \ predefined)\n{\n    return arrayCast<int>(randomTestSizes(\n        static_cast<long\
    \ long>(totalSize),\n        count,\n        static_cast<long long>(minSize),\n\
    \        static_cast<long long>(maxSize),\n        arrayCast<long long>(predefined)\n\
    \    ));\n}\n\n#endif // JNGEN_DECLARE_ONLY\n\n} // namespace jngen\n\nusing jngen::startTest;\n\
    using jngen::setNextTestNumber;\n\nusing jngen::randomTestSizes;\n\n\n#include\
    \ <iostream>\n#include <stdexcept>\n#include <type_traits>\n\nnamespace jngen\
    \ {\n\nnamespace variant_detail {\n\nconstexpr static int NO_TYPE = -1;\n\ntemplate<size_t\
    \ Size, size_t Align, typename ... Args>\nclass VariantImpl;\n\ntemplate<size_t\
    \ Size, size_t Align>\nclass VariantImpl<Size, Align> {\npublic:\n    VariantImpl()\
    \ {\n        type_ = NO_TYPE;\n    }\n\nprivate:\n    alignas(Align) char data_[Size];\n\
    \    int type_;\n\nprotected:\n    int& type() { return type_; }\n    int type()\
    \ const { return type_; }\n\n    char* data() { return data_; }\n    const char*\
    \ data() const { return data_; }\n\n    void doDestroy() {\n        throw;\n \
    \   }\n\n    template<typename P>\n    constexpr static int typeId() {\n     \
    \   return NO_TYPE;\n    }\n\n    void copy(char*) const {\n        throw;\n \
    \   }\n\n    void move(char*) const {\n        throw;\n    }\n\n    void setType(int)\
    \ {\n        throw;\n    }\n\n    template<typename V>\n    typename V::return_type\
    \ applyVisitor(V&&) const {\n        throw;\n    }\n\n    void assign() {}\n};\n\
    \ntemplate<size_t Size, size_t Align, typename T, typename ... Args>\nclass VariantImpl<Size,\
    \ Align, T, Args...> : public VariantImpl<\n        (sizeof(T) > Size ? sizeof(T)\
    \ : Size),\n        (alignof(T) > Align ? alignof(T) : Align),\n        Args...\n\
    \    >\n{\n    using Base = VariantImpl<\n        (sizeof(T) > Size ? sizeof(T)\
    \ : Size),\n        (alignof(T) > Align ? alignof(T) : Align),\n        Args...\n\
    \    >;\n\n    constexpr static int MY_ID = sizeof...(Args);\n\nprotected:\n \
    \   void doDestroy() {\n        if (this->type() == MY_ID) {\n            this->type()\
    \ = NO_TYPE;\n            reinterpret_cast<T*>(this->data())->~T();\n        }\
    \ else {\n            Base::doDestroy();\n        }\n    }\n\n    template<typename\
    \ P>\n    constexpr static int typeId() {\n        return std::is_same<P, T>::value\
    \ ?\n            MY_ID :\n            Base::template typeId<P>();\n    }\n\n \
    \   void copy(char* dst) const {\n        if (this->type() == MY_ID) {\n     \
    \       new(dst) T(*reinterpret_cast<const T*>(this->data()));\n        } else\
    \ {\n            Base::copy(dst);\n        }\n    }\n\n    void move(char* dst)\
    \ const {\n        if (this->type() == MY_ID) {\n            new(dst) T(std::move(*reinterpret_cast<const\
    \ T*>(this->data())));\n        } else {\n            Base::copy(dst);\n     \
    \   }\n    }\n\n    void setType(int typeIndex) {\n        if (typeIndex == MY_ID)\
    \ {\n            if (this->type() != NO_TYPE) {\n                throw;\n    \
    \        }\n            assign(T{});\n        } else {\n            Base::setType(typeIndex);\n\
    \        }\n    }\n\n    template<typename V>\n    typename V::return_type applyVisitor(V&&\
    \ v) const {\n        if (this->type() == MY_ID) {\n            return v(*reinterpret_cast<const\
    \ T*>(this->data()));\n        } else {\n            return Base::applyVisitor(std::forward<V>(v));\n\
    \        }\n    }\n\n    using Base::assign;\n\n    void assign(const T& t) {\n\
    \        if (this->type() == NO_TYPE) {\n            new(this->data()) T;\n  \
    \          this->type() = MY_ID;\n        }\n\n        ref() = t;\n    }\n\nprivate:\n\
    \    T& ref() { return *reinterpret_cast<T*>(this->data()); }\n\npublic:\n   \
    \ operator T() const {\n        if (this->type() == MY_ID) {\n            return\
    \ *reinterpret_cast<const T*>(this->data());\n        } else {\n            return\
    \ T();\n        }\n    }\n};\n\ntemplate<typename ... Args>\nclass Variant : public\
    \ VariantImpl<0, 1, Args...> {\n    using Base = VariantImpl<0, 1, Args...>;\n\
    \npublic:\n    Variant() { }\n\n    Variant(const Variant<Args...>& other) {\n\
    \        if (other.type() != NO_TYPE) {\n            other.copy(this->data());\n\
    \            unsafeType() = other.type();\n        }\n    }\n\n    Variant& operator=(const\
    \ Variant<Args...>& other) {\n        if (&other == this) {\n            return\
    \ *this;\n        }\n        if (this->type() != NO_TYPE) {\n            this->doDestroy();\n\
    \        }\n        if (other.type() != NO_TYPE) {\n            other.copy(this->data());\n\
    \            unsafeType() = other.type();\n        }\n        return *this;\n\
    \    }\n\n    Variant(Variant<Args...>&& other) {\n        if (other.type() !=\
    \ NO_TYPE) {\n            other.move(this->data());\n            unsafeType()\
    \ = other.type();\n        } else {\n            unsafeType() = other.type();\n\
    \        }\n    }\n\n    Variant& operator=(Variant<Args...>&& other) {\n    \
    \    if (&other == this) {\n            return *this;\n        }\n        if (this->type()\
    \ != NO_TYPE) {\n            this->doDestroy();\n        }\n        if (other.type()\
    \ != NO_TYPE) {\n            other.move(this->data());\n            unsafeType()\
    \ = other.type();\n        }\n        return *this;\n    }\n\n    ~Variant() {\n\
    \        if (type() != NO_TYPE) {\n            this->doDestroy();\n        }\n\
    \    }\n\n    template<typename T>\n    Variant(const T& t) : Variant() {\n  \
    \      this->assign(t);\n    }\n\n    template<typename T>\n    T& ref() {\n \
    \       return *ptr<T>();\n    }\n\n    template<typename T>\n    const T& cref()\
    \ const {\n        auto ptr = cptr<T>();\n        if (ptr == 0) {\n          \
    \  throw std::logic_error(\"jngen::Variant: taking a reference for\"\n       \
    \         \" a type which is not active now\");\n        }\n        return *ptr;\n\
    \    }\n\n    bool operator==(const Variant& v) const { return compareTo(v) ==\
    \ 0; }\n    bool operator!=(const Variant& v) const { return compareTo(v) != 0;\
    \ }\n    bool operator< (const Variant& v) const { return compareTo(v) <  0; }\n\
    \    bool operator> (const Variant& v) const { return compareTo(v) >  0; }\n \
    \   bool operator<=(const Variant& v) const { return compareTo(v) <= 0; }\n  \
    \  bool operator>=(const Variant& v) const { return compareTo(v) >= 0; }\n\n \
    \   template<typename V>\n    typename V::return_type applyVisitor(V&& v) const\
    \ {\n        return Base::applyVisitor(std::forward<V>(v));\n    }\n\n    int\
    \ type() const { return Base::type(); }\n\n    void setType(int typeIndex) {\n\
    \        if (typeIndex == NO_TYPE) {\n            throw std::logic_error(\"jngen::Variant::setType():\"\
    \n                \" calling with NO_TYPE is invalid\");\n        }\n        if\
    \ (this->type() == typeIndex) {\n            return;\n        }\n        if (this->type()\
    \ != NO_TYPE) {\n            this->doDestroy();\n        }\n        Base::setType(typeIndex);\n\
    \    }\n\n    bool empty() const { return Base::type() == NO_TYPE; }\n\n    template<typename\
    \ T>\n    constexpr static bool hasType() {\n        return Base::template typeId<T>()\
    \ != NO_TYPE;\n    }\n\nprivate:\n    template<typename T_>\n    decay_t<T_>*\
    \ ptr() {\n        using T = decay_t<T_>;\n        if (type() != this->template\
    \ typeId<T>()) {\n            if (type() != NO_TYPE) {\n                this->doDestroy();\n\
    \            }\n            ::new(this->data()) T;\n            unsafeType() =\
    \ this->template typeId<T>();\n        }\n        return reinterpret_cast<T*>(this->data());\n\
    \    }\n\n    template<typename T_>\n    const decay_t<T_>* cptr() const {\n \
    \       using T = decay_t<T_>;\n        if (type() != this->template typeId<T>())\
    \ {\n            return nullptr;\n        }\n        return reinterpret_cast<const\
    \ T*>(this->data());\n    }\n\n    int& unsafeType() {\n        return Base::type();\n\
    \    }\n\n    int compareTo(const Variant& other) const;\n};\n\nstruct OstreamVisitor\
    \ {\n    using return_type = void;\n\n    template<typename T>\n    void operator()(const\
    \ T& t) {\n        JNGEN_PRINT(t);\n    }\n    std::ostream& out;\n    const OutputModifier&\
    \ mod;\n};\n\ntemplate<typename V>\nstruct CompareToVisitor {\n    using return_type\
    \ = int;\n\n    template<typename T>\n    int operator()(const T& t) {\n     \
    \   if (t == variant.template cref<T>()) {\n            return 0;\n        }\n\
    \        return t < variant.template cref<T>() ? -1 : 1;\n    }\n\n    const V&\
    \ variant;\n};\n\ntemplate<typename ... Args>\nint Variant<Args...>::compareTo(const\
    \ Variant& other) const {\n    if (empty()) {\n        return other.empty() ?\
    \ 0 : -1;\n    }\n    if (other.empty()) {\n        return 1;\n    }\n\n    if\
    \ (type() != other.type()) {\n        return type() > other.type() ? -1 : 1;\n\
    \    }\n    return applyVisitor(CompareToVisitor<Variant>{other});\n\n}\n\n} //\
    \ namespace variant_detail\n\nusing variant_detail::Variant;\n\ntemplate<typename\
    \ ... Args>\nJNGEN_DECLARE_SIMPLE_PRINTER(Variant<Args...>, 5) {\n    if (t.type()\
    \ == jngen::variant_detail::NO_TYPE) {\n        out << \"{empty variant}\";\n\
    \    } else {\n        t.applyVisitor(jngen::variant_detail::OstreamVisitor{out,\
    \ mod});\n    }\n}\n\n} // namespace jngen\n\n\n#include <iterator>\n#include\
    \ <vector>\n#include <type_traits>\n\nnamespace jngen {\n\ntemplate<typename ...\
    \ Args>\nclass VariantArray : public GenericArray<Variant<Args...>> {\npublic:\n\
    \    using Base = GenericArray<Variant<Args...>>;\n    using BaseVariant = Variant<Args...>;\n\
    \n    using Base::Base;\n\n    VariantArray() {}\n\n    /* implicit */ VariantArray(const\
    \ Base& base) :\n            Base(base)\n    {  }\n\n    template<typename T,\
    \ typename = typename std::enable_if<\n        BaseVariant::template hasType<T>()>::type>\n\
    \    VariantArray(const std::vector<T>& other) {\n        std::copy(other.begin(),\
    \ other.end(), std::back_inserter(*this));\n    }\n\n    template<typename T,\
    \ typename = typename std::enable_if<\n        BaseVariant::template hasType<T>()>::type>\n\
    \    VariantArray(std::vector<T>&& other) {\n        std::move(other.begin(),\
    \ other.end(), std::back_inserter(*this));\n        GenericArray<T>().swap(other);\n\
    \    }\n\n    template<typename T, typename = typename std::enable_if<\n     \
    \   BaseVariant::template hasType<T>()>::type>\n    operator GenericArray<T>()\
    \ const\n    {\n        return GenericArray<T>(this->begin(), this->end());\n\
    \    }\n\n    bool hasNonEmpty() const {\n        for (const auto& x: *this) {\n\
    \            if (!x.empty()) {\n                return true;\n            }\n\
    \        }\n        return false;\n    }\n\n    int anyType() const {\n      \
    \  for (const auto& x: *this) {\n            if (!x.empty()) {\n             \
    \   return x.type();\n            }\n        }\n        return 0;\n    }\n\n};\n\
    \n} // namespace jngen\n\n#include <string>\n#include <utility>\n\n\nnamespace\
    \ jngen {\n\n#define JNGEN_DEFAULT_WEIGHT_TYPES int, double, std::string, char,\
    \ std::pair<int, int>\n\n#if defined(JNGEN_EXTRA_WEIGHT_TYPES)\n#define JNGEN_WEIGHT_TYPES\
    \ JNGEN_DEFAULT_WEIGHT_TYPES , JNGEN_EXTRA_WEIGHT_TYPES\n#else\n#define JNGEN_WEIGHT_TYPES\
    \ JNGEN_DEFAULT_WEIGHT_TYPES\n#endif\n\nusing Weight = Variant<JNGEN_WEIGHT_TYPES>;\n\
    using WeightArray = VariantArray<JNGEN_WEIGHT_TYPES>;\n\n} // namespace jngen\n\
    \nusing jngen::Weight;\nusing jngen::WeightArray;\n\n\n#include <algorithm>\n\
    #include <iostream>\n#include <iterator>\n#include <set>\n#include <utility>\n\
    #include <vector>\n\nnamespace jngen {\n\nclass GenericGraph {\npublic:\n    virtual\
    \ ~GenericGraph() {}\n\n    virtual int n() const { return adjList_.size(); }\n\
    \    virtual int m() const { return numEdges_; }\n\n    bool directed() const\
    \ { return directed_; }\n\n    // u, v: labels\n    virtual void addEdge(int u,\
    \ int v, const Weight& w = Weight{});\n    virtual bool isConnected() const {\
    \ return dsu_.isConnected(); }\n\n    virtual int vertexLabel(int v) const { return\
    \ vertexLabel_.at(v); }\n    virtual int vertexByLabel(int v) const { return vertexByLabel_.at(v);\
    \ }\n\n    // v: label\n    // return: array<label>\n    virtual Array edges(int\
    \ v) const;\n\n    // return: array<label, label>\n    virtual Arrayp edges()\
    \ const;\n\n    // order: by labels\n    // TODO: think about ordering here\n\
    \    virtual void setVertexWeights(const WeightArray& weights);\n    // v: label\n\
    \    virtual void setVertexWeight(int v, const Weight& weight);\n\n    virtual\
    \ void setEdgeWeights(const WeightArray& weights);\n    virtual void setEdgeWeight(size_t\
    \ index, const Weight& weight);\n\n    // v: label\n    virtual Weight vertexWeight(int\
    \ v) const;\n    virtual Weight edgeWeight(size_t index) const;\n\n    // TODO:\
    \ should it really be public?\n    virtual void doPrintEdges(\n        std::ostream&\
    \ out, const OutputModifier& mod) const;\n\n    virtual bool operator==(const\
    \ GenericGraph& other) const;\n    virtual bool operator!=(const GenericGraph&\
    \ other) const;\n    virtual bool operator< (const GenericGraph& other) const;\n\
    \    virtual bool operator> (const GenericGraph& other) const;\n    virtual bool\
    \ operator<=(const GenericGraph& other) const;\n    virtual bool operator>=(const\
    \ GenericGraph& other) const;\n\n    void initWithEdges(int n, const Arrayp& edges);\n\
    \nprotected:\n    static WeightArray prepareWeightArray(WeightArray a, int requiredSize);\n\
    \n    void doShuffle();\n    void doShuffleAllBut(const Array& except);\n    void\
    \ doShuffleEdges();\n\n    void extend(size_t size);\n\n    // v: vertex number\n\
    \    // returns: array<number>\n    Array internalEdges(int v) const;\n\n    //\
    \ u, v: vertex numbers\n    void addEdgeUnsafe(int u, int v);\n\n    // v: vertex\
    \ number\n    // returns: vertex number\n    int edgeOtherEnd(int v, int edgeId)\
    \ const;\n\n    void permuteEdges(const Array& order);\n\n    void normalizeEdges();\n\
    \n    int compareTo(const GenericGraph& other) const;\n\n    int numEdges_ = 0;\n\
    \n    bool directed_ = false;\n\n    Dsu dsu_;\n    std::vector<Array> adjList_;\n\
    \    Array vertexLabel_;\n    Array vertexByLabel_;\n    Arrayp edges_;\n\n  \
    \  WeightArray vertexWeights_;\n    WeightArray edgeWeights_;\n};\n\ntemplate<>\n\
    struct Hash<GenericGraph> {\n    uint64_t operator()(const GenericGraph& graph)\
    \ const {\n        uint64_t h = 0;\n        for (int i = 0; i < graph.n(); ++i)\
    \ {\n            impl::hashCombine(h, Hash<Array>{}(graph.edges(i)));\n      \
    \  }\n        return h;\n    }\n};\n\n} // namespace jngen\n\nJNGEN_DEFINE_STD_HASH(jngen::GenericGraph);\n\
    \n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_GENERIC_GRAPH_INL_H\n#ifndef\
    \ JNGEN_INCLUDE_GENERIC_GRAPH_INL_H\n#error File \"generic_graph_inl.h\" must\
    \ not be included directly.\n#endif\n\nnamespace jngen {\n\nvoid GenericGraph::setVertexWeights(const\
    \ WeightArray& weights) {\n    ensure(\n        static_cast<int>(weights.size())\
    \ == n(),\n        \"The argument of setVertexWeights must have exactly n elements\"\
    );\n    vertexWeights_.resize(n());\n    for (int i = 0; i < n(); ++i) {\n   \
    \     vertexWeights_[i] = weights[vertexByLabel(i)];\n    }\n}\n\nvoid GenericGraph::setVertexWeight(int\
    \ v, const Weight& weight) {\n    ensure(v < n(), \"setVertexWeight\");\n    v\
    \ = vertexByLabel(v);\n\n    vertexWeights_.extend(v + 1);\n    vertexWeights_[v]\
    \ = weight;\n}\n\nvoid GenericGraph::setEdgeWeights(const WeightArray& weights)\
    \ {\n    ensure(\n        static_cast<int>(weights.size()) == m(),\n        \"\
    The argument of setEdgeWeights must have exactly m elements\");\n    edgeWeights_\
    \ = weights;\n}\n\nvoid GenericGraph::setEdgeWeight(size_t index, const Weight&\
    \ weight) {\n    ensure(static_cast<int>(index) < m(), \"setEdgeWeight\");\n \
    \   edgeWeights_.extend(index + 1);\n    edgeWeights_[index] = weight;\n}\n\n\
    Weight GenericGraph::vertexWeight(int v) const {\n    ensure(v < n(), \"vertexWeight\"\
    );\n    size_t index = vertexByLabel(v);\n    if (index >= vertexWeights_.size())\
    \ {\n        return Weight{};\n    }\n    return vertexWeights_[index];\n}\n\n\
    Weight GenericGraph::edgeWeight(size_t index) const {\n    ensure(static_cast<int>(index)\
    \ < m(), \"edgeWeight\");\n    if (index >= edgeWeights_.size()) {\n        return\
    \ Weight{};\n    }\n    return edgeWeights_[index];\n}\n\nArray GenericGraph::edges(int\
    \ v) const {\n\n    ensure(v < n(), \"Graph::edges(v)\");\n    v = vertexByLabel(v);\n\
    \n    Array result = internalEdges(v);\n    for (auto& x: result) {\n        x\
    \ = vertexLabel(x);\n    }\n\n    return result;\n}\n\nArrayp GenericGraph::edges()\
    \ const {\n    auto edges = edges_;\n    for (auto& e: edges) {\n        e.first\
    \ = vertexLabel(e.first);\n        e.second = vertexLabel(e.second);\n    }\n\
    \    return edges;\n}\n\nWeightArray GenericGraph::prepareWeightArray(WeightArray\
    \ a, int requiredSize) {\n    ENSURE(a.hasNonEmpty(), \"Attempt to print empty\
    \ weight array\");\n\n    a.extend(requiredSize);\n    int type = a.anyType();\n\
    \    for (auto& x: a) {\n        if (x.empty()) {\n            x.setType(type);\n\
    \        }\n    }\n\n    return a;\n}\n\nvoid GenericGraph::doShuffle() {\n  \
    \  // this if is to be removed after all checks pass\n    if (vertexLabel_.size()\
    \ < static_cast<size_t>(n())) {\n        ENSURE(false, \"GenericGraph::doShuffle\"\
    );\n        vertexLabel_ = Array::id(n());\n    }\n\n    vertexLabel_.shuffle();\n\
    \    vertexByLabel_ = vertexLabel_.inverse();\n\n    doShuffleEdges();\n}\n\n\
    void GenericGraph::doShuffleAllBut(const Array& except) {\n    Array index = except.sorted();\n\
    \    Array needed = Array::id(n());\n    needed.erase(std::set_difference(\n \
    \               needed.begin(), needed.end(),\n                index.begin(),\
    \ index.end(),\n                needed.begin()), needed.end());\n    Array neededShuffled\
    \ = needed.shuffled();\n    Array perm = Array::id(n());\n    for (size_t i =\
    \ 0; i < needed.size(); ++i) {\n        perm[needed[i]] = neededShuffled[i];\n\
    \    }\n\n    vertexLabel_ = vertexLabel_.subseq(perm);\n    vertexByLabel_ =\
    \ vertexLabel_.inverse();\n\n    doShuffleEdges();\n}\n\nvoid GenericGraph::doShuffleEdges()\
    \ {\n    if (!directed_) {\n        for (auto& edge: edges_) {\n            if\
    \ (rnd.next(2)) {\n                std::swap(edge.first, edge.second);\n     \
    \       }\n        }\n    }\n\n    permuteEdges(Array::id(numEdges_).shuffled());\n\
    }\n\nvoid GenericGraph::extend(size_t size) {\n    checkLargeParameter(size);\n\
    \    size_t oldSize = n();\n    if (size > oldSize) {\n        adjList_.resize(size);\n\
    \        vertexLabel_ += Array::id(size - oldSize, oldSize);\n        vertexByLabel_\
    \ += Array::id(size - oldSize, oldSize);\n        dsu_.extend(size);\n    }\n\
    }\n\nArray GenericGraph::internalEdges(int v) const {\n    Array result;\n   \
    \ std::transform(\n        adjList_[v].begin(),\n        adjList_[v].end(),\n\
    \        std::back_inserter(result),\n        [this, v](int x) { return edgeOtherEnd(v,\
    \ x); }\n    );\n    return result;\n}\n\nvoid GenericGraph::addEdgeUnsafe(int\
    \ u, int v) {\n    int id = numEdges_++;\n    edges_.emplace_back(u, v);\n\n \
    \   ENSURE(u < n() && v < n(), \"GenericGraph::addEdgeUnsafe\");\n\n    adjList_[u].push_back(id);\n\
    \    if (!directed_ && u != v) {\n        adjList_[v].push_back(id);\n    }\n\
    }\n\nint GenericGraph::edgeOtherEnd(int v, int edgeId) const {\n    ENSURE(edgeId\
    \ < numEdges_);\n    const auto& edge = edges_[edgeId];\n    if (edge.first ==\
    \ v) {\n        return edge.second;\n    }\n    ENSURE(!directed_);\n    ENSURE(edge.second\
    \ == v);\n    return edge.first;\n}\n\nvoid GenericGraph::permuteEdges(const Array&\
    \ order) {\n    ENSURE(static_cast<int>(order.size()) == m(), \"GenericGraph::permuteEdges\"\
    );\n\n    edges_ = edges_.subseq(order);\n\n    auto newByOld = order.inverse();\n\
    \    for (int v = 0; v < n(); ++v) {\n        for (auto& x: adjList_[v]) {\n \
    \           x = newByOld[x];\n        }\n    }\n\n    if (edgeWeights_.hasNonEmpty())\
    \ {\n        edgeWeights_.extend(m());\n        edgeWeights_ = edgeWeights_.subseq(order);\n\
    \    }\n}\n\nvoid GenericGraph::addEdge(int u, int v, const Weight& w) {\n   \
    \ extend(std::max(u, v) + 1);\n\n    u = vertexByLabel(u);\n    v = vertexByLabel(v);\n\
    \n    dsu_.unite(u, v);\n    addEdgeUnsafe(u, v);\n\n    if (!w.empty()) {\n \
    \       setEdgeWeight(m() - 1, w);\n    }\n}\n\nvoid GenericGraph::doPrintEdges(\n\
    \    std::ostream& out, const OutputModifier& mod) const\n{\n    bool pendingEndline\
    \ = false;\n    if (mod.printN) {\n        out << n();\n        if (mod.printM)\
    \ {\n            out << \" \" << m();\n        }\n        pendingEndline = true;\n\
    \    } else if (mod.printM) {\n        out << m();\n        pendingEndline = true;\n\
    \    }\n\n    if (n() == 0) {\n        return;\n    }\n\n    if (vertexWeights_.hasNonEmpty())\
    \ {\n        auto vertexWeights = prepareWeightArray(vertexWeights_, n());\n \
    \       if (pendingEndline) {\n            out << \"\\n\";\n        }\n      \
    \  for (int i = 0; i < n(); ++i) {\n            if (i > 0) {\n               \
    \ out << \" \";\n            }\n            JNGEN_PRINT_NO_MOD(vertexWeights[vertexByLabel(i)]);\n\
    \        }\n        pendingEndline = true;\n    }\n\n    if (m() == 0) {\n   \
    \     return;\n    }\n\n    if (pendingEndline) {\n        out << \"\\n\";\n \
    \   }\n\n    auto t(mod);\n    {\n        auto mod(t);\n\n        Arrayp edges\
    \ = this->edges();\n        mod.printN = false;\n        if (edgeWeights_.hasNonEmpty())\
    \ {\n            auto edgeWeights = prepareWeightArray(edgeWeights_, m());\n \
    \           for (int i = 0; i < m(); ++i) {\n                if (i > 0) {\n  \
    \                  out << \"\\n\";\n                }\n                JNGEN_PRINT(edges[i]);\n\
    \                out << \" \";\n                JNGEN_PRINT_NO_MOD(edgeWeights[i]);\n\
    \            }\n        } else {\n            JNGEN_PRINT(edges);\n        }\n\
    \    }\n}\n\nbool GenericGraph::operator==(const GenericGraph& other) const {\n\
    \    return compareTo(other) == 0;\n}\n\nbool GenericGraph::operator!=(const GenericGraph&\
    \ other) const {\n    return compareTo(other) != 0;\n}\n\nbool GenericGraph::operator<(const\
    \ GenericGraph& other) const {\n    return compareTo(other) == -1;\n}\n\nbool\
    \ GenericGraph::operator>(const GenericGraph& other) const {\n    return compareTo(other)\
    \ == 1;\n}\n\nbool GenericGraph::operator<=(const GenericGraph& other) const {\n\
    \    return compareTo(other) != 1;\n}\n\nbool GenericGraph::operator>=(const GenericGraph&\
    \ other) const {\n    return compareTo(other) != -1;\n}\n\nvoid GenericGraph::normalizeEdges()\
    \ {\n    if (!config.normalizeEdges) {\n        return;\n    }\n    ENSURE(\n\
    \        vertexLabel_ == Array::id(n()),\n        \"Can call normalizeEdges()\
    \ only on newly created graph\");\n\n    if (!directed_) {\n        for (auto&\
    \ edge: edges_) {\n            if (edge.first > edge.second) {\n             \
    \   std::swap(edge.first, edge.second);\n            }\n        }\n    }\n\n \
    \   auto order = Array::id(numEdges_).sorted(\n        [this](int i, int j) {\n\
    \            return edges_[i] < edges_[j];\n        });\n\n    permuteEdges(order);\n\
    }\n\nint GenericGraph::compareTo(const GenericGraph& other) const {\n    if (n()\
    \ != other.n()) {\n        return n() < other.n() ? -1 : 1;\n    }\n    for (int\
    \ i = 0; i < n(); ++i) {\n        auto e1 = edges(i).sorted();\n        auto e2\
    \ = other.edges(i).sorted();\n        if (e1 != e2) {\n            return e1 <\
    \ e2 ? -1 : 1;\n        }\n    }\n    return 0;\n}\n\nvoid GenericGraph::initWithEdges(int\
    \ n, const Arrayp& edges) {\n    ENSURE(this->n() == 0, \"Can call initWithEdges\
    \ only on empty graph\");\n    extend(n);\n\n    edges_ = edges;\n    numEdges_\
    \ = edges.size();\n\n\n    Array degree(n);\n    for (const auto& edge: edges)\
    \ {\n        ++degree[edge.first];\n        if (!directed_ && edge.first != edge.second)\
    \ {\n            ++degree[edge.second];\n        }\n\n        dsu_.unite(edge.first,\
    \ edge.second);\n    }\n    for (int i = 0; i < n; ++i) {\n        adjList_[i].reserve(degree[i]);\n\
    \    }\n    for (size_t id = 0; id != edges.size(); ++id) {\n        const auto&\
    \ edge = edges[id];\n        adjList_[edge.first].push_back(id);\n        if (!directed_\
    \ && edge.first != edge.second) {\n            adjList_[edge.second].push_back(id);\n\
    \        }\n    }\n\n    normalizeEdges();\n}\n\n} // namespace jngen\n#undef\
    \ JNGEN_INCLUDE_GENERIC_GRAPH_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#include\
    \ <algorithm>\n#include <vector>\n\nnamespace jngen {\n\nclass Tree : public ReprProxy<Tree>,\
    \ public GenericGraph {\npublic:\n    Tree() {\n        extend(1);\n    }\n\n\
    \    Tree(const GenericGraph& gg) : GenericGraph(gg) {\n        extend(1);\n \
    \       ensure(\n                dsu_.numComponents() == n() - m(),\n        \
    \        \"Cannot create a tree from a graph with cycles\");\n    }\n\n    void\
    \ addEdge(int u, int v, const Weight& w = Weight{}) override;\n\n    bool canAddEdge(int\
    \ u, int v);\n\n    Array parents(int root) const;\n\n    Tree& shuffle();\n \
    \   Tree shuffled() const;\n    Tree& shuffleAllBut(const Array& except);\n  \
    \  Tree shuffledAllBut(const Array& except) const;\n\n    Tree link(int vInThis,\
    \ const Tree& other, int vInOther);\n    Tree glue(int vInThis, const Tree& other,\
    \ int vInOther);\n\n    static Tree bamboo(int size);\n    static Tree random(int\
    \ size);\n    static Tree randomPrim(int size, int elongation = 0);\n    static\
    \ Tree randomKruskal(int size);\n    static Tree star(int size);\n    static Tree\
    \ caterpillar(int size, int length);\n    static Tree binary(int size);\n    static\
    \ Tree kary(int size, int k);\n\n    static Tree fromPruferSequence(const Array&\
    \ code);\n\n    void doPrintParents(std::ostream& out, const OutputModifier& mod)\
    \ const;\n};\n\nJNGEN_DECLARE_SIMPLE_PRINTER(Tree, 2) {\n    ensure(t.isConnected(),\
    \ \"Cannot print a tree: it is not connected\");\n\n    if (mod.printEdges) {\n\
    \        t.doPrintEdges(out, mod);\n    } else {\n        t.doPrintParents(out,\
    \ mod);\n    }\n}\n\ntemplate<>\nstruct Hash<Tree> {\n    uint64_t operator()(const\
    \ Tree& t) const {\n        return Hash<GenericGraph>{}(t);\n    }\n};\n\n} //\
    \ namespace jngen\n\nJNGEN_DEFINE_STD_HASH(jngen::Tree);\n\nusing jngen::Tree;\n\
    \n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_TREE_INL_H\n#ifndef JNGEN_INCLUDE_TREE_INL_H\n\
    #error File \"tree_inl.h\" must not be included directly.\n#endif\n\nvoid Tree::addEdge(int\
    \ u, int v, const Weight& w) {\n    extend(std::max(u, v) + 1);\n\n    u = vertexByLabel(u);\n\
    \    v = vertexByLabel(v);\n\n    int ret = dsu_.unite(u, v);\n    ensure(ret,\
    \ \"A cycle appeared in the tree\");\n\n    addEdgeUnsafe(u, v);\n\n    if (!w.empty())\
    \ {\n        setEdgeWeight(m() - 1, w);\n    }\n}\n\nbool Tree::canAddEdge(int\
    \ u, int v) {\n    u = vertexByLabel(u);\n    v = vertexByLabel(v);\n    return\
    \ dsu_.getRoot(u) != dsu_.getRoot(v);\n}\n\nArray Tree::parents(int root) const\
    \ {\n    ensure(isConnected(), \"Tree::parents(int): Tree is not connected\");\n\
    \    root = vertexByLabel(root);\n\n    Array parents(n());\n    parents[root]\
    \ = -1;\n    std::vector<int> used(n());\n    std::vector<int> queue{root};\n\
    \    for (size_t i = 0; i < queue.size(); ++i) {\n        int v = queue[i];\n\
    \        used[v] = true;\n        for (auto to: internalEdges(v)) {\n        \
    \    if (!used[to]) {\n                parents[to] = v;\n                queue.push_back(to);\n\
    \            }\n        }\n    }\n\n    for (auto& x: parents) {\n        if (x\
    \ != -1) {\n            x = vertexLabel(x);\n        }\n    }\n\n    return parents;\n\
    }\n\nTree& Tree::shuffle() {\n    doShuffle();\n    return *this;\n}\n\nTree Tree::shuffled()\
    \ const {\n    Tree t = *this;\n    return t.shuffle();\n}\n\nTree& Tree::shuffleAllBut(const\
    \ Array& except) {\n    doShuffleAllBut(except);\n    return *this;\n}\n\nTree\
    \ Tree::shuffledAllBut(const Array& except) const {\n    Tree g(*this);\n    return\
    \ g.shuffleAllBut(except);\n}\n\nTree Tree::link(int vInThis, const Tree& other,\
    \ int vInOther) {\n    ensure(vInThis < n(), \"Cannot link a nonexistent vertex\"\
    );\n    ensure(vInOther < other.n(), \"Cannot link to a nonexistent vertex\");\n\
    \n    Tree t(*this);\n\n    for (const auto& e: other.edges()) {\n        t.addEdge(e.first\
    \ + n(), e.second + n());\n    }\n\n    t.addEdge(vInThis, vInOther + n());\n\n\
    \    return t;\n}\n\nTree Tree::glue(int vInThis, const Tree& other, int vInOther)\
    \ {\n    ensure(vInThis < n(), \"Cannot glue a nonexistent vertex\");\n    ensure(vInOther\
    \ < other.n(), \"Cannot glue to a nonexistent vertex\");\n\n    auto newLabel\
    \ = [vInThis, vInOther, &other, this] (int v) {\n        if (v < vInOther) {\n\
    \            return n() + v;\n        } else if (v == vInOther) {\n          \
    \  return vInThis;\n        } else {\n            return n() + v - 1;\n      \
    \  }\n    };\n\n    Tree t(*this);\n\n    for (const auto& e: other.edges()) {\n\
    \        t.addEdge(newLabel(e.first), newLabel(e.second));\n    }\n\n    ensure(t.n()\
    \ == n() + other.n() - 1);\n\n    return t;\n}\n\n// Tree generators go here\n\
    \nTree Tree::bamboo(int size) {\n    ensure(size > 0, \"Number of vertices in\
    \ the tree must be positive\");\n    checkLargeParameter(size);\n    Tree t;\n\
    \    for (int i = 0; i + 1 < size; ++i) {\n        t.addEdge(i, i+1);\n    }\n\
    \    t.normalizeEdges();\n    return t;\n}\n\nTree Tree::random(int size) {\n\
    \    ensure(size > 0, \"Number of vertices in the tree must be positive\");\n\
    \    checkLargeParameter(size);\n    if (size == 1) {\n        return Tree();\n\
    \    }\n    return fromPruferSequence(Array::random(size - 2, size));\n}\n\nTree\
    \ Tree::randomPrim(int size, int elongation) {\n    ensure(size > 0, \"Number\
    \ of vertices in the tree must be positive\");\n    checkLargeParameter(size);\n\
    \    Tree t;\n    for (int v = 1; v < size; ++v) {\n        int parent = rnd.wnext(v,\
    \ elongation);\n        t.addEdge(parent, v);\n    }\n    t.normalizeEdges();\n\
    \    return t;\n}\n\nTree Tree::randomKruskal(int size) {\n    ensure(size > 0,\
    \ \"Number of vertices in the tree must be positive\");\n    checkLargeParameter(size);\n\
    \    Tree t;\n    t.extend(size);\n    while (!t.isConnected()) {\n        auto\
    \ e = rnd.nextp(size, dpair);\n        if (t.canAddEdge(e.first, e.second)) {\n\
    \            t.addEdge(e.first, e.second);\n        }\n    }\n    return t;\n\
    }\n\nTree Tree::star(int size) {\n    ensure(size > 0, \"Number of vertices in\
    \ the tree must be positive\");\n    checkLargeParameter(size);\n    Tree t;\n\
    \    for (int i = 1; i < size; ++i) {\n        t.addEdge(0, i);\n    }\n    t.normalizeEdges();\n\
    \    return t;\n}\n\nTree Tree::caterpillar(int size, int length) {\n    ensure(size\
    \ > 0, \"Number of vertices in the tree must be positive\");\n    ensure(length\
    \ > 0, \"Length of the caterpillar must be positive\");\n    checkLargeParameter(size);\n\
    \    ensure(length <= size);\n    Tree t = Tree::bamboo(length);\n    for (int\
    \ i = length; i < size; ++i) {\n        t.addEdge(rnd.next(length), i);\n    }\n\
    \    t.normalizeEdges();\n    return t;\n}\n\nTree Tree::binary(int size) {\n\
    \    return kary(size, 2);\n}\n\nTree Tree::kary(int size, int k) {\n    ensure(size\
    \ > 0, \"Number of vertices in the tree must be positive\");\n    checkLargeParameter(size);\n\
    \n    Tree t;\n    for (int i = 1; i < size; ++i) {\n        t.addEdge((i - 1)\
    \ / k, i);\n    }\n    t.normalizeEdges();\n    return t;\n}\n\nTree Tree::fromPruferSequence(const\
    \ Array& code) {\n    std::vector<int> degree(code.size() + 2, 1);\n    for (int\
    \ v: code) {\n        ++degree[v];\n    }\n\n    std::set<int> leaves;\n    for\
    \ (size_t v = 0; v != degree.size(); ++v) {\n        if (degree[v] == 1) {\n \
    \           leaves.insert(v);\n        }\n    }\n\n    Tree t;\n    for (int v:\
    \ code) {\n        ENSURE(!leaves.empty());\n        int to = *leaves.begin();\n\
    \        leaves.erase(leaves.begin());\n        if (--degree[v] == 1) {\n    \
    \        leaves.insert(v);\n        }\n\n        t.addEdge(v, to);\n    }\n\n\
    \    ENSURE(leaves.size() == 2u);\n    t.addEdge(*leaves.begin(), *leaves.rbegin());\n\
    \    t.normalizeEdges();\n    return t;\n\n}\n\nvoid Tree::doPrintParents(std::ostream&\
    \ out, const OutputModifier& mod) const {\n    int root = mod.printParents;\n\
    \    if (root == -1) {\n        root = 0;\n    }\n\n    auto parents = this->parents(root);\n\
    \    if (mod.printParents == -1) {\n        parents.erase(parents.begin());\n\
    \    }\n\n    if (mod.printN) {\n        out << n() << \"\\n\";\n    }\n\n   \
    \ // TODO: avoid copy-paste from doPrintEdges\n    if (mod.printWeights && vertexWeights_.hasNonEmpty())\
    \ {\n        auto vertexWeights = prepareWeightArray(vertexWeights_, n());\n \
    \       for (int i = 0; i < n(); ++i) {\n            if (i > 0) {\n          \
    \      out << \" \";\n            }\n            JNGEN_PRINT_NO_MOD(vertexWeights[vertexByLabel(i)]);\n\
    \        }\n        out << \"\\n\";\n    }\n\n    auto t(mod);\n    {\n      \
    \  auto mod(t);\n        mod.printN = false;\n\n        if (mod.printWeights &&\
    \ edgeWeights_.hasNonEmpty()) {\n            ensure(false, \"Printing parents\
    \ and edge weights is not supported\");\n            ensure(\n               \
    \ mod.printParents == -1,\n                \"Root must not be set to any exact\
    \ value when printing a tree \"\n                \"with edge weights. To fix it,\
    \ either set printParents() \"\n                \"or printWeights(false)\");\n\
    \            ENSURE(root == 0);\n            // TODO: some code to be here\n \
    \       } else {\n            JNGEN_PRINT(parents);\n        }\n    }\n}\n\n#undef\
    \ JNGEN_INCLUDE_TREE_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#include <memory>\n\
    #include <set>\n#include <utility>\n#include <vector>\n\nnamespace jngen {\n\n\
    class Graph : public ReprProxy<Graph>, public GenericGraph {\n    using BuilderProxy\
    \ = graph_detail::BuilderProxy;\n    using Traits = graph_detail::Traits;\n\n\
    \    friend class graph_detail::GraphRandom;\n    friend class graph_detail::BuilderProxy;\n\
    \npublic:\n    virtual ~Graph() {}\n    Graph() {}\n\n    Graph(int n) {\n   \
    \     extend(n);\n    }\n\n    Graph(const GenericGraph& gg) : GenericGraph(gg)\
    \ {}\n\n    void setN(int n);\n\n    Graph& shuffle();\n    Graph shuffled() const;\n\
    \    Graph& shuffleAllBut(const Array& except);\n    Graph shuffledAllBut(const\
    \ Array& except) const;\n\n    static BuilderProxy random(int n, int m);\n   \
    \ static BuilderProxy complete(int n);\n    static BuilderProxy empty(int n);\n\
    \    static BuilderProxy cycle(int n);\n    static BuilderProxy randomStretched(\n\
    \            int n, int m, int elongation, int spread);\n    static BuilderProxy\
    \ randomBipartite(int n1, int n2, int m);\n    static BuilderProxy completeBipartite(int\
    \ n1, int n2);\n};\n\ninline void Graph::setN(int n) {\n    ensure(n >= this->n(),\
    \ \"Cannot lessen number of vertices in the graph\");\n    extend(n);\n}\n\ninline\
    \ Graph& Graph::shuffle() {\n    doShuffle();\n    return *this;\n}\n\ninline\
    \ Graph Graph::shuffled() const {\n    Graph g(*this);\n    return g.shuffle();\n\
    }\n\ninline Graph& Graph::shuffleAllBut(const Array& except) {\n    doShuffleAllBut(except);\n\
    \    return *this;\n}\n\ninline Graph Graph::shuffledAllBut(const Array& except)\
    \ const {\n    Graph g(*this);\n    return g.shuffleAllBut(except);\n}\n\nJNGEN_DECLARE_SIMPLE_PRINTER(Graph,\
    \ 2) {\n    t.doPrintEdges(out, mod);\n}\n\nJNGEN_DECLARE_SIMPLE_PRINTER(graph_detail::BuilderProxy,\
    \ 2) {\n    JNGEN_PRINT(t.g());\n}\n\ntemplate<>\nstruct Hash<Graph> {\n    uint64_t\
    \ operator()(const Graph& g) const {\n        return Hash<GenericGraph>{}(g);\n\
    \    };\n};\n\n} // namespace jngen\n\nusing jngen::Graph;\n\nJNGEN_DEFINE_STD_HASH(jngen::Graph);\n\
    \n#ifndef JNGEN_DECLARE_ONLY\n#define JNGEN_INCLUDE_GRAPH_INL_H\n#ifndef JNGEN_INCLUDE_GRAPH_INL_H\n\
    #error File \"graph_inl.h\" must not be included directly.\n#endif\n\n\nnamespace\
    \ jngen {\n\nnamespace graph_detail {\n\nGraph BuilderProxy::g() const {\n   \
    \ return builder_(traits_);\n}\n\nBuilderProxy::operator Graph() const {\n   \
    \ return g();\n}\n\nclass GraphRandom {\n    using BuilderProxy = graph_detail::BuilderProxy;\n\
    \    using Traits = graph_detail::Traits;\n\npublic:\n    GraphRandom() {\n  \
    \      static bool created = false;\n        ensure(!created, \"jngen::GraphRandom\
    \ should be created only once\");\n        created = true;\n    }\n\n    static\
    \ BuilderProxy random(int n, int m) {\n        ensure(\n            n >= 0 &&\
    \ m >= 0,\n            \"Number of vertices and edges in the graph must be nonnegative\"\
    );\n        checkLargeParameter(n);\n        checkLargeParameter(m);\n       \
    \ return BuilderProxy(Traits(n, m), &doRandom);\n    }\n\n    static BuilderProxy\
    \ complete(int n) {\n        ensure(\n            n >= 0,\n            \"Number\
    \ of vertices and edges in the graph must be nonnegative\");\n        checkLargeParameter(n\
    \ * n);\n        return BuilderProxy(Traits(n), [](Traits t) {\n            Graph\
    \ g;\n            g.setN(t.n);\n            if (t.directed) {\n              \
    \  g.directed_ = true;\n            }\n            for (int i = 0; i < t.n; ++i)\
    \ {\n                for (int j = 0; j <= i; ++j) {\n                    if (i\
    \ == j) {\n                        if (t.allowLoops) {\n                     \
    \       g.addEdge(i, j);\n                        }\n                        continue;\n\
    \                    }\n\n                    if (t.directed) {\n            \
    \            if (t.acyclic) {\n                            g.addEdge(i, j);\n\
    \                        } else if (t.allowAntiparallel) {\n                 \
    \           g.addEdge(i, j);\n                            g.addEdge(j, i);\n \
    \                       } else {\n                            if (rnd.next(2))\
    \ {\n                                g.addEdge(i, j);\n                      \
    \      } else {\n                                g.addEdge(j, i);\n          \
    \                  }\n                        }\n                    } else {\n\
    \                        g.addEdge(i, j);\n                    }\n           \
    \     }\n            }\n            g.normalizeEdges();\n            return g;\n\
    \        });\n    }\n\n    static BuilderProxy empty(int n) {\n        ensure(\n\
    \            n >= 0,\n            \"Number of vertices and edges in the graph\
    \ must be nonnegative\");\n        checkLargeParameter(n);\n        return BuilderProxy(Traits(n),\
    \ [](Traits t) {\n            ensure(\n                t.n <= 1 || !t.connected,\n\
    \                \"Empty graph on >1 vertices cannot be connected\");\n      \
    \      Graph g;\n            if (t.directed) {\n                g.directed_ =\
    \ true;\n            }\n            g.setN(t.n);\n            return g;\n    \
    \    });\n    }\n\n    static BuilderProxy cycle(int n) {\n        ensure(\n \
    \           n >= 0,\n            \"Number of vertices and edges in the graph must\
    \ be nonnegative\");\n        checkLargeParameter(n);\n        return BuilderProxy(Traits(n),\
    \ [](Traits t) {\n            Graph g;\n            if (t.directed) {\n      \
    \          g.directed_ = true;\n                ensure(!t.acyclic, \"Cannot generate\
    \ acyclic cycle\");\n            }\n            for (int i = 0; i < t.n; ++i)\
    \ {\n                g.addEdge(i, (i+1)%t.n);\n            }\n            g.normalizeEdges();\n\
    \            return g;\n        });\n    }\n\n    static BuilderProxy randomStretched(\n\
    \            int n, int m, int elongation, int spread)\n    {\n        ensure(\n\
    \            n >= 0 && m >= 0,\n            \"Number of vertices and edges in\
    \ the graph must be nonnegative\");\n        checkLargeParameter(n);\n       \
    \ checkLargeParameter(m);\n        return BuilderProxy(Traits(n, m), [elongation,\
    \ spread](Traits t) {\n            return doRandomStretched(t, elongation, spread);\n\
    \        });\n    }\n\n    static BuilderProxy randomBipartite(int n1, int n2,\
    \ int m) {\n        ensure(\n            n1 >= 0 && n2 >= 0 && m >= 0,\n     \
    \       \"Number of vertices and edges in the graph must be nonnegative\");\n\
    \        checkLargeParameter(n1 + n2);\n        checkLargeParameter(m);\n    \
    \    return BuilderProxy(Traits(0, m), [n1, n2](Traits t) {\n                return\
    \ doRandomBipartite(t, n1, n2);\n        });\n    }\n\n\n    static BuilderProxy\
    \ completeBipartite(int n1, int n2) {\n        ensure(\n            n1 >= 0 &&\
    \ n2 >= 0,\n            \"Number of vertices and edges in the graph must be nonnegative\"\
    );\n        checkLargeParameter(n1 * n2);\n        return BuilderProxy(Traits(0,\
    \ 0), [n1, n2](Traits t) {\n            ensure(!t.directed, \"Directed bipartite\
    \ graphs are not supported\");\n\n            Arrayp edges;\n            edges.reserve(n1\
    \ * n2);\n            for (int u = 0; u < n1; ++u) {\n                for (int\
    \ v = 0; v < n2; ++v) {\n                    edges.emplace_back(u, v + n1);\n\
    \                }\n            }\n\n            Graph g;\n            g.initWithEdges(n1\
    \ + n2, edges);\n            return g;\n        });\n    }\n\nprivate:\n    static\
    \ Graph doRandom(Traits t) {\n        int n = t.n;\n        int m = t.m;\n\n \
    \       if (!t.allowMulti) {\n            ensure(m <= maxEdges(n, t), \"Too many\
    \ edges in the graph\");\n        }\n\n        std::unordered_set<std::pair<int,\
    \ int>> usedEdges;\n\n        if (t.connected) {\n            ensure(m >= n -\
    \ 1, \"Not enough edges for a connected graph\");\n            auto treeEdges\
    \ = Tree::random(n).edges();\n            if (t.directed) {\n                for\
    \ (auto& edge: treeEdges) {\n                    if (rnd.next(2)) {\n        \
    \                std::swap(edge.first, edge.second);\n                    }\n\
    \                }\n            }\n            usedEdges.insert(treeEdges.begin(),\
    \ treeEdges.end());\n            ENSURE(usedEdges.size() == static_cast<size_t>(n\
    \ - 1));\n        }\n\n        auto edgeIsGood = [&usedEdges, t](std::pair<int,\
    \ int> edge) {\n            if (!t.allowMulti && usedEdges.count(edge)) {\n  \
    \              return false;\n            }\n            if (t.directed && !t.allowAntiparallel\
    \ &&\n                    usedEdges.count({edge.second, edge.first}))\n      \
    \      {\n                return false;\n            }\n            return true;\n\
    \        };\n\n        Arrayp result(usedEdges.begin(), usedEdges.end());\n  \
    \      result.reserve(m);\n\n        while (result.size() < static_cast<size_t>(m))\
    \ {\n            auto edge = randomEdge(n, t);\n            if (edgeIsGood(edge))\
    \ {\n                usedEdges.insert(edge);\n                result.push_back(edge);\n\
    \            }\n        }\n\n        Graph graph;\n\n        if (t.directed &&\
    \ t.acyclic) {\n            makeAcyclic(result);\n        }\n        if (t.directed)\
    \ {\n            graph.directed_ = true;\n        }\n\n        graph.initWithEdges(n,\
    \ result);\n        return graph;\n    }\n\n    static Graph doRandomStretched(Traits\
    \ t, int elongation, int spread) {\n        Tree tree = Tree::randomPrim(t.n,\
    \ elongation);\n        Array parents = tree.parents(0);\n        parents[0] =\
    \ 0;\n\n\n        auto treeEdges = tree.edges();\n        if (t.directed && !t.acyclic)\
    \ {\n            for (auto& edge: treeEdges) {\n                if (rnd.next(2))\
    \ {\n                    std::swap(edge.first, edge.second);\n               \
    \ }\n            }\n        }\n\n        Arrayp edges = treeEdges;\n        edges.reserve(t.m);\n\
    \n        std::unordered_set<std::pair<int, int>> usedEdges(\n            treeEdges.begin(),\
    \ treeEdges.end());\n\n        auto edgeIsGood = [&usedEdges, t](std::pair<int,\
    \ int> edge) {\n            if (!t.allowMulti && usedEdges.count(edge)) {\n  \
    \              return false;\n            }\n            if (t.directed && !t.allowAntiparallel\
    \ &&\n                    usedEdges.count({edge.second, edge.first}))\n      \
    \      {\n                return false;\n            }\n            return true;\n\
    \        };\n\n        constexpr size_t MAX_ATTEMPTS = 1000;\n        size_t attemptsToFail\
    \ = MAX_ATTEMPTS;\n\n        while (static_cast<int>(edges.size()) != t.m) {\n\
    \            if (--attemptsToFail == 0) {\n                ensure(false, format(\"\
    Cannot generate random stretched graph \"\n                    \"with parameters\
    \ %d, %d, %d, %d\",\n                    t.n, t.m, elongation, spread));\n   \
    \         }\n            int u = rnd.next(t.n);\n            int up = rnd.next(0,\
    \ spread);\n            int v = u;\n            for (int iter = 0; iter < up;\
    \ ++iter) {\n                v = parents[v];\n            }\n\n            ENSURE(v\
    \ <= u);\n\n            if (!t.allowLoops && u == v) {\n                continue;\n\
    \            }\n\n            if (!edgeIsGood({v, u})) {\n                continue;\n\
    \            }\n\n            if (t.directed && !t.acyclic && rnd.next(2)) {\n\
    \                std::swap(u, v);\n            }\n\n            edges.emplace_back(v,\
    \ u);\n            attemptsToFail = MAX_ATTEMPTS;\n        }\n\n        Graph\
    \ graph;\n        if (t.directed) {\n            graph.directed_ = true;\n   \
    \     }\n\n        graph.initWithEdges(t.n, edges);\n        return graph;\n \
    \   }\n\n    static Graph doRandomBipartite(Traits t, int n1, int n2) {\n    \
    \    int m = t.m;\n\n        if (!t.allowMulti) {\n            ensure(m <= static_cast<long\
    \ long>(n1) * n2,\n                    \"Too many edges in the graph\");\n   \
    \     }\n\n        ensure(!t.directed, \"Directed bipartite graphs are not supported\"\
    );\n\n        std::unordered_set<std::pair<int, int>> usedEdges;\n\n        if\
    \ (t.connected) {\n            ensure(m >= n1 + n2 - 1, \"Not enough edges for\
    \ a connected graph\");\n            auto pruferCode = Array::random(n2 - 1, 0,\
    \ n1 - 1) +\n                Array::random(n1 - 1, n1, n1 + n2 - 1);\n       \
    \     pruferCode.shuffle();\n            auto treeEdges = Tree::fromPruferSequence(pruferCode).edges();\n\
    \            usedEdges.insert(treeEdges.begin(), treeEdges.end());\n         \
    \   ENSURE(usedEdges.size() == static_cast<size_t>(n1 + n2 - 1));\n        }\n\
    \n        auto edgeIsGood = [&usedEdges, t](std::pair<int, int> edge) {\n    \
    \        if (!t.allowMulti && usedEdges.count(edge)) {\n                return\
    \ false;\n            }\n            if (t.directed && !t.allowAntiparallel &&\n\
    \                    usedEdges.count({edge.second, edge.first}))\n           \
    \ {\n                return false;\n            }\n            return true;\n\
    \        };\n\n        Arrayp result(usedEdges.begin(), usedEdges.end());\n  \
    \      result.reserve(m);\n\n        while (result.size() < static_cast<size_t>(m))\
    \ {\n            int u = rnd.next(0, n1 - 1);\n            int v = rnd.next(n1,\
    \ n1 + n2 - 1);\n            std::pair<int, int> edge(u, v);\n            if (edgeIsGood(edge))\
    \ {\n                usedEdges.insert(edge);\n                result.push_back(edge);\n\
    \            }\n        }\n\n        Graph graph;\n\n        graph.initWithEdges(n1\
    \ + n2, result);\n        return graph;\n    }\n\n    static std::pair<int, int>\
    \ randomEdge(int n, const Traits& t) {\n        return rnd.nextp(n, RandomPairTraits{!t.directed,\
    \ !t.allowLoops});\n    }\n\n    static long long maxEdges(int n, const Traits&\
    \ t) {\n        ENSURE(!t.allowMulti);\n        long long res = static_cast<long\
    \ long>(n) * (n-1);\n        if (!(t.directed && t.allowAntiparallel)) {\n   \
    \         res /= 2;\n        }\n        if (t.allowLoops) {\n            res +=\
    \ n;\n        }\n        return res;\n    }\n\n    static void makeAcyclic(Arrayp&\
    \ edges) {\n        auto numbering = Array::id(edges.size()).shuffle();\n    \
    \    for (auto& edge: edges) {\n            if (numbering[edge.first] > numbering[edge.second])\
    \ {\n                std::swap(edge.first, edge.second);\n            }\n    \
    \    }\n    }\n};\n\n} // namespace graph_detail\n\nGraph::BuilderProxy Graph::random(int\
    \ n, int m) {\n    return graph_detail::GraphRandom::random(n, m);\n}\n\nGraph::BuilderProxy\
    \ Graph::complete(int n) {\n    return graph_detail::GraphRandom::complete(n);\n\
    }\n\nGraph::BuilderProxy Graph::empty(int n) {\n    return graph_detail::GraphRandom::empty(n);\n\
    }\n\nGraph::BuilderProxy Graph::cycle(int n) {\n    return graph_detail::GraphRandom::cycle(n);\n\
    }\n\nGraph::BuilderProxy Graph::randomStretched(\n        int n, int m, int elongation,\
    \ int spread) {\n    return graph_detail::GraphRandom::randomStretched(n, m, elongation,\
    \ spread);\n}\n\nGraph::BuilderProxy Graph::randomBipartite(int n1, int n2, int\
    \ m) {\n    return graph_detail::GraphRandom::randomBipartite(n1, n2, m);\n}\n\
    \nGraph::BuilderProxy Graph::completeBipartite( int n1, int n2) {\n    return\
    \ graph_detail::GraphRandom::completeBipartite(n1, n2);\n}\n\n} // namespace jngen\n\
    #undef JNGEN_INCLUDE_GRAPH_INL_H\n#endif // JNGEN_DECLARE_ONLY\n\n\n#include <algorithm>\n\
    #include <cstdlib>\n\nnamespace jngen {\nnamespace suites {\n\nJNGEN_CHAINING_TRAITS(GeneralGraphSuiteTraits,\
    \ allowLoops, allowMulti, connected)\n\nclass GeneralGraphSuite : public BaseTestSuite<Graph,\
    \ GeneralGraphSuiteTraits, int, int> {\n    graph_detail::BuilderProxy&& apply(graph_detail::BuilderProxy&&\
    \ builder) const {\n        builder.allowLoops(conf_._allowLoops);\n        builder.allowMulti(conf_._allowMulti);\n\
    \        builder.connected(conf_._connected);\n        return std::move(builder);\n\
    \    }\n\n    int selectMForRandom(int n, int m, double ratio) const {\n     \
    \   if (conf_._connected) {\n            return std::min(m, n + static_cast<int>((m\
    \ - n + 1) * ratio));\n        } else {\n            return std::max(1, static_cast<int>(m\
    \ * ratio));\n        }\n    }\n\n    Graph randomWithRatio(int n, int m, double\
    \ ratio) const {\n        return apply(Graph::random(n, selectMForRandom(n, m,\
    \ ratio))).g();\n    }\n\npublic:\n    GeneralGraphSuite() : BaseTestSuite(\"\
    GeneralGraphSuite\") {\n#define JNGEN_PRODUCER_ARGS int n, int m\n\n        JNGEN_ADD_PRODUCER(random0.001)\
    \ {\n            return randomWithRatio(n, m, 0.001);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.005)\
    \ {\n            return randomWithRatio(n, m, 0.005);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.01)\
    \ {\n            return randomWithRatio(n, m, 0.01);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.02)\
    \ {\n            return randomWithRatio(n, m, 0.02);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.05)\
    \ {\n            return randomWithRatio(n, m, 0.05);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.1)\
    \ {\n            return randomWithRatio(n, m, 0.1);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.2)\
    \ {\n            return randomWithRatio(n, m, 0.2);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.3)\
    \ {\n            return randomWithRatio(n, m, 0.3);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.4)\
    \ {\n            return randomWithRatio(n, m, 0.4);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.6)\
    \ {\n            return randomWithRatio(n, m, 0.6);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.7)\
    \ {\n            return randomWithRatio(n, m, 0.7);\n        };\n\n        JNGEN_ADD_PRODUCER(random0.9)\
    \ {\n            return randomWithRatio(n, m, 0.9);\n        };\n\n        JNGEN_ADD_PRODUCER(random1)\
    \ {\n            return randomWithRatio(n, m, 1);\n        };\n\n        JNGEN_ADD_PRODUCER(cycle)\
    \ {\n            (void)m;\n            return Graph::cycle(n);\n        };\n\n\
    \        JNGEN_ADD_PRODUCER(complete) {\n            int size = 1;\n         \
    \   while (size <= n && size * (size - 1) / 2 +\n                    (conf_._allowLoops\
    \ ? size : 0) <= m) {\n                ++size;\n            }\n            return\
    \ apply(Graph::complete(size - 1));\n        };\n\n        JNGEN_ADD_PRODUCER(bamboo)\
    \ {\n            (void)m;\n            return Graph(Tree::bamboo(n));\n      \
    \  };\n\n        JNGEN_ADD_PRODUCER(star) {\n            (void)m;\n          \
    \  return Graph(Tree::star(n));\n        };\n\n        JNGEN_ADD_PRODUCER(wheel)\
    \ {\n            Graph g = Tree::star(n);\n            int edges = m - (n - 1);\n\
    \            for (int i = 1; i < n && edges > 0; ++i) {\n                g.addEdge(i,\
    \ i == n-1 ? 1 : i+1);\n            }\n            return g;\n        };\n\n#undef\
    \ JNGEN_PRODUCER_ARGS\n    }\n};\n\n} // namespace test_suites\n} // namespace\
    \ jngen\n\n\n#include <cstdlib>\n\nnamespace jngen {\nnamespace suites {\n\nJNGEN_CHAINING_TRAITS(GeneralTreeSuiteTraits,\
    \ _)\n\nclass GeneralTreeSuite : public BaseTestSuite<Tree, GeneralTreeSuiteTraits,\
    \ int> {\npublic:\n    GeneralTreeSuite() : BaseTestSuite(\"GeneralTreeSuite\"\
    ) {\n#define JNGEN_PRODUCER_ARGS int n\n\n        JNGEN_ADD_PRODUCER(random1)\
    \ {\n            return Tree::random(n);\n        };\n\n        JNGEN_ADD_PRODUCER(random2)\
    \ {\n            return Tree::random(n);\n        };\n\n        JNGEN_ADD_PRODUCER(random3)\
    \ {\n            return Tree::random(n);\n        };\n\n        JNGEN_ADD_PRODUCER(bamboo)\
    \ {\n            return Tree::bamboo(n);\n        };\n\n        JNGEN_ADD_PRODUCER(shuffled_bamboo)\
    \ {\n            return Tree::bamboo(n).shuffled();\n        };\n\n        JNGEN_ADD_PRODUCER(3branches)\
    \ {\n            int k = (n - 1) / 3 + 1;\n\n            Tree t = Tree::bamboo(k);\n\
    \            t = t.glue(0, Tree::bamboo(k), 0);\n            t = t.glue(0, Tree::bamboo(k),\
    \ 0);\n\n            ENSURE(t.n() <= n);\n\n            return t;\n        };\n\
    \n        JNGEN_ADD_PRODUCER(sqrt_branches) {\n            int k = std::sqrt(n)\
    \ + 1;\n            Tree t = Tree::bamboo(k);\n            while (t.n() + k -\
    \ 1 <= n) {\n                t = t.glue(0, Tree::bamboo(k), 0);\n            }\n\
    \            ENSURE(t.n() <= n);\n            return t;\n        };\n\n      \
    \  JNGEN_ADD_PRODUCER(branches_123) {\n            Tree t = Tree::bamboo(2);\n\
    \            for (int i = 2; t.n() + i <= n; ++i) {\n                t = t.link(0,\
    \ Tree::bamboo(i), 0);\n            }\n            ENSURE(t.n() < n);\n      \
    \      return t;\n        };\n\n        JNGEN_ADD_PRODUCER(binary) {\n       \
    \     return Tree::binary(n);\n        };\n\n        JNGEN_ADD_PRODUCER(3ary)\
    \ {\n            return Tree::kary(n, 3);\n        };\n\n        JNGEN_ADD_PRODUCER(4ary)\
    \ {\n            return Tree::kary(n, 4);\n        };\n\n        JNGEN_ADD_PRODUCER(50ary)\
    \ {\n            return Tree::kary(n, 50);\n        };\n\n        JNGEN_ADD_PRODUCER(500ary)\
    \ {\n            return Tree::kary(n, 500);\n        };\n\n        JNGEN_ADD_PRODUCER(star)\
    \ {\n            return Tree::star(n);\n        };\n\n        JNGEN_ADD_PRODUCER(shuffled_star)\
    \ {\n            return Tree::star(n).shuffled();\n        };\n\n        JNGEN_ADD_PRODUCER(caterpillar_len90)\
    \ {\n            return Tree::caterpillar(n, n * 0.9);\n        };\n\n       \
    \ JNGEN_ADD_PRODUCER(caterpillar_len50) {\n            return Tree::caterpillar(n,\
    \ n * 0.5);\n        };\n\n        JNGEN_ADD_PRODUCER(caterpillar_len10) {\n \
    \           return Tree::caterpillar(n, n * 0.1);\n        };\n\n        JNGEN_ADD_PRODUCER(broom_n/2)\
    \ {\n            auto t1 = Tree::bamboo(n/2);\n            auto t2 = Tree::star(n\
    \ - n/2);\n            return t1.link(n/2 - 1, t2, 0);\n        };\n\n       \
    \ JNGEN_ADD_PRODUCER(random_w-100) {\n            return Tree::randomPrim(n, -100);\n\
    \        };\n\n        JNGEN_ADD_PRODUCER(random_w-50) {\n            return Tree::randomPrim(n,\
    \ -50);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w-10) {\n           \
    \ return Tree::randomPrim(n, -10);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w-5)\
    \ {\n            return Tree::randomPrim(n, -5);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w0)\
    \ {\n            return Tree::randomPrim(n, 0);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w5)\
    \ {\n            return Tree::randomPrim(n, 5);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w10)\
    \ {\n            return Tree::randomPrim(n, 10);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w50)\
    \ {\n            return Tree::randomPrim(n, 50);\n        };\n\n        JNGEN_ADD_PRODUCER(random_w100)\
    \ {\n            return Tree::randomPrim(n, 100);\n        };\n\n#undef JNGEN_PRODUCER_ARGS\n\
    \    }\n};\n\n} // namespace test_suites\n} // namespace jngen\n\n\nnamespace\
    \ jngen {\n\nstruct TestSuites {\n    suites::GeneralGraphSuite graph;\n    suites::GeneralTreeSuite\
    \ tree;\n};\n\nJNGEN_EXTERN TestSuites testSuites;\n\n} // namespace jngen\n\n\
    using jngen::testSuites;\n#pragma GCC diagnostic pop // -Wconversion\n#if __clang__major\
    \ >= 5\n#pragma GCC diagnostic pop // -Wunused-lambda-capture\n#endif"
  dependsOn: []
  isVerificationFile: false
  path: tests/jngen.h
  requiredBy:
  - tests/benchmark/PowerSeries.cpp
  - tests/benchmark/bench.h
  - tests/benchmark/PolynomialRing.cpp
  - tests/benchmark/main.cpp
  - tests/stress/PowerSeries.cpp
  - tests/stress/PolynomialRing.cpp
  - tests/stress/main.cpp
  - tests/stress/stress.cpp
  timestamp: '2020-10-20 00:40:28-03:00'
  verificationStatus: LIBRARY_NO_TESTS
  verifiedWith: []
documentation_of: tests/jngen.h
layout: document
redirect_from:
- /library/tests/jngen.h
- /library/tests/jngen.h.html
title: tests/jngen.h
---
